# Chapter 7: Session State for Multi-Step Agent Workflows

Agentic applications often need to keep track of context across multiple user interactions. For example, a diagnostic agent may need to remember a patient‚Äôs reported symptoms, order tests, and later recommend treatments ‚Äî all in the same conversation. Without proper state management, this continuity would break, and every input would be treated as an isolated request.

Streamlit provides `st.session_state`, a persistent dictionary-like object, to store and retrieve values across reruns of the app. This is the key to implementing multi-step workflows.

---

## Why Session State Matters in Agent Workflows

* **Maintain Conversation Context**: Agents can reference earlier user inputs to build consistent responses.
* **Store Intermediate Decisions**: Partial outputs (like ordered tests) can be saved and reused later.
* **Enable Multi-Step Journeys**: From initial triage to treatment recommendation, the workflow unfolds logically.

---

## Core Concepts

1. **Initialization**: Define keys in `st.session_state` to ensure they exist from the start.

   ```python
   if "conversation" not in st.session_state:
       st.session_state.conversation = []
   if "diagnosis_steps" not in st.session_state:
       st.session_state.diagnosis_steps = {}
   ```

2. **Updating State**: After each user interaction, update the stored values.

   ```python
   st.session_state.conversation.append({"user": symptom})
   st.session_state.diagnosis_steps["symptom"] = symptom
   ```

3. **Reading State**: Use the stored data to inform the next step of the workflow.

   ```python
   previous_symptom = st.session_state.diagnosis_steps.get("symptom", None)
   ```

---

## Example: Multi-Step Diagnostic Agent

Below is a simple simulation of a **Diagnostic Agent** workflow with three stages:

* **Step 1**: User provides symptom.
* **Step 2**: Agent suggests a test.
* **Step 3**: Based on test results, agent gives a treatment suggestion.

```python
import streamlit as st

# Initialize session state
if "diagnosis_steps" not in st.session_state:
    st.session_state.diagnosis_steps = {}

st.title("üßë‚Äç‚öïÔ∏è Multi-Step Diagnostic Agent")

# Step 1: Capture symptom
symptom = st.text_input("Enter your main symptom:")

if symptom and "symptom" not in st.session_state.diagnosis_steps:
    st.session_state.diagnosis_steps["symptom"] = symptom
    st.success(f"Symptom recorded: {symptom}")

# Step 2: Suggest a test
if "symptom" in st.session_state.diagnosis_steps and "test" not in st.session_state.diagnosis_steps:
    st.info("Based on your symptom, I recommend a blood test.")
    if st.button("Confirm Test Ordered"):
        st.session_state.diagnosis_steps["test"] = "Blood Test"
        st.success("Blood test ordered ‚úÖ")

# Step 3: Treatment suggestion
if "test" in st.session_state.diagnosis_steps and "treatment" not in st.session_state.diagnosis_steps:
    test_result = st.selectbox("Enter test result:", ["Pending", "Normal", "Abnormal"])
    if test_result == "Abnormal":
        st.session_state.diagnosis_steps["treatment"] = "Antibiotics"
        st.success("Suggested Treatment: Antibiotics üíä")
    elif test_result == "Normal":
        st.session_state.diagnosis_steps["treatment"] = "Rest & Hydration"
        st.success("Suggested Treatment: Rest & Hydration üõå")

# Display conversation state
st.subheader("Conversation Context")
st.json(st.session_state.diagnosis_steps)
```

---

## Key Takeaways

* `st.session_state` ensures persistence across reruns.
* You can design **multi-step workflows** without losing context.
* This technique applies to various use cases: diagnostic flows, research assistants, customer support bots, etc.

---

‚úÖ With **Session State**, your Streamlit apps can act more like **conversational agents**, remembering past interactions and guiding users through structured, multi-step processes.

---

