# **Chapter 15 — Testing and CI/CD**

## **Overview**

Building robust AI-driven applications with **FastAPI + LangServe** requires reliable testing and continuous integration (CI) pipelines to ensure consistent quality, stability, and performance.
This chapter covers how to:

* Write **unit tests** for FastAPI routes and LangServe chains
* Implement **integration tests** for full data flow
* Automate **continuous deployment** using Docker, Uvicorn, and Nginx

---

## **15.1 Writing Unit Tests for FastAPI APIs**

Unit tests validate isolated pieces of functionality — typically individual routes, service functions, or LangChain tools.

### **15.1.1 Setup**

Install the required testing libraries:

```bash
pip install pytest httpx pytest-asyncio
```

Your directory should include a `tests/` folder:

```
project_root/
│
├── app/
│   ├── main.py
│   ├── api/
│   ├── core/
│   └── services/
│
└── tests/
    ├── test_api_routes.py
    └── test_chains.py
```

---

### **15.1.2 Example: Testing a FastAPI Endpoint**

```python
# tests/test_api_routes.py
import pytest
from httpx import AsyncClient
from app.main import app

@pytest.mark.asyncio
async def test_read_health_check():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "ok"}
```

✅ **Key points:**

* Use **AsyncClient** from `httpx` to call async routes.
* `pytest.mark.asyncio` is required for asynchronous test functions.
* Base URL `"http://test"` is a placeholder for in-memory testing.

---

## **15.2 Unit Testing LangServe Chains**

LangServe exposes **LangChain Runnables** as API endpoints.
You can test chains directly or via their mounted endpoints.

### **15.2.1 Testing the Chain Directly**

```python
# tests/test_chains.py
import pytest
from app.chains.summarize import summarize_chain

@pytest.mark.asyncio
async def test_summarize_chain():
    result = await summarize_chain.ainvoke({"text": "LangServe helps deploy LangChain apps easily."})
    assert "LangServe" in result["summary"]
```

### **15.2.2 Testing LangServe Endpoint**

```python
# tests/test_langserve_endpoint.py
from httpx import AsyncClient
from app.main import app

@pytest.mark.asyncio
async def test_langserve_endpoint():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        payload = {"text": "AI can automate diagnostics."}
        response = await ac.post("/api/summarize/invoke", json=payload)
    assert response.status_code == 200
    data = response.json()
    assert "summary" in data["output"]
```

✅ **Tip:**
Always use the `/invoke` suffix when testing LangServe endpoints.

---

## **15.3 Integration Tests for End-to-End Flow**

Integration tests check **multi-component flows**, e.g., database + LangServe + API routes.

### **Example: Testing the Diagnostic Pipeline**

```python
# tests/test_integration_pipeline.py
import pytest
from httpx import AsyncClient
from app.main import app

@pytest.mark.asyncio
async def test_diagnostic_pipeline():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        # Step 1: Create a test patient record
        patient_data = {"name": "John Doe", "age": 35, "symptoms": "fever, cough"}
        res_create = await ac.post("/api/patients", json=patient_data)
        assert res_create.status_code == 201

        # Step 2: Call the diagnostic chain endpoint
        payload = {"patient_id": 1}
        res_diag = await ac.post("/api/diagnose/invoke", json=payload)
        assert res_diag.status_code == 200
        assert "diagnosis" in res_diag.json()["output"]
```

✅ **Best Practice:**
Use a temporary test database (e.g., SQLite in-memory) for isolated integration testing.
You can configure this by using environment variables in `.env.test`.

---

## **15.4 Automating CI with GitHub Actions**

Automation ensures every push or pull request triggers tests and deployment.

### **15.4.1 Example GitHub Workflow**

Create a file `.github/workflows/test-and-build.yml`

```yaml
name: Test and Deploy

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest httpx pytest-asyncio

      - name: Run tests
        run: pytest -v
```

✅ This runs your FastAPI and LangServe tests on every commit.
Failures stop the pipeline, ensuring code stability before deployment.

---

## **15.5 Continuous Deployment with Docker, Uvicorn, and Nginx**

After CI testing, successful builds can be automatically deployed using Docker.

### **15.5.1 Dockerfile Example**

```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY . /app

RUN pip install --no-cache-dir -r requirements.txt

EXPOSE 8000

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### **15.5.2 docker-compose.yml Example**

```yaml
version: "3.9"
services:
  api:
    build: .
    container_name: fastapi_langserve
    restart: always
    ports:
      - "8000:8000"

  nginx:
    image: nginx:latest
    container_name: nginx_proxy
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - api
```

---

### **15.5.3 Nginx Reverse Proxy Configuration**

`nginx.conf`

```nginx
events {}

http {
  server {
    listen 80;

    location / {
      proxy_pass http://api:8000;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
    }
  }
}
```

This setup:

* Routes traffic from port **80 → FastAPI (Uvicorn)**
* Handles **reverse proxying** and potential **SSL termination** (with certbot if needed)

---

## **15.6 Summary**

| Layer             | Tool                     | Purpose                                         |
| ----------------- | ------------------------ | ----------------------------------------------- |
| Unit Tests        | pytest, httpx            | Validate individual routes and LangServe chains |
| Integration Tests | pytest-asyncio           | Verify full request–response flow               |
| CI                | GitHub Actions           | Automate testing and build on commits           |
| CD                | Docker + Uvicorn + Nginx | Containerized deployment and load balancing     |

---

## **15.7 Practice Exercises**

1. Write a unit test for a `/predict` LangServe endpoint that returns a disease prediction.
2. Implement an integration test for your `/register → /diagnose → /summarize` pipeline.
3. Extend your GitHub Action to build a Docker image and push to Docker Hub.
4. Deploy your containerized LangServe app behind Nginx and verify it works on port 80.

---
