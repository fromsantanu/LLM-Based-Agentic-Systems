# **Chapter 3: Database Integration**

---

## **Goal:**

Learn how to integrate a database with your LangServe + FastAPI backend using SQLAlchemy ORM.
Youâ€™ll understand how to **choose the right database**, **create models**, **manage sessions**, and **perform CRUD operations** efficiently â€” both synchronously and asynchronously.

---

## **1. Choosing the Database**

### **For Demos**

* **SQLite** is lightweight, file-based, and easy to set up.
  âœ… Great for prototypes, testing, and single-user systems.

  ```bash
  DATABASE_URL = "sqlite:///./app.db"
  ```

### **For Production**

* **MySQL / MariaDB**
  Reliable for medium-scale deployments.

  ```bash
  DATABASE_URL = "mysql+aiomysql://user:password@localhost/mydb"
  ```
* **PostgreSQL**
  Most robust, enterprise-grade support for async I/O, JSON fields, and concurrency.

  ```bash
  DATABASE_URL = "postgresql+asyncpg://user:password@localhost/mydb"
  ```

ðŸ’¡ **Tip:**
Start with **SQLite** during development, and switch to **PostgreSQL** for production.
SQLAlchemy makes migration easy with **Alembic**.

---

## **2. SQLAlchemy ORM Basics**

### **What is SQLAlchemy?**

SQLAlchemy is the most popular ORM (Object Relational Mapper) for Python.
It lets you define **Python classes** as database tables and interact with them using **objects** instead of raw SQL.

---

### **Model Example**

```python
from sqlalchemy import Column, Integer, String, Boolean
from sqlalchemy.orm import declarative_base

Base = declarative_base()

class Customer(Base):
    __tablename__ = "customers"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100))
    email = Column(String(100), unique=True, index=True)
    is_active = Column(Boolean, default=True)
```

---

### **Creating Tables**

```python
from sqlalchemy import create_engine

DATABASE_URL = "sqlite:///./app.db"
engine = create_engine(DATABASE_URL, echo=True)

Base.metadata.create_all(bind=engine)
```

---

## **3. Session Management**

The **Session** object represents a database transaction.

```python
from sqlalchemy.orm import sessionmaker

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
```

### **Dependency in FastAPI**

```python
from fastapi import Depends

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

You can now inject `db` into any route:

```python
@app.get("/customers")
def list_customers(db: Session = Depends(get_db)):
    return db.query(Customer).all()
```

---

## **4. CRUD Operations**

### **Create**

```python
def create_customer(db, name, email):
    new_customer = Customer(name=name, email=email)
    db.add(new_customer)
    db.commit()
    db.refresh(new_customer)
    return new_customer
```

### **Read**

```python
def get_customer(db, customer_id: int):
    return db.query(Customer).filter(Customer.id == customer_id).first()
```

### **Update**

```python
def update_customer(db, customer_id: int, new_name: str):
    customer = db.query(Customer).filter(Customer.id == customer_id).first()
    if customer:
        customer.name = new_name
        db.commit()
        db.refresh(customer)
    return customer
```

### **Delete**

```python
def delete_customer(db, customer_id: int):
    db.query(Customer).filter(Customer.id == customer_id).delete()
    db.commit()
```

---

## **5. Asynchronous Database Operations**

FastAPI supports **async ORM operations** via `SQLAlchemy 2.0` or **databases** package.

### **Engine and Session Setup**

```python
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker

DATABASE_URL = "sqlite+aiosqlite:///./app.db"

engine = create_async_engine(DATABASE_URL, echo=True)
AsyncSessionLocal = async_sessionmaker(bind=engine, expire_on_commit=False)
```

### **Async Dependency**

```python
async def get_db():
    async with AsyncSessionLocal() as session:
        yield session
```

### **Async CRUD Example**

```python
from sqlalchemy.future import select

async def get_all_customers(db):
    result = await db.execute(select(Customer))
    return result.scalars().all()
```

### **Route Example**

```python
@app.get("/customers", response_model=list[CustomerDTO])
async def read_customers(db: AsyncSession = Depends(get_db)):
    return await get_all_customers(db)
```

---

## **6. Returning Structured DTOs**

DTOs (Data Transfer Objects) help enforce schema consistency between your database and API responses.

```python
from pydantic import BaseModel

class CustomerDTO(BaseModel):
    id: int
    name: str
    email: str
    is_active: bool

    class Config:
        orm_mode = True
```

Using `orm_mode = True` allows SQLAlchemy objects to be automatically converted into DTOs.

Example:

```python
@app.get("/customers/{id}", response_model=CustomerDTO)
def get_customer_by_id(id: int, db: Session = Depends(get_db)):
    return get_customer(db, id)
```

---

## **7. Lab: Build and Test**

### **Goal:**

Create a small working API for customer management.

#### **Steps**

1. Define your model in `models.py`
2. Create DB connection in `database.py`
3. Add CRUD logic in `repositories/customer_repo.py`
4. Create DTOs in `schemas.py`
5. Add endpoints in `routes/customers.py`
6. Run the app:

   ```bash
   uvicorn main:app --reload
   ```
7. Test endpoints using:

   ```
   GET /customers
   POST /customers
   PUT /customers/{id}
   DELETE /customers/{id}
   ```

---

## **8. Summary**

| Concept             | Description                          |
| ------------------- | ------------------------------------ |
| **SQLite**          | Best for demos and development       |
| **SQLAlchemy ORM**  | Maps Python classes to DB tables     |
| **Session**         | Manages transactions                 |
| **CRUD functions**  | Core DB operations                   |
| **Async support**   | For scalable production APIs         |
| **DTOs (Pydantic)** | Ensure consistent data across layers |

---

### âœ… **Youâ€™ve Learned**

* How to pick a database for different environments
* How to define models and sessions with SQLAlchemy
* How to write CRUD logic
* How to integrate async DB calls in FastAPI
* How to return validated and structured DTOs

---
