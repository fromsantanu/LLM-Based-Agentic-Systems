# **Chapter 7: Connecting LangServe to Database Logic**

### ğŸ¯ **Goal**

To make your LangServe endpoints interact with live data sources â€” enabling LangChain agents to perform **CRUD operations** on databases using built-in or custom tools.

LangServe can expose LangChain tools that directly execute SQL queries, retrieve structured results, and send them back through REST endpoints.

---

### ğŸ§© **1. Why Connect LangServe to a Database?**

Most real-world LLM applications need persistent or dynamic data.
Examples:

* Healthcare: Retrieve patient records, lab test results, or hospital resources.
* Education: Get student progress, attendance, or assignment status.
* Sales: Query order history, inventory, or revenue by region.

By integrating your **LangChain tools** with a database and serving them through **LangServe**, you can:

* Query data on-demand from SQL databases.
* Allow AI agents to reason over structured data.
* Maintain full control over query safety and schema constraints.

---

### âš™ï¸ **2. Common Use Cases**

| Use Case      | Description                  | Example Tool                                 |
| ------------- | ---------------------------- | -------------------------------------------- |
| Read/Query    | Retrieve records from SQL DB | `SQLDatabaseToolkit`                         |
| Create/Insert | Add new records              | Custom tool wrapping ORM logic               |
| Update        | Modify existing data         | Tool calling `update_user()` from repository |
| Delete        | Remove records               | Tool calling `delete_entry()` safely         |

---

### ğŸ§  **3. Using SQLDatabaseToolkit with LangChain**

LangChain provides a pre-built set of tools for SQL databases.

#### **Step 1: Install Dependencies**

```bash
pip install langchain langserve langchain-community sqlalchemy sqlite-utils
```

#### **Step 2: Connect to Database**

Example with **SQLite**:

```python
from langchain_community.utilities import SQLDatabase

db = SQLDatabase.from_uri("sqlite:///./data/mydb.sqlite")
```

#### **Step 3: Create Toolkit**

```python
from langchain_community.agent_toolkits import SQLDatabaseToolkit
from langchain_openai import ChatOpenAI

llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)
toolkit = SQLDatabaseToolkit(db=db, llm=llm)
```

This toolkit provides the following default tools:

* `sql_db_list_tables`
* `sql_db_schema`
* `sql_db_query`
* `sql_db_query_checker`

---

### ğŸ§ª **4. Building a LangChain Agent for DB Queries**

```python
from langchain.agents import create_sql_agent

agent = create_sql_agent(
    llm=llm,
    toolkit=toolkit,
    verbose=True
)
```

This `agent` can now answer natural-language queries by converting them into SQL commands and executing them safely.

**Example usage:**

```python
response = agent.invoke({"input": "Show me the total sales by product in 2024"})
print(response["output"])
```

---

### ğŸš€ **5. Exposing the Agent via LangServe**

Create a simple **LangServe endpoint** using `add_routes()`.

#### **main.py**

```python
from fastapi import FastAPI
from langserve import add_routes

from myapp.db_agent import agent  # from above

app = FastAPI(title="LangServe + Database Demo")

add_routes(app, agent, path="/querydb")

# Run: uvicorn main:app --reload
```

Now, you can send HTTP POST requests to:

```
http://127.0.0.1:8000/querydb/invoke
```

Example JSON body:

```json
{
  "input": "List all users who joined after 2023"
}
```

Response:

```json
{
  "output": [
    {"name": "Alice", "joined": "2024-02-10"},
    {"name": "Bob", "joined": "2024-06-21"}
  ]
}
```

---

### ğŸ§° **6. Implementing Custom CRUD Tools**

Sometimes you donâ€™t want LLMs to generate SQL freely (e.g., for sensitive systems).
Instead, wrap **repository functions** or **ORM logic** inside **custom tools**.

#### **Example: Custom Tool for Customer Retrieval**

```python
from langchain.tools import tool
from app.repositories.customer_repo import get_customers

@tool("get_customer_data", return_direct=True)
def get_customer_data(limit: int = 10):
    """Fetch customer records from the database."""
    return get_customers(limit)
```

#### **Repository Layer (customer_repo.py)**

```python
from app.database import SessionLocal
from app.models import Customer

def get_customers(limit: int):
    with SessionLocal() as session:
        return session.query(Customer).limit(limit).all()
```

#### **Integrate with Agent**

```python
from langchain.agents import initialize_agent

tools = [get_customer_data]
agent = initialize_agent(tools, llm, verbose=True)
```

Now, your LangServe endpoint can safely respond to:

```json
{"input": "Fetch 5 customers from the system"}
```

---

### ğŸŒ‰ **7. Combining with FastAPI Controllers**

If your FastAPI app already has controller routes that perform CRUD operations,
you can **reuse those logic functions** by wrapping them as LangChain tools.

Example:

```python
from app.controllers.customer_controller import list_customers

@tool("list_customers_tool", return_direct=True)
def list_customers_tool():
    return list_customers()
```

This ensures:

* Single source of truth for database logic.
* Both REST endpoints and AI agents use consistent business rules.

---

### ğŸ§© **8. Advanced: Hybrid DB + LLM Queries**

Sometimes, structured data (SQL) and unstructured knowledge (LLM) must combine.

You can use a **RunnableMap**:

```python
from langchain.schema.runnable import RunnableMap

chain = RunnableMap({
    "structured": agent,       # SQL agent
    "summary": llm             # Text summarizer
})
```

Example prompt flow:

> â€œFetch last 5 patient reports and summarize key findings.â€

1. SQL agent fetches structured records.
2. LLM summarizes them into readable text.

Expose `chain` with LangServe:

```python
add_routes(app, chain, path="/report_summary")
```

---

### ğŸ§© **9. Lab Exercise**

**Task:**
Create an endpoint `/hospital/query` that:

1. Connects to a `hospital.db` SQLite file.
2. Uses `SQLDatabaseToolkit`.
3. Lets users send natural-language queries like:

   ```
   "Show number of admitted patients in ICU last 7 days"
   ```
4. Returns JSON output.

**Hint:**

* Use `SQLDatabaseToolkit` + `create_sql_agent`.
* Mount with `add_routes(app, agent, path="/hospital/query")`.

---

### ğŸ§­ **10. Key Takeaways**

* LangServe can expose **LLM + SQL database logic** as simple REST APIs.
* Use built-in **SQLDatabaseToolkit** for fast prototyping.
* For production: prefer **custom ORM-based tools** to control access.
* Integrate both **FastAPI controllers** and **LangChain agents** to unify your API and AI logic layers.

---
