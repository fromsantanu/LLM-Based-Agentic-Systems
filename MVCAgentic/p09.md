# **Chapter 9: Choosing a Frontend Framework**

## **Overview**

When building AI-driven applications that combine FastAPI, LangServe, and LangChain, the frontend layer plays a critical role.
It serves as the **“View”** in your **MVC architecture**, connecting the backend intelligence to human users through intuitive dashboards, forms, and visualizations.

Two of the most popular choices for Python developers building such interfaces are **Streamlit** and **Dash**.
Both allow you to quickly create interactive web apps without needing deep frontend (HTML/CSS/JS) expertise — but they differ in focus, flexibility, and scalability.

---

## **9.1 Role of the Frontend in an LLM Application**

An LLM-powered application generally has three layers:

| **Layer**                      | **Purpose**                                                                           | **Typical Technology**             |
| ------------------------------ | ------------------------------------------------------------------------------------- | ---------------------------------- |
| **Model (Backend)**            | Handles AI logic, chains, and database operations                                     | LangServe, LangChain, FastAPI      |
| **Controller (Service Layer)** | Mediates between frontend and backend, handles routes, validation, and business rules | FastAPI endpoints, service classes |
| **View (Frontend)**            | Displays results, manages user input, and provides an interactive dashboard           | Streamlit or Dash                  |

Example flow:

1. User inputs a question on Streamlit/Dash UI.
2. UI sends request → FastAPI endpoint (`/api/llm_query`).
3. LangServe executes a chain/tool and returns the result.
4. UI displays formatted response or visualization.

---

## **9.2 The MVC Mindset**

When combining LangServe, FastAPI, and a frontend framework, think in terms of **Model–View–Controller (MVC)**:

* **Model (M)** → AI and data logic

  * LangChain chains
  * LangServe endpoints (`/api/summarize`, `/api/query_db`)
  * Database ORM models (SQLAlchemy)

* **View (V)** → Frontend visualization

  * Streamlit or Dash UI
  * Graphs, tables, forms, text boxes

* **Controller (C)** → Service and routing logic

  * FastAPI routes (`@app.post("/api/query")`)
  * Pydantic schemas for validation
  * Functions that connect frontend → backend chain calls

This separation ensures modularity — meaning you can later swap the frontend (e.g., replace Streamlit with a React or Next.js UI) without breaking the backend.

---

## **9.3 Streamlit: Simplicity and Speed**

### **Key Features**

* Extremely easy to use — a few lines of Python generate a full UI.
* Ideal for **prototyping**, **research dashboards**, and **LLM demos**.
* Has built-in components for forms, markdown, charts, and chat interfaces.
* Integrates well with **LangChain** and **FastAPI APIs**.

### **Example Integration**

```python
# streamlit_app.py
import streamlit as st
import requests

st.title("AI Summarizer")

user_input = st.text_area("Enter text to summarize:")

if st.button("Summarize"):
    response = requests.post(
        "http://localhost:8000/api/summarize",
        json={"text": user_input}
    )
    st.write("### Summary:")
    st.write(response.json()["summary"])
```

### **Advantages**

✅ Rapid development and deployment
✅ No need for frontend coding
✅ Built-in session handling
✅ Strong community support

### **Limitations**

❌ Limited layout control for complex UI
❌ Not ideal for large multi-page web apps
❌ Less control over styling and custom JS

---

## **9.4 Dash: Control and Scalability**

### **Key Features**

* Built on **Plotly**, making it powerful for interactive data visualization.
* Suitable for **enterprise dashboards** and **production-grade web apps**.
* Uses a callback architecture that links input → output elements.
* Integrates well with APIs (FastAPI endpoints can be used as data sources).

### **Example Integration**

```python
# dash_app.py
from dash import Dash, html, dcc, Input, Output
import requests

app = Dash(__name__)

app.layout = html.Div([
    html.H2("AI Summarizer (Dash)"),
    dcc.Textarea(id='input_text', style={'width': '100%', 'height': 100}),
    html.Button('Summarize', id='submit_btn', n_clicks=0),
    html.Div(id='output_text')
])

@app.callback(
    Output('output_text', 'children'),
    Input('submit_btn', 'n_clicks'),
    Input('input_text', 'value')
)
def update_output(n_clicks, text):
    if n_clicks > 0 and text:
        response = requests.post("http://localhost:8000/api/summarize", json={"text": text})
        return f"Summary: {response.json()['summary']}"
    return ""

if __name__ == '__main__':
    app.run_server(debug=True)
```

### **Advantages**

✅ Advanced layout & styling flexibility
✅ Enterprise-grade and production-ready
✅ Native integration with Plotly charts
✅ Ideal for multi-page analytical apps

### **Limitations**

❌ Slightly steeper learning curve
❌ Requires more setup (callbacks, HTML components)
❌ Slower to prototype than Streamlit

---

## **9.5 Streamlit vs Dash: Side-by-Side Comparison**

| **Feature**                  | **Streamlit**           | **Dash**                  |
| ---------------------------- | ----------------------- | ------------------------- |
| **Ease of Use**              | ★★★★★ (Very simple)     | ★★☆☆☆ (Requires setup)    |
| **UI Flexibility**           | ★★☆☆☆                   | ★★★★★                     |
| **Performance (Large Data)** | Moderate                | High                      |
| **Best For**                 | Prototypes, LLM Demos   | Enterprise Dashboards     |
| **Custom Components**        | Limited                 | Extensive                 |
| **Styling Control**          | Minimal                 | Full CSS/JS support       |
| **Learning Curve**           | Beginner-friendly       | Intermediate/Advanced     |
| **Integration with FastAPI** | Simple REST calls       | Flexible callbacks + REST |
| **Deployment**               | Streamlit Cloud, Docker | Dash Enterprise, Docker   |

---

## **9.6 Recommended Strategy**

* **For Quick LLM App Prototypes:**
  Use **Streamlit**. Perfect for showing results of LangChain chains, chat interfaces, or summarization tools.

* **For Scalable, Multi-User Systems:**
  Use **Dash** with FastAPI (controller) + LangServe (model).
  This structure gives you complete control over data visualization, routing, and user management.

---

## **9.7 Example: MVC in Action**

Below is a simple conceptual flow of how all parts fit together:

```
          ┌───────────────────────┐
          │   Streamlit / Dash    │   ← View
          │  (Frontend UI)        │
          └────────┬──────────────┘
                   │   JSON (POST)
                   ▼
          ┌───────────────────────┐
          │ FastAPI Controller    │   ← Controller
          │ (Routes, Validation)  │
          └────────┬──────────────┘
                   │   invoke()
                   ▼
          ┌───────────────────────┐
          │  LangServe Endpoint   │   ← Model
          │  (LLM Chain Logic)    │
          └───────────────────────┘
```

Example request:

```bash
POST /api/summarize
{
  "text": "Your long paragraph here..."
}
```

Result displayed in Streamlit/Dash:

> “This paragraph summarizes the idea of separating concerns using MVC in LangServe-based AI systems.”

---

## **9.8 Summary**

| **Concept**       | **Key Takeaway**                                                |
| ----------------- | --------------------------------------------------------------- |
| **Frontend role** | Manages user interaction and displays model outputs             |
| **Streamlit**     | Best for rapid prototyping and simplicity                       |
| **Dash**          | Best for scalability, enterprise dashboards, and data-rich apps |
| **MVC alignment** | Model → LangServe; Controller → FastAPI; View → Streamlit/Dash  |
| **Integration**   | Frontend calls FastAPI → FastAPI calls LangServe chain          |

---
