# **Chapter 2 — FastAPI Fundamentals (for LangServe Users)**

### 🎯 **Goal:**

Understand the structure, routing, and data-handling concepts of FastAPI — the foundation on which LangServe exposes LLM chains as API endpoints.

---

## **2.1 FastAPI Structure & Routing**

### 🧩 What is FastAPI?

FastAPI is a **modern Python web framework** for building **APIs** quickly and efficiently. It’s:

* **Asynchronous** (built on Starlette & Pydantic)
* **Type-safe** (uses Python typing for validation)
* **Automatic docs** via Swagger UI and ReDoc

### 📁 Typical Folder Structure

When working with LangServe, you often embed FastAPI inside a modular project.

```
my_app/
│
├── main.py              # Entry point
├── routers/
│   ├── health.py        # Example endpoint
│   └── chain_api.py     # LangServe endpoints
├── models/              # Pydantic models
│   └── schema.py
├── services/            # Business logic or LangChain services
├── config/              # Configuration and environment
└── utils/               # Helper functions
```

### 🧭 Routing Basics

Each route (endpoint) connects a URL path to a function.

```python
# routers/health.py
from fastapi import APIRouter

router = APIRouter()

@router.get("/health")
def health_check():
    return {"status": "ok"}
```

Then include this in your main application:

```python
# main.py
from fastapi import FastAPI
from routers import health

app = FastAPI(title="LangServe Integration API")

app.include_router(health.router, prefix="/api")
```

✅ **Try it:**
Run the server:

```bash
uvicorn main:app --reload
```

Then open: [http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs)

---

## **2.2 Request & Response Models (Pydantic)**

### 📦 Why Pydantic?

Pydantic ensures data integrity by **validating** and **parsing** request/response data automatically.

### ✍️ Example Models

```python
# models/schema.py
from pydantic import BaseModel, Field

class QueryRequest(BaseModel):
    query: str = Field(..., example="Summarize this paragraph")

class QueryResponse(BaseModel):
    result: str
    tokens_used: int
```

### 🚦 Using Models in Routes

```python
# routers/chain_api.py
from fastapi import APIRouter
from models.schema import QueryRequest, QueryResponse

router = APIRouter()

@router.post("/process", response_model=QueryResponse)
async def process_query(request: QueryRequest):
    # (Imagine calling a LangChain chain here)
    return QueryResponse(result=f"Processed: {request.query}", tokens_used=15)
```

FastAPI automatically:

* Parses JSON into `QueryRequest`
* Validates field types
* Generates OpenAPI docs
* Serializes `QueryResponse` as JSON

---

## **2.3 Dependency Injection in FastAPI**

### 🧠 Concept

Dependency Injection (DI) lets you **reuse shared components** like database sessions, configs, or chain clients without passing them manually in every route.

### ⚙️ Example

```python
# config/dependencies.py
from fastapi import Depends

def get_config():
    return {"model_name": "gpt-4o-mini"}

# routers/chain_api.py
from fastapi import Depends, APIRouter
from config.dependencies import get_config

router = APIRouter()

@router.get("/info")
def model_info(config = Depends(get_config)):
    return {"model_in_use": config["model_name"]}
```

✅ **Benefit:**
Clean separation of setup logic and endpoint logic — perfect for scalable LangServe + FastAPI systems.

---

## **2.4 Handling CORS & Middleware for Frontend Integration**

When integrating with **Streamlit**, **Dash**, or **React** frontends, you must allow **cross-origin requests**.

### 🌐 Add CORS Middleware

```python
# main.py
from fastapi.middleware.cors import CORSMiddleware
from fastapi import FastAPI

app = FastAPI()

origins = [
    "http://localhost:3000",  # React
    "http://localhost:8501",  # Streamlit
    "http://127.0.0.1:8050",  # Dash
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

✅ **Why it matters:**
Without CORS, browsers block API calls from other origins (like your frontend dashboard).

---

## **2.5 Mini Lab — Build a LangServe-Compatible FastAPI**

**Goal:** Create a basic FastAPI backend ready for LangServe endpoints and frontend dashboards.

**Steps:**

1. Create the project folders:

   ```bash
   mkdir -p my_app/{routers,models,config}
   ```
2. Add `main.py`, `routers/health.py`, `routers/chain_api.py`, `models/schema.py`.
3. Add simple endpoints for `/api/health` and `/api/process`.
4. Add CORS middleware for Streamlit or Dash.
5. Run:

   ```bash
   uvicorn main:app --reload
   ```
6. Test using [http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs)

---

## **2.6 Summary**

| Concept                  | Purpose                | Example                    |
| ------------------------ | ---------------------- | -------------------------- |
| **Routing**              | Connect URL → function | `@app.get("/path")`        |
| **Pydantic Models**      | Data validation        | `class Request(BaseModel)` |
| **Dependency Injection** | Shared components      | `Depends(get_db)`          |
| **CORS**                 | Frontend integration   | `CORSMiddleware`           |

---

