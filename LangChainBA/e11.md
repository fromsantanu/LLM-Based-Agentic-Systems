Let’s design (and implement) a **medical triage bot** that:

1. **Retrieves medical guidelines** with RAG,
2. **Calls a drug-interaction API/tool**, and
3. **Explains results** clearly (and flags escalation).

> ⚕️ **Safety note**: This is an educational demo, not medical advice. Always consult a clinician.

---

# What we’ll build

* **Inputs**: patient complaint + vitals + meds + allergies.
* **Workflow (LangGraph)**:

  * `intake → red_flag_check → retrieve_guidelines → drug_interactions → reasoning → explanation`
  * Branch to `escalate` when red flags present (e.g., chest pain + hypotension).
* **Tools**:

  * `RAGRetriever`: Chroma/FAISS over local PDF/DOCX clinical guidelines.
  * `DrugInteractionTool`: mock HTTP client (swap with real API later).
* **Outputs**: short triage assessment, interaction risks, guideline citations, and escalation decision.

---

# 1) Setup & Indexing (RAG over PDFs / DOCX / HTML)

```python
# === env & imports ===
from typing import List, Dict, Any, TypedDict, Optional
import os
from langchain_community.document_loaders import PyPDFLoader, UnstructuredWordDocumentLoader, UnstructuredHTMLLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import Chroma  # or FAISS
from langchain_openai import OpenAIEmbeddings, ChatOpenAI
from langchain.schema import Document

# === load multi-format guidelines ===
def load_guidelines(paths: List[str]) -> List[Document]:
    docs = []
    for p in paths:
        ext = os.path.splitext(p)[1].lower()
        if ext == ".pdf":
            docs += PyPDFLoader(p).load()
        elif ext in [".docx", ".doc"]:
            docs += UnstructuredWordDocumentLoader(p).load()
        elif ext in [".html", ".htm"]:
            docs += UnstructuredHTMLLoader(p).load()
        else:
            print(f"Skipping unsupported: {p}")
    return docs

raw_docs = load_guidelines([
    "guidelines/primary_care_chest_pain.pdf",
    "guidelines/uti_management.docx",
    "guidelines/antibiotic_stewardship.html",
])

# === chunk & index ===
splitter = RecursiveCharacterTextSplitter(chunk_size=1200, chunk_overlap=200)
chunks = splitter.split_documents(raw_docs)

embeddings = OpenAIEmbeddings()  # or SentenceTransformersEmbeddings(model_name="all-MiniLM-L6-v2")
vectordb = Chroma(collection_name="guidelines", embedding_function=embeddings)
vectordb.add_documents(chunks)

retriever = vectordb.as_retriever(search_kwargs={"k": 4})
```

> Swap `OpenAIEmbeddings` with any local embedding model if needed.

---

# 2) Tools: Drug-Interaction API (mock) + Red-flag checker

```python
# === drug interaction tool (mock) ===
# Replace this with real service call (e.g., openFDA, RxNorm+Micromedex, or a hospital DB)
MOCK_INTERACTIONS = {
    ("amoxicillin", "warfarin"): {"severity": "moderate", "note": "Antibiotics may increase INR; monitor closely."},
    ("ciprofloxacin", "tizanidine"): {"severity": "contraindicated", "note": "CYP1A2 inhibition → profound hypotension/sedation."},
    ("nitrofurantoin", "magnesium trisilicate"): {"severity": "minor", "note": "Antacids may reduce nitrofurantoin absorption."},
}

def check_interactions(meds: List[str]) -> List[Dict[str, str]]:
    meds_norm = [m.strip().lower() for m in meds]
    results = []
    for i in range(len(meds_norm)):
        for j in range(i+1, len(meds_norm)):
            pair = (meds_norm[i], meds_norm[j])
            pair_rev = (meds_norm[j], meds_norm[i])
            if pair in MOCK_INTERACTIONS:
                d = MOCK_INTERACTIONS[pair]
                results.append({"a": pair[0], "b": pair[1], **d})
            elif pair_rev in MOCK_INTERACTIONS:
                d = MOCK_INTERACTIONS[pair_rev]
                results.append({"a": pair_rev[0], "b": pair_rev[1], **d})
    return results

# === simple red-flag rule set (extend as needed) ===
def red_flags(cc: str, vitals: Dict[str, Any]) -> List[str]:
    cc_low = cc.lower()
    flags = []
    if "chest pain" in cc_low and vitals.get("systolic_bp", 999) < 90:
        flags.append("Chest pain with hypotension")
    if "shortness of breath" in cc_low and vitals.get("spo2", 100) < 90:
        flags.append("Dyspnea with hypoxia")
    if vitals.get("hr", 0) > 130:
        flags.append("Tachycardia >130 bpm")
    if vitals.get("temp", 0) >= 40:
        flags.append("Hyperpyrexia ≥40°C")
    return flags
```

---

# 3) Prompts (concise, guideline-grounded)

```python
from langchain.prompts import ChatPromptTemplate

TRIAGE_PROMPT = ChatPromptTemplate.from_messages([
    ("system",
     "You are a cautious clinical triage assistant. "
     "Use ONLY retrieved guideline context and tool outputs. "
     "Do not diagnose; focus on urgency, next steps, and safety. "
     "If red flags exist, recommend immediate escalation."),
    ("human",
     "Patient:\n- Chief complaint: {cc}\n- Vitals: {vitals}\n- Medications: {meds}\n- Allergies: {allergies}\n\n"
     "Retrieved guidelines:\n{guideline_context}\n\n"
     "Drug interactions:\n{interactions}\n\n"
     "Task: Provide a short triage assessment (3-6 bullets), include safety advice, and cite guideline snippets (by title/page if available).")
])

ESCALATION_PROMPT = ChatPromptTemplate.from_messages([
    ("system",
     "You are a triage escalation assistant. Explain clearly why escalation is necessary, "
     "link to guideline rationales, and advise the safest immediate action."),
    ("human",
     "Red flags: {flags}\nChief complaint: {cc}\nVitals: {vitals}\nGuidelines:\n{guideline_context}\n"
     "Provide a crisp explanation (2-4 bullets) and what to do now.")
])
```

---

# 4) LangGraph Workflow

```python
from langgraph.graph import StateGraph, END
from dataclasses import dataclass, field

@dataclass
class TriageState:
    cc: str
    vitals: Dict[str, Any]
    meds: List[str]
    allergies: List[str]
    flags: List[str] = field(default_factory=list)
    guideline_context: str = ""
    interactions: List[Dict[str, str]] = field(default_factory=list)
    assessment: Optional[str] = None
    escalated: bool = False

llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)  # choose your model

def node_intake(state: TriageState) -> TriageState:
    # (Here we assume inputs already validated; add schema checks in production)
    return state

def node_redflags(state: TriageState) -> TriageState:
    state.flags = red_flags(state.cc, state.vitals)
    return state

def node_retrieve_guidelines(state: TriageState) -> TriageState:
    # Build a focused query for retrieval
    q = f"{state.cc}; vitals={state.vitals}; meds={', '.join(state.meds)}; allergies={', '.join(state.allergies)}"
    docs = retriever.get_relevant_documents(q)
    # compact guideline context (title/page if available)
    parts = []
    for d in docs:
        title = d.metadata.get("source", "guideline")
        page = d.metadata.get("page", None)
        cite = f"{title}" + (f", p.{page}" if page is not None else "")
        parts.append(f"[{cite}] {d.page_content[:800]}")
    state.guideline_context = "\n\n".join(parts[:4])
    return state

def node_interactions(state: TriageState) -> TriageState:
    state.interactions = check_interactions(state.meds)
    return state

def node_reasoning(state: TriageState) -> TriageState:
    interactions_str = "\n".join([f"- {i['a']} + {i['b']}: {i['severity']} — {i['note']}" for i in state.interactions]) or "None found."
    msg = TRIAGE_PROMPT.format_messages(
        cc=state.cc, vitals=state.vitals, meds=state.meds, allergies=state.allergies,
        guideline_context=state.guideline_context, interactions=interactions_str
    )
    resp = llm.invoke(msg)
    state.assessment = resp.content
    return state

def node_escalate(state: TriageState) -> TriageState:
    state.escalated = True
    msg = ESCALATION_PROMPT.format_messages(
        flags="; ".join(state.flags), cc=state.cc, vitals=state.vitals,
        guideline_context=state.guideline_context
    )
    resp = llm.invoke(msg)
    # Prepend escalation banner
    state.assessment = ("**🚑 Escalation Recommended**\n" + resp.content)
    return state

# === graph ===
graph = StateGraph(TriageState)
graph.add_node("intake", node_intake)
graph.add_node("redflag_check", node_redflags)
graph.add_node("retrieve_guidelines", node_retrieve_guidelines)
graph.add_node("drug_interactions", node_interactions)
graph.add_node("reasoning", node_reasoning)
graph.add_node("escalate", node_escalate)

graph.set_entry_point("intake")
graph.add_edge("intake", "redflag_check")
graph.add_edge("redflag_check", "retrieve_guidelines")
graph.add_edge("retrieve_guidelines", "drug_interactions")

# Conditional branch: escalate if any red flags
def should_escalate(state: TriageState) -> str:
    return "escalate" if len(state.flags) > 0 else "reasoning"

graph.add_conditional_edges("drug_interactions", should_escalate, {
    "escalate": "escalate",
    "reasoning": "reasoning"
})

graph.add_edge("escalate", END)
graph.add_edge("reasoning", END)

app = graph.compile()
```

---

# 5) Try it (two demos)

### A) **Non-emergent UTI-like symptoms** with benign interactions

```python
state = TriageState(
    cc="Dysuria and frequency for 2 days, mild suprapubic pain; afebrile.",
    vitals={"temp": 37.2, "hr": 92, "systolic_bp": 118, "spo2": 98},
    meds=["nitrofurantoin", "magnesium trisilicate"],  # minor interaction in mock
    allergies=["sulfa"]
)
result = app.invoke(state)
print(result.assessment)
```

**What you should see (example)**

* Likely **no escalation**, brief guidance like:

  * “Features suggest uncomplicated lower UTI; afebrile and stable vitals.”
  * “Minor interaction: antacid may reduce nitrofurantoin absorption—separate dosing by ≥2h.”
  * “Hydration; follow local antibiotic stewardship; safety-net signs (fever ≥38.5°C, flank pain, vomiting).”
  * Citations: guideline titles/pages pulled by RAG.

---

### B) **Chest pain + hypotension** → escalation path

```python
state2 = TriageState(
    cc="Acute chest pain radiating to left arm, nausea.",
    vitals={"temp": 37.1, "hr": 122, "systolic_bp": 82, "spo2": 95},
    meds=["aspirin", "nitroglycerin"],
    allergies=[]
)
result2 = app.invoke(state2)
print(result2.assessment)
```

**What you should see (example)**
A clear escalation block, e.g.:

* **🚑 Escalation Recommended**
* “Chest pain with hypotension is a red flag for ACS/cardiogenic compromise.”
* “Immediate ED transfer, continuous monitoring, IV access, 12-lead ECG, troponin per guideline.”
* Brief rationale with snippets (titles/pages) from your chest pain guideline PDF.

---

# 6) Swapping the mock Drug Interaction tool with a real API

Replace `check_interactions` with a real client:

```python
import requests

def check_interactions_real(meds: List[str]) -> List[Dict[str, str]]:
    # Example sketch (pseudocode; adapt to vendor API)
    results = []
    for i in range(len(meds)):
        for j in range(i+1, len(meds)):
            a, b = meds[i], meds[j]
            # resp = requests.get("https://vendor.api/interaction", params={"drugA": a, "drugB": b}, timeout=10)
            # data = resp.json()
            # results.append({"a": a, "b": b, "severity": data["severity"], "note": data["summary"]})
            pass
    return results
```

Then swap in `node_interactions`:

```python
def node_interactions(state: TriageState) -> TriageState:
    state.interactions = check_interactions_real(state.meds)
    return state
```

---

# 7) Production hardening checklist

* **PHI/PII**: redact/Hash; store minimal data; encrypt transit & rest.
* **Model safety**: system prompts that forbid diagnosis; keep language cautious.
* **Guideline freshness**: auto-reindex monthly; store doc titles, versions, dates.
* **Citations**: return doc ID + page/span for auditability.
* **Human-in-the-loop**: mandatory clinician review for medium/high-risk cases.
* **Observability**: log state + tool I/O (with redaction), add trace IDs.
* **Fallbacks**: if retriever empty → safe default advice + “unable to locate guideline.”
* **Latency**: cache embeddings, use small context windows, parallelize retrieval and interactions.

---

## TL;DR

You now have a **LangGraph triage pipeline** that (1) grounds on **multi-format guidelines (PDF/DOCX/HTML)** via **RAG**, (2) consults a **drug-interaction tool**, and (3) delivers **concise, safety-focused explanations**—escalating when red flags appear. Plug in your real guideline corpus and a production drug-interaction API to go from **tutorial** → **clinic-ready (with supervision)**.

