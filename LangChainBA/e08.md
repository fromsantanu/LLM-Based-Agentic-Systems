Let’s build and **explain + solve** the example end-to-end.

---

# Example: Weather Agent (API + Natural-Language Answers)

We’ll create a LangChain agent that:

1. understands a user’s natural-language weather question,
2. calls a real weather API, and
3. replies in clear prose with useful details.

We’ll use **Open-Meteo** (free, no API key) + its **Geocoding API** to convert city → latitude/longitude.

---

## How it works (at a glance)

1. **Tool:** `get_weather(city, date)`

   * Uses Open-Meteo Geocoding → `lat/lon`
   * Calls Open-Meteo Forecast API → hourly/daily data
   * Returns a compact, structured JSON summary (temp, precip chance, wind, etc.)

2. **Agent:** LLM with the weather tool attached

   * The LLM reads the user’s question
   * Decides when to call the tool
   * Converts the tool’s JSON into a friendly answer

---

## Full, runnable code (Python)

> Works with: `langchain>=0.2`, `langchain-openai`, `requests`.
> Set `OPENAI_API_KEY` in your environment (or swap in a local model).

```python
# weather_agent.py
import os
import datetime as dt
from typing import Optional, Dict, Any

import requests
from langchain_openai import ChatOpenAI
from langchain_core.tools import tool
from langchain.agents import initialize_agent, AgentType, Tool
from langchain_core.prompts import ChatPromptTemplate

# =========
# 1) Low-level API helpers (Open-Meteo)
# =========

GEO_URL = "https://geocoding-api.open-meteo.com/v1/search"
FORECAST_URL = "https://api.open-meteo.com/v1/forecast"

def geocode_city(city: str) -> Optional[Dict[str, Any]]:
    """Return first geocoding match: {name, country, lat, lon} or None."""
    r = requests.get(GEO_URL, params={"name": city, "count": 1})
    r.raise_for_status()
    data = r.json()
    if not data.get("results"):
        return None
    res = data["results"][0]
    return {
        "name": res.get("name"),
        "country": res.get("country"),
        "lat": res.get("latitude"),
        "lon": res.get("longitude"),
    }

def fetch_forecast(lat: float, lon: float, date: str) -> Dict[str, Any]:
    """
    Fetch daily + hourly weather. date: 'YYYY-MM-DD'.
    We request a single day window [date, date].
    """
    params = {
        "latitude": lat,
        "longitude": lon,
        "timezone": "auto",
        "start_date": date,
        "end_date": date,
        "hourly": "temperature_2m,precipitation_probability,wind_speed_10m",
        "daily": "temperature_2m_max,temperature_2m_min,precipitation_probability_max,wind_speed_10m_max",
    }
    r = requests.get(FORECAST_URL, params=params, timeout=20)
    r.raise_for_status()
    return r.json()

def summarize_forecast(api_json: Dict[str, Any]) -> Dict[str, Any]:
    """Return a compact summary from Open-Meteo JSON."""
    daily = api_json.get("daily", {})
    hourly = api_json.get("hourly", {})
    tz = api_json.get("timezone", "local")

    summary = {
        "timezone": tz,
        "date": daily.get("time", ["?"])[0] if daily.get("time") else "?",
        "t_max": daily.get("temperature_2m_max", [None])[0],
        "t_min": daily.get("temperature_2m_min", [None])[0],
        "precip_prob_max": daily.get("precipitation_probability_max", [None])[0],
        "wind_max": daily.get("wind_speed_10m_max", [None])[0],
        "hourly_sample": []
    }

    # Give a few representative hourly points (morning, afternoon, evening)
    for want in ["09:00", "15:00", "21:00"]:
        # Find nearest hour index
        times = hourly.get("time", [])
        idx = next((i for i, t in enumerate(times) if t.endswith(want)), None)
        if idx is not None:
            summary["hourly_sample"].append({
                "time": times[idx],
                "temp": hourly.get("temperature_2m", [None])[idx],
                "precip_prob": hourly.get("precipitation_probability", [None])[idx],
                "wind": hourly.get("wind_speed_10m", [None])[idx],
            })
    return summary


# =========
# 2) LangChain Tool
# =========

@tool("get_weather", return_direct=False)
def get_weather(city: str, date: Optional[str] = None) -> Dict[str, Any]:
    """
    Get a compact weather summary for a city on a given date.

    Args:
        city: City name (e.g., "Oxford", "Kolkata", "New York").
        date: Optional 'YYYY-MM-DD'. If not provided, uses today's date in the city's local timezone.

    Returns:
        JSON dict summarizing key weather fields:
        {
          "place": {"name": "...", "country": "...", "lat": ..., "lon": ...},
          "summary": {
             "timezone": "...",
             "date": "YYYY-MM-DD",
             "t_max": float, "t_min": float,
             "precip_prob_max": int, "wind_max": float,
             "hourly_sample": [{time, temp, precip_prob, wind}, ...]
          }
        }
    """
    if not city or not isinstance(city, str):
        return {"error": "Please provide a valid city name."}

    place = geocode_city(city)
    if not place:
        return {"error": f"Could not find the city '{city}'."}

    # If no date provided, use today's date (UTC). Open-Meteo will shift to local tz internally.
    if not date:
        date = dt.datetime.utcnow().date().isoformat()

    try:
        raw = fetch_forecast(place["lat"], place["lon"], date)
        summary = summarize_forecast(raw)
        return {"place": place, "summary": summary}
    except requests.HTTPError as e:
        return {"error": f"API error: {e.response.status_code} {e.response.text[:200]}"}
    except requests.RequestException as e:
        return {"error": f"Network error: {str(e)}"}
    except Exception as e:
        return {"error": f"Unexpected error: {str(e)}"}


# =========
# 3) Agent setup
# =========

def build_agent(model_name: str = "gpt-4o-mini") -> Any:
    llm = ChatOpenAI(model=model_name, temperature=0)
    tools = [Tool.from_function(get_weather)]
    # We’ll use the ReAct-style agent that plans tool calls via function descriptions
    agent = initialize_agent(
        tools=tools,
        llm=llm,
        agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
        verbose=True,
        handle_parsing_errors=True,
    )
    return agent

# =========
# 4) Example usage
# =========

if __name__ == "__main__":
    # Ensure OPENAI_API_KEY is set, or swap in your preferred LLM.
    if not os.getenv("OPENAI_API_KEY"):
        print("Warning: OPENAI_API_KEY not set. Set it or swap in a local model.")
    agent = build_agent()

    # Natural language queries:
    q1 = "What's the weather in Oxford today? Do I need an umbrella and how windy will it be?"
    q2 = "Kolkata weather on 2025-09-24: max/min temperature and chance of rain?"

    print("\nQ1:", q1)
    print(agent.run(q1))

    print("\nQ2:", q2)
    print(agent.run(q2))
```

---

## Why this design works

* **Reliable geocoding:** City → `lat/lon` via Open-Meteo Geocoding (avoids API-key hassles).
* **Focused data pull:** We request only what we need (temps, precip prob, wind), for a **single date** to keep responses snappy.
* **LLM as explainer, not calculator:** The tool returns **structured JSON**; the LLM’s job is to turn that into a friendly answer (“Carry an umbrella; winds peak around 25 km/h.”).
* **Error paths handled:** City not found, network errors, HTTP errors → graceful messages.

---

## Upgrades you can add

* **Unit tests** for `summarize_forecast` using saved JSON.
* **Caching** (e.g., `requests_cache`) to reduce repeat calls.
* **Date range** support (e.g., 3-day outlook).
* **Localization** (units: °C/°F, km/h/mph).
* **Router** to handle non-weather queries (“If it’s not weather, answer generically or route to other tools”).

---

## Quick test prompts

* “Weather in **Delhi** tomorrow morning—umbrella or not?”
* “Give me **max/min temps** and **wind** for **Bengaluru** today.”
* “I’m traveling to **New York** on **2025-10-02**—what’s the chance of rain?”

---

