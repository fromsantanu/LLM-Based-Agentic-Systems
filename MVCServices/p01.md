# **Chapter 1: Project Structure & Layering**

### 🎯 **Goal**

To understand how to organize an application so that the **User Interface (UI)**, **Controller (logic)**, and **Model (data)** remain clearly separated.
This modular design ensures:

* **Scalability** – adding new pages or features is easy.
* **Maintainability** – logic is reusable, and UI is less cluttered.
* **Testability** – each layer can be verified independently.

---

## 🧱 1. Understanding MVC in the Context of Dash / Streamlit

Traditional MVC (Model-View-Controller) translates naturally to modern Python web frameworks:

| MVC Component                    | Role                                                                                  | In Dash / Streamlit Context                                                                              |
| -------------------------------- | ------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| **Model**                        | Defines and manages data (schemas, database logic, business entities).                | Classes, schemas, or helper functions that fetch or process data.                                        |
| **View (UI)**                    | Handles how information is presented to the user.                                     | Streamlit pages, Dash layouts, charts, forms, or tables.                                                 |
| **Controller (Service / Logic)** | Orchestrates data flow between model and view; performs validation, triggers actions. | Functions or classes that fetch data from the model and pass it to UI, often in a `controllers/` folder. |

**Example Flow**
→ UI event (button click) → **Controller** calls → **Model** → returns processed data → displayed by **View**.

---

## 📂 2. Folder Layout

Below is a clean baseline structure for a small Streamlit / Dash MVC-style project:

```
my_app/
│
├── app.py                   # Entry point; loads pages or routes
│
├── views/                   # User Interface layer
│   ├── home_view.py
│   ├── report_view.py
│   └── __init__.py
│
├── controllers/             # Control & business logic layer
│   ├── report_controller.py
│   ├── auth_controller.py
│   └── __init__.py
│
├── models/                  # Data layer
│   ├── user_model.py
│   ├── sales_model.py
│   └── __init__.py
│
├── services/                # Optional: reusable utilities (DB connectors, API clients)
│   └── db_service.py
│
├── helpers/                 # Common helper functions (validators, formatters)
│   └── utils.py
│
└── requirements.txt
```

**Import rules**

* Views → Controllers ✅
* Controllers → Models ✅
* Models → Services ✅
* Never import upward (e.g., Model → Controller ❌) — it creates **circular dependencies**.

---

## 🔄 3. Avoiding Cyclic Imports

Cyclic imports happen when:

```python
# report_controller.py
from models import sales_model

# sales_model.py
from controllers import report_controller  # ❌ circular dependency
```

**Fix it by:**

* Moving shared logic into `helpers/utils.py`
* Passing functions or objects as parameters instead of importing back and forth
* Keeping models “data-only,” with no dependency on UI or controller logic.

---

## 🧪 4. Lab: Split a Single-File App into MVC Folders

### Step 1 — Start with a toy one-file app

```python
# toy_app.py
import streamlit as st
import pandas as pd

st.title("Toy Sales Dashboard")

data = pd.DataFrame({
    "Product": ["Pen", "Pencil", "Eraser"],
    "Sales": [120, 80, 50]
})

if st.button("Show Data"):
    st.write(data)
    st.bar_chart(data.set_index("Product"))
```

Everything is mixed in one file — UI, logic, and data.

---

### Step 2 — Create folders

```
toy_mvc/
│
├── app.py
├── views/
│   └── toy_view.py
├── controllers/
│   └── toy_controller.py
└── models/
    └── toy_model.py
```

---

### Step 3 — Split the code

#### **models/toy_model.py**

```python
import pandas as pd

def get_sales_data():
    return pd.DataFrame({
        "Product": ["Pen", "Pencil", "Eraser"],
        "Sales": [120, 80, 50]
    })
```

#### **controllers/toy_controller.py**

```python
from models.toy_model import get_sales_data

def prepare_chart_data():
    data = get_sales_data()
    return data.set_index("Product")
```

#### **views/toy_view.py**

```python
import streamlit as st
from controllers.toy_controller import prepare_chart_data

def render():
    st.title("Toy Sales Dashboard")

    if st.button("Show Data"):
        chart_data = prepare_chart_data()
        st.write(chart_data)
        st.bar_chart(chart_data)
```

#### **app.py**

```python
from views import toy_view

if __name__ == "__main__":
    toy_view.render()
```

---

### Step 4 — Run the app

```bash
streamlit run app.py
```

---

## 🧩 5. Key Takeaways

✅ Separate *data*, *logic*, and *presentation*
✅ Define clear import boundaries
✅ Avoid circular dependencies
✅ Modularize early — scaling becomes effortless later

---



Would you like me to include a **diagram (MVC flow chart)** in this chapter before finalizing it?

