# **Chapter 1: Project Structure & Layering**

### ğŸ¯ **Goal**

To understand how to organize an application so that the **User Interface (UI)**, **Controller (logic)**, and **Model (data)** remain clearly separated.
This modular design ensures:

* **Scalability** â€“ adding new pages or features is easy.
* **Maintainability** â€“ logic is reusable, and UI is less cluttered.
* **Testability** â€“ each layer can be verified independently.

---

## ğŸ§± 1. Understanding MVC in the Context of Dash / Streamlit

Traditional MVC (Model-View-Controller) translates naturally to modern Python web frameworks:

| MVC Component                    | Role                                                                                  | In Dash / Streamlit Context                                                                              |
| -------------------------------- | ------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| **Model**                        | Defines and manages data (schemas, database logic, business entities).                | Classes, schemas, or helper functions that fetch or process data.                                        |
| **View (UI)**                    | Handles how information is presented to the user.                                     | Streamlit pages, Dash layouts, charts, forms, or tables.                                                 |
| **Controller (Service / Logic)** | Orchestrates data flow between model and view; performs validation, triggers actions. | Functions or classes that fetch data from the model and pass it to UI, often in a `controllers/` folder. |

**Example Flow**
â†’ UI event (button click) â†’ **Controller** calls â†’ **Model** â†’ returns processed data â†’ displayed by **View**.

---

## ğŸ“‚ 2. Folder Layout

Below is a clean baseline structure for a small Streamlit / Dash MVC-style project:

```
my_app/
â”‚
â”œâ”€â”€ app.py                   # Entry point; loads pages or routes
â”‚
â”œâ”€â”€ views/                   # User Interface layer
â”‚   â”œâ”€â”€ home_view.py
â”‚   â”œâ”€â”€ report_view.py
â”‚   â””â”€â”€ __init__.py
â”‚
â”œâ”€â”€ controllers/             # Control & business logic layer
â”‚   â”œâ”€â”€ report_controller.py
â”‚   â”œâ”€â”€ auth_controller.py
â”‚   â””â”€â”€ __init__.py
â”‚
â”œâ”€â”€ models/                  # Data layer
â”‚   â”œâ”€â”€ user_model.py
â”‚   â”œâ”€â”€ sales_model.py
â”‚   â””â”€â”€ __init__.py
â”‚
â”œâ”€â”€ services/                # Optional: reusable utilities (DB connectors, API clients)
â”‚   â””â”€â”€ db_service.py
â”‚
â”œâ”€â”€ helpers/                 # Common helper functions (validators, formatters)
â”‚   â””â”€â”€ utils.py
â”‚
â””â”€â”€ requirements.txt
```

**Import rules**

* Views â†’ Controllers âœ…
* Controllers â†’ Models âœ…
* Models â†’ Services âœ…
* Never import upward (e.g., Model â†’ Controller âŒ) â€” it creates **circular dependencies**.

---

## ğŸ”„ 3. Avoiding Cyclic Imports

Cyclic imports happen when:

```python
# report_controller.py
from models import sales_model

# sales_model.py
from controllers import report_controller  # âŒ circular dependency
```

**Fix it by:**

* Moving shared logic into `helpers/utils.py`
* Passing functions or objects as parameters instead of importing back and forth
* Keeping models â€œdata-only,â€ with no dependency on UI or controller logic.

---

## ğŸ§ª 4. Lab: Split a Single-File App into MVC Folders

### Step 1 â€” Start with a toy one-file app

```python
# toy_app.py
import streamlit as st
import pandas as pd

st.title("Toy Sales Dashboard")

data = pd.DataFrame({
    "Product": ["Pen", "Pencil", "Eraser"],
    "Sales": [120, 80, 50]
})

if st.button("Show Data"):
    st.write(data)
    st.bar_chart(data.set_index("Product"))
```

Everything is mixed in one file â€” UI, logic, and data.

---

### Step 2 â€” Create folders

```
toy_mvc/
â”‚
â”œâ”€â”€ app.py
â”œâ”€â”€ views/
â”‚   â””â”€â”€ toy_view.py
â”œâ”€â”€ controllers/
â”‚   â””â”€â”€ toy_controller.py
â””â”€â”€ models/
    â””â”€â”€ toy_model.py
```

---

### Step 3 â€” Split the code

#### **models/toy_model.py**

```python
import pandas as pd

def get_sales_data():
    return pd.DataFrame({
        "Product": ["Pen", "Pencil", "Eraser"],
        "Sales": [120, 80, 50]
    })
```

#### **controllers/toy_controller.py**

```python
from models.toy_model import get_sales_data

def prepare_chart_data():
    data = get_sales_data()
    return data.set_index("Product")
```

#### **views/toy_view.py**

```python
import streamlit as st
from controllers.toy_controller import prepare_chart_data

def render():
    st.title("Toy Sales Dashboard")

    if st.button("Show Data"):
        chart_data = prepare_chart_data()
        st.write(chart_data)
        st.bar_chart(chart_data)
```

#### **app.py**

```python
from views import toy_view

if __name__ == "__main__":
    toy_view.render()
```

---

### Step 4 â€” Run the app

```bash
streamlit run app.py
```

---

## ğŸ§© 5. Key Takeaways

âœ… Separate *data*, *logic*, and *presentation*
âœ… Define clear import boundaries
âœ… Avoid circular dependencies
âœ… Modularize early â€” scaling becomes effortless later

---



Would you like me to include a **diagram (MVC flow chart)** in this chapter before finalizing it?

