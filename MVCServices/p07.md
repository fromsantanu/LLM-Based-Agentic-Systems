## **Chapter 7: Error Handling & Logging**

### ðŸŽ¯ **Goal**

Predictable failures and useful logs â€” so that you can debug and monitor your app reliably.

---

### ðŸ“˜ **Concepts to Learn**

#### 1. **Custom Exceptions**

* Define domain-level errors that represent predictable failures (validation, business rules, etc.).
* Avoid raw `Exception`; use custom subclasses for clarity and control.

**Example:**

```python
# app/errors.py
class DomainError(Exception):
    """Base class for domain-specific errors."""
    pass


class ValidationError(DomainError):
    """Raised when input validation fails."""
    def __init__(self, field: str, message: str):
        self.field = field
        self.message = message
        super().__init__(f"Validation failed for {field}: {message}")


class NotFoundError(DomainError):
    """Raised when a resource is not found."""
    def __init__(self, resource: str, identifier):
        self.resource = resource
        self.identifier = identifier
        super().__init__(f"{resource} with id {identifier} not found")
```

---

#### 2. **Structured Logging**

* Use the standard `logging` module.
* Configure formatters and levels for consistent log output.
* Log contextual info in controllers.

**Example:**

```python
# app/config/logging_config.py
import logging

LOG_FORMAT = "%(asctime)s [%(levelname)s] %(name)s: %(message)s"

def setup_logging(level=logging.INFO):
    logging.basicConfig(level=level, format=LOG_FORMAT)
```

Usage:

```python
# app/main.py
from app.config.logging_config import setup_logging

setup_logging()
```

Now, in your code:

```python
import logging

logger = logging.getLogger(__name__)

def process_order(order):
    logger.info("Processing order", extra={"order_id": order.id})
    ...
```

---

#### 3. **Error Boundaries**

* Catch domain errors in controllers and return consistent HTTP responses.
* Donâ€™t expose internal tracebacks or implementation details to clients.

**Example:**

```python
# app/controllers/order_controller.py
from fastapi import APIRouter, HTTPException
from app.services.order_service import create_order
from app.errors import ValidationError, NotFoundError
import logging

router = APIRouter()
logger = logging.getLogger(__name__)

@router.post("/orders/")
def create_order_endpoint(order_data: dict):
    try:
        result = create_order(order_data)
        logger.info("Order created successfully", extra={"order": result})
        return result
    except ValidationError as e:
        logger.warning(f"Validation failed: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except NotFoundError as e:
        logger.warning(f"Resource not found: {e}")
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Internal Server Error")
```

---

### ðŸ§ª **Lab Exercise**

**Goal:**
Make your service raise `ValidationError` and ensure controllers log the error and return a clear message.

#### Step 1: Update Service

```python
# app/services/customer_service.py
from app.errors import ValidationError

def create_customer(data):
    if not data.get("email"):
        raise ValidationError("email", "Email is required")
    if "@" not in data["email"]:
        raise ValidationError("email", "Invalid email format")
    # pretend to insert into DB
    return {"id": 101, "name": data["name"], "email": data["email"]}
```

#### Step 2: Update Controller

```python
# app/controllers/customer_controller.py
from fastapi import APIRouter, HTTPException
from app.services.customer_service import create_customer
from app.errors import ValidationError
import logging

router = APIRouter()
logger = logging.getLogger(__name__)

@router.post("/customers/")
def add_customer(customer: dict):
    try:
        result = create_customer(customer)
        logger.info("Customer created", extra={"email": customer.get("email")})
        return result
    except ValidationError as e:
        logger.warning(f"Validation failed: {e}")
        raise HTTPException(status_code=400, detail=str(e))
```

#### Step 3: Run and Test

```bash
uvicorn app.main:app --reload
```

Send:

```bash
http POST :8000/customers/ name="Alice"
```

You should get:

```json
{
  "detail": "Validation failed for email: Email is required"
}
```

And in logs:

```
2025-10-08 16:45:12 [WARNING] app.controllers.customer_controller: Validation failed: Validation failed for email: Email is required
```

---

### ðŸ§© **Summary**

| Concept                  | Purpose                                              |
| ------------------------ | ---------------------------------------------------- |
| **Custom Exceptions**    | Predictable, domain-specific errors                  |
| **Structured Logging**   | Consistent, machine-readable logs                    |
| **Error Boundaries**     | Prevents leaks of internal details                   |
| **ValidationError Demo** | Example of how services raise and controllers handle |

---
 me to generate Chapter 8 next (Background Tasks & Caching)?

