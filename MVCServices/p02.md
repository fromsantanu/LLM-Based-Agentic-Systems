# Chapter 2 — DTOs with Pydantic

**Goal:** lock down stable request/response shapes between layers.

**You’ll learn:** `BaseModel`, `Field()`, validators, `model_dump()` (Pydantic v2).

---

## 2.1 What is a DTO (and why we care)

* **DTO (Data Transfer Object)** = a small, validated shape for moving data **between** layers (UI ⇄ controllers ⇄ services ⇄ db).
* Keep DTOs **framework-agnostic** and **side-effect free**; treat them as contracts.

---

## 2.2 Pydantic v2 crash course

```python
from pydantic import BaseModel, Field, field_validator
from typing import Annotated, Optional, List
from datetime import datetime

class Example(BaseModel):
    id: int
    name: Annotated[str, Field(min_length=1, max_length=80)]
    created_at: datetime = Field(default_factory=datetime.utcnow)

    @field_validator("name")
    @classmethod
    def strip_name(cls, v: str) -> str:
        return v.strip()

e = Example(id=1, name="  Alice  ")
print(e.model_dump())  # {'id': 1, 'name': 'Alice', 'created_at': '...'}
```

**Quick notes**

* `Field()` sets constraints, defaults, examples, descriptions.
* `@field_validator("field")` runs post-parsing checks/transforms.
* `model_dump()` → dict; `model_dump_json()` → JSON string.
* To accept non-dict sources (ORM objects), enable attribute access (see §2.6).

---

## 2.3 Define core DTOs

### 2.3.1 Customer DTOs

```python
from pydantic import BaseModel, Field, EmailStr
from typing import Optional
from datetime import datetime

class CustomerCreate(BaseModel):
    name: str = Field(min_length=1, max_length=100, examples=["Anita Sharma"])
    email: EmailStr = Field(examples=["anita@example.com"])
    phone: Optional[str] = Field(default=None, examples=["+91-98765-43210"])

    @staticmethod
    def example() -> "CustomerCreate":
        return CustomerCreate(name="Anita Sharma", email="anita@example.com")

class CustomerRead(BaseModel):
    id: int
    name: str
    email: EmailStr
    phone: Optional[str] = None
    is_active: bool
    created_at: datetime

    class Config:
        # purely documentary in v2; use field descriptions instead
        # keep Read separate from Create to avoid leaking internal fields
        pass
```

### 2.3.2 Order DTOs

```python
from typing import Literal, List

OrderStatus = Literal["draft", "placed", "shipped", "cancelled"]

class OrderLine(BaseModel):
    product_id: int = Field(gt=0)
    qty: int = Field(gt=0)
    unit_price: float = Field(ge=0)

    @field_validator("unit_price")
    @classmethod
    def round_money(cls, v: float) -> float:
        return round(v, 2)

class OrderCreate(BaseModel):
    customer_id: int = Field(gt=0)
    lines: List[OrderLine]
    currency: Literal["INR", "USD", "EUR"] = "INR"

    @field_validator("lines")
    @classmethod
    def non_empty_lines(cls, v: List[OrderLine]) -> List[OrderLine]:
        if not v:
            raise ValueError("order must have at least one line")
        return v
```

---

## 2.4 Request vs Response shapes

* **Request** (from client): `CustomerCreate`, `OrderCreate`
* **Response** (to client): `CustomerRead`, `OrderRead` (not shown; would include server-only fields like `id`, `status`, timestamps).

Keep them separate so you can evolve server fields without breaking clients.

---

## 2.5 Dumping, copying, and redaction

```python
cust = CustomerCreate.example()
payload = cust.model_dump()                 # dict to send to service/controller
payload_exclude_email = cust.model_dump(exclude={"email"})
payload_only_name = cust.model_dump(include={"name"})
payload_for_sql = cust.model_dump(mode="python")
json_body = cust.model_dump_json()
```

---

## 2.6 From ORM (SQLAlchemy) → DTO

Enable attribute access using `model_validate` with `from_attributes=True`.

```python
from pydantic import BaseModel, ConfigDict

class CustomerRead(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: int
    name: str
    email: EmailStr
    phone: Optional[str] = None
    is_active: bool
    created_at: datetime

# later, given SQLAlchemy object `db_customer`
dto = CustomerRead.model_validate(db_customer)  # uses attribute access
```

---

## 2.7 From pandas row → DTO

You’ll often hydrate DTOs from analytics/ETL outputs.

```python
import pandas as pd

row = pd.Series({
    "id": 101,
    "name": "  Riya  ",
    "email": "riya@example.com",
    "phone": None,
    "is_active": True,
    "created_at": "2025-10-01T12:30:00Z",
})

# 1) Normalize: to dict + parse dates where needed
row_dict = row.to_dict()

# 2) Let Pydantic coerce types (datetime parsing, trimming via validator)
cust_read = CustomerRead.model_validate(row_dict)

print(cust_read.model_dump())
```

**Tips**

* If column names differ, map them first: `row.rename({"customer_email":"email"}, inplace=True)`.
* For a whole DataFrame: `[CustomerRead.model_validate(rec) for rec in df.to_dict(orient="records")]`.

---

## 2.8 Common validator patterns

```python
from typing import ClassVar

class CustomerCreate(BaseModel):
    name: str
    email: EmailStr
    phone: Optional[str] = None

    RESERVED_NAMES: ClassVar[set[str]] = {"admin", "root"}

    @field_validator("name")
    @classmethod
    def no_reserved_names(cls, v: str) -> str:
        if v.lower().strip() in cls.RESERVED_NAMES:
            raise ValueError("name is reserved")
        return v.strip()
```

---

## 2.9 Testing DTOs (fast)

```python
def test_customer_create_trim():
    dto = CustomerCreate(name="  Meera  ", email="meera@example.com")
    assert dto.name == "Meera"

def test_order_must_have_lines():
    import pytest
    with pytest.raises(ValueError):
        OrderCreate(customer_id=1, lines=[])
```

---

## 2.10 Folder placement (MVC-friendly)

```
app/
  models/             # ORM entities (SQLAlchemy)
  dto/                # <-- Pydantic DTOs live here (no DB imports!)
    customer.py
    order.py
  controllers/        # HTTP handlers / routers — only import dto/*
  services/           # business logic — returns/accepts DTOs
  repositories/       # db read/write — map ORM <-> DTO
```

Keep `dto/` **import-clean** (no framework/DB imports).

---

## 2.11 Lab

**Lab Goal:** Define `CustomerCreate`, `CustomerRead`, `OrderCreate`; convert a pandas row → DTO.

1. Create `app/dto/customer.py` and `app/dto/order.py` with the DTOs shown above.
2. Add at least **two** validators:

   * trim/validate `name`
   * non-empty order `lines`
3. Write a short script `lab_pandas_to_dto.py`:

```python
# lab_pandas_to_dto.py
import pandas as pd
from app.dto.customer import CustomerRead
from datetime import datetime, timezone

df = pd.DataFrame([
    {"id": 1, "name": "  Anita  ", "email": "anita@example.com", "phone": None,
     "is_active": True, "created_at": datetime.now(timezone.utc).isoformat()},
])

records = [CustomerRead.model_validate(rec).model_dump() for rec in df.to_dict(orient="records")]
print(records)
```

**Stretch:** Build `OrderRead` that includes: `id`, `status`, `total_amount`, `created_at`, and compute `total_amount` from `lines` in a `@model_validator(mode="after")`.

---

## 2.12 Cheatsheet

* Define: `class X(BaseModel): ...`
* Constrain: `Field(min_length=1, gt=0, examples=[...])`
* Validate: `@field_validator("f")`
* Parse non-dict: `X.model_validate(obj, from_attributes=True)`
* Dump: `model_dump(include=..., exclude=..., mode="json"|"python")`
* Keep DTOs framework-free; separate **Create** vs **Read** shapes.

---
