# Chapter 4 — Services (Business Rules)

**Goal:** Keep logic pure & testable; no UI imports.
**Learn:** input validation, orchestration across repositories, returned DTOs/DataFrames.
**Lab:** `calculate_invoice_totals(lines, tax_rate)` (pure function) + unit tests.

---

## 4.1 What “Services” mean in our stack

* **Purpose:** Hold *business rules* and multi-step *orchestration* that sits between controllers and repositories.
* **Constraints:**

  * No imports from UI frameworks (Streamlit/Dash/FastAPI routers).
  * Avoid DB session code here—delegate to repositories.
  * Prefer **pure functions** for core rules; they’re easiest to test.
* **Inputs/Outputs:**

  * Accept **DTOs** or primitive types.
  * Return **DTOs** (or plain dicts) — optionally DataFrames for analytics.

**Typical layout**

```
app/
  services/
    __init__.py
    invoices.py        # pure rules, orchestration around invoice
    customers.py
  repositories/
    invoices.py
    customers.py
  dto/
    invoice.py         # Pydantic models used across layers
```

---

## 4.2 Patterns you’ll use

1. **Validate inputs at the boundary**
   Use Pydantic DTOs or small validators in services to normalize/guard values.

2. **Keep currency precise**
   Use `Decimal` (never float) and a single rounding policy (e.g., bankers or half-up).

3. **Return stable shapes**

   * For APIs/UI: DTOs (Pydantic models).
   * For analysis: a Pandas `DataFrame` created *at the edge* (view/controller) from DTOs.

     > Keep the *rule* pure; transforming to a DataFrame is a thin adapter.

4. **Composition over conditionals**
   Break rules into small helpers, compose them.

---

## 4.3 The Business Rule: Invoice Totals

**Requirements**

* Input: a list of *invoice lines* with:

  * `sku: str`
  * `qty: int >= 0`
  * `unit_price: Decimal >= 0`
  * (optional) `discount_rate: Decimal` in **[0, 1]** per line
* `tax_rate: Decimal` in **[0, 1]**
* Compute for each line:

  * `line_subtotal = qty * unit_price`
  * `line_discount = line_subtotal * discount_rate` (default 0)
  * `line_net = line_subtotal - line_discount`
  * `line_tax = line_net * tax_rate`
  * `line_total = line_net + line_tax`
* Invoice totals are sum of line fields.
* Rounding: **2 decimal places, HALF_UP** at the *money* boundaries:

  * Round each monetary component (`subtotal`, `discount`, `net`, `tax`, `total`) to 2dp.

---

## 4.4 DTOs for Lines and Totals

```python
# app/dto/invoice.py
from decimal import Decimal
from pydantic import BaseModel, Field, field_validator, ConfigDict

Money = Decimal

class InvoiceLineDTO(BaseModel):
    sku: str = Field(min_length=1)
    qty: int = Field(ge=0)
    unit_price: Money = Field(ge=0)
    discount_rate: Decimal = Field(default=Decimal("0"), ge=0, le=1)

    model_config = ConfigDict(arbitrary_types_allowed=True, frozen=True)

    @field_validator("unit_price", mode="before")
    @classmethod
    def _as_decimal(cls, v):
        return Decimal(str(v))

    @field_validator("discount_rate", mode="before")
    @classmethod
    def _as_decimal2(cls, v):
        return Decimal(str(v))

class InvoiceLineResultDTO(BaseModel):
    sku: str
    qty: int
    unit_price: Money
    subtotal: Money
    discount: Money
    net: Money
    tax: Money
    total: Money

class InvoiceTotalsDTO(BaseModel):
    lines: list[InvoiceLineResultDTO]
    subtotal: Money
    discount: Money
    net: Money
    tax: Money
    total: Money
```

---

## 4.5 Service Implementation (Pure)

```python
# app/services/invoices.py
from decimal import Decimal, ROUND_HALF_UP, getcontext
from typing import Iterable
from app.dto.invoice import (
    InvoiceLineDTO, InvoiceLineResultDTO, InvoiceTotalsDTO
)

# Keep high precision internally; round only at money boundaries.
getcontext().prec = 28

def _money(x: Decimal) -> Decimal:
    """Round to 2 dp with HALF_UP."""
    return x.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)

def calculate_invoice_totals(lines: Iterable[InvoiceLineDTO], tax_rate: Decimal) -> InvoiceTotalsDTO:
    """
    Pure business rule: given lines + tax_rate -> per-line + invoice totals.
    No I/O, no DB, no UI.
    """
    tax_rate = Decimal(str(tax_rate))
    if tax_rate < 0 or tax_rate > 1:
        raise ValueError("tax_rate must be between 0 and 1 inclusive")

    line_results: list[InvoiceLineResultDTO] = []
    sum_subtotal = Decimal("0")
    sum_discount = Decimal("0")
    sum_net = Decimal("0")
    sum_tax = Decimal("0")
    sum_total = Decimal("0")

    for ln in lines:
        if ln.qty < 0:
            raise ValueError("qty must be >= 0")
        if ln.unit_price < 0:
            raise ValueError("unit_price must be >= 0")
        if ln.discount_rate < 0 or ln.discount_rate > 1:
            raise ValueError("discount_rate must be in [0,1]")

        raw_subtotal = Decimal(ln.qty) * ln.unit_price
        subtotal = _money(raw_subtotal)

        raw_discount = raw_subtotal * ln.discount_rate
        discount = _money(raw_discount)

        raw_net = raw_subtotal - raw_discount
        net = _money(raw_net)

        raw_tax = raw_net * tax_rate
        tax = _money(raw_tax)

        total = _money(net + tax)

        line_results.append(InvoiceLineResultDTO(
            sku=ln.sku, qty=ln.qty, unit_price=_money(ln.unit_price),
            subtotal=subtotal, discount=discount, net=net, tax=tax, total=total
        ))

        sum_subtotal += subtotal
        sum_discount += discount
        sum_net += net
        sum_tax += tax
        sum_total += total

    return InvoiceTotalsDTO(
        lines=line_results,
        subtotal=_money(sum_subtotal),
        discount=_money(sum_discount),
        net=_money(sum_net),
        tax=_money(sum_tax),
        total=_money(sum_total),
    )
```

---

## 4.6 Optional: DataFrame Adapter (keep the rule pure)

If you want a `DataFrame` for the UI/controller layer, write a thin adapter:

```python
# app/services/invoice_adapters.py
import pandas as pd
from app.dto.invoice import InvoiceTotalsDTO

def totals_to_dataframe(totals: InvoiceTotalsDTO) -> pd.DataFrame:
    rows = [l.model_dump() for l in totals.lines]
    df = pd.DataFrame(rows, columns=[
        "sku","qty","unit_price","subtotal","discount","net","tax","total"
    ])
    return df
```

> Note: The **core** rule stays DTO-based; this adapter is optional sugar for display.

---

## 4.7 Unit Tests (pytest)

```
tests/
  test_services_invoices.py
```

```python
# tests/test_services_invoices.py
from decimal import Decimal
import pytest
from app.dto.invoice import InvoiceLineDTO
from app.services.invoices import calculate_invoice_totals

def D(x: str) -> Decimal:
    return Decimal(x)

def test_basic_two_lines_no_discount():
    lines = [
        InvoiceLineDTO(sku="A", qty=2, unit_price=D("10.00")),
        InvoiceLineDTO(sku="B", qty=1, unit_price=D("5.50")),
    ]
    totals = calculate_invoice_totals(lines, tax_rate=D("0.10"))

    # Per-line checks
    a = totals.lines[0]
    assert a.subtotal == D("20.00")
    assert a.discount == D("0.00")
    assert a.net == D("20.00")
    assert a.tax == D("2.00")
    assert a.total == D("22.00")

    b = totals.lines[1]
    assert b.subtotal == D("5.50")
    assert b.tax == D("0.55")
    assert b.total == D("6.05")

    # Invoice totals
    assert totals.subtotal == D("25.50")
    assert totals.discount == D("0.00")
    assert totals.net == D("25.50")
    assert totals.tax == D("2.55")
    assert totals.total == D("28.05")

def test_line_with_discount_and_rounding():
    # 3 * 9.99 = 29.97; 10% discount => 2.997 -> 3.00; net=26.97
    # tax 18% -> 4.8546 -> 4.85 (HALF_UP); total=31.82
    lines = [InvoiceLineDTO(sku="C", qty=3, unit_price=D("9.99"), discount_rate=D("0.10"))]
    totals = calculate_invoice_totals(lines, tax_rate=D("0.18"))

    l = totals.lines[0]
    assert l.subtotal == D("29.97")
    assert l.discount == D("3.00")
    assert l.net == D("26.97")
    assert l.tax == D("4.85")
    assert l.total == D("31.82")

    assert totals.total == D("31.82")

@pytest.mark.parametrize("bad_rate", ["-0.01", "1.01"])
def test_invalid_tax_rate_raises(bad_rate):
    with pytest.raises(ValueError):
        calculate_invoice_totals([], tax_rate=Decimal(bad_rate))

def test_invalid_line_fields_raise():
    from app.dto.invoice import InvoiceLineDTO
    with pytest.raises(ValueError):
        calculate_invoice_totals([InvoiceLineDTO(sku="X", qty=-1, unit_price=D("1.00"))], D("0.05"))
    with pytest.raises(ValueError):
        calculate_invoice_totals([InvoiceLineDTO(sku="X", qty=1, unit_price=D("-1.00"))], D("0.05"))
    with pytest.raises(ValueError):
        calculate_invoice_totals([InvoiceLineDTO(sku="X", qty=1, unit_price=D("1.00"), discount_rate=D("1.2"))], D("0.05"))
```

**Run**

```bash
pytest -q
```

---

## 4.8 Orchestrating across repositories (example)

A *service* may compose repository calls but keep rules pure:

```python
# app/services/invoice_checkout.py
from decimal import Decimal
from app.repositories.invoices import InvoiceRepo
from app.dto.invoice import InvoiceLineDTO
from app.services.invoices import calculate_invoice_totals

class InvoiceCheckoutService:
    def __init__(self, repo: InvoiceRepo) -> None:
        self.repo = repo

    def price_and_persist(self, draft_invoice_id: str, tax_rate: Decimal):
        # 1) Load draft lines (DTOs) from repo
        lines: list[InvoiceLineDTO] = self.repo.fetch_draft_lines(draft_invoice_id)

        # 2) Pure pricing rule
        totals = calculate_invoice_totals(lines, tax_rate)

        # 3) Persist results (no business math here)
        self.repo.save_priced_invoice(draft_invoice_id, totals)
        return totals
```

> Notice: repository handles I/O; the *math* stayed in `calculate_invoice_totals`.

---

## 4.9 Checklist (keep services clean)

* [ ] No UI imports (Streamlit/Dash/FastAPI routers)
* [ ] No DB session logic — call repositories
* [ ] Core rules are pure functions with unit tests
* [ ] Use `Decimal` + consistent rounding
* [ ] Validate boundaries (rates in [0,1], non-negative money/qty)
* [ ] Return DTOs; adapt to DataFrames at the edge if needed

---

## 4.10 Lab — Your Turn

1. **Implement** `calculate_invoice_totals` exactly as above (copy into `app/services/invoices.py`).
2. **Write tests** in `tests/test_services_invoices.py` (add at least the four tests shown).
3. **Run** `pytest` and fix any failures.
4. **Stretch goals**

   * Add per-line **fixed** discount (`discount_amount`) and decide precedence vs `discount_rate`.
   * Support **tax-inclusive** unit prices with back-calculation.
   * Add a **rounding policy** param (`HALF_UP` vs `ROUND_HALF_EVEN`) and test both.
   * Add a small adapter that returns a **summary DTO** + **DataFrame** for UI.

That’s your service layer foundation: pure, predictable, and easy to evolve.

