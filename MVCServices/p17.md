# Chapter 17 — Auth & Permissions (lightweight)

> Goal: add **just-enough** authentication and role-based UI gating to Dash & Streamlit so you can hide admin-only sections during demos.
> ⚠️ This is **not** production security. It’s fine for prototypes, classes, and internal demos.

---

## What you’ll learn

* A tiny **user store** and password check (hashed, in-memory or env).
* **Session** storage of `user` and `role`.
* **Gating patterns**:

  * Dash: protect **routes, layouts, and callbacks** using a guard.
  * Streamlit: **login gate** using `st.session_state` and hide components unless role matches.
* Where to swap in real auth later (JWT/OAuth/SSO).

---

## Minimal user model (shared idea)

```python
# models/users.py
from dataclasses import dataclass
from hashlib import sha256

@dataclass
class User:
    username: str
    role: str  # "admin" | "user"
    password_hash: str

# in-memory store for demos
USERS = {
    "alice": User("alice", "admin", sha256(b"alice123").hexdigest()),
    "bob":   User("bob",   "user",  sha256(b"bob123").hexdigest()),
}

def verify_password(username: str, password: str) -> tuple[bool, User | None]:
    u = USERS.get(username)
    if not u:
        return False, None
    return sha256(password.encode()).hexdigest() == u.password_hash, u
```

---

## Dash — route/component protection

### Project bits we’ll add

```
your_dash_app/
├─ app.py                    # dash.Dash app + server secret_key
├─ guards.py                 # guard helpers
├─ pages/
│  ├─ home.py                # public
│  ├─ admin.py               # admin-only
│  └─ login.py               # login screen (sets session)
├─ models/users.py           # (from above)
└─ controllers/session.py    # read/write flask session
```

### Configure sessions

```python
# app.py
from dash import Dash
from flask import Flask
import os

server = Flask(__name__)
server.secret_key = os.environ.get("SECRET_KEY", "dev-only-secret")
app = Dash(__name__, use_pages=True, server=server, suppress_callback_exceptions=True)
app.title = "RBAC Demo"
```

### Session helpers

```python
# controllers/session.py
from flask import session

SESSION_KEY = "auth"

def set_user(user_dict: dict):
    session[SESSION_KEY] = user_dict

def get_user() -> dict | None:
    return session.get(SESSION_KEY)

def clear_user():
    session.pop(SESSION_KEY, None)
```

### Guards for layouts & callbacks

```python
# guards.py
from dash import html, dcc
from flask import request
from controllers.session import get_user

def require_login_layout(content_component):
    """Wrap a layout: if not logged in, show redirect."""
    user = get_user()
    if not user:
        # soft-redirect to /login and remember next
        next_url = request.path or "/"
        return dcc.Location(id="redir", href=f"/login?next={next_url}")
    return content_component

def require_role(*roles):
    """Call from callbacks or layout builders."""
    user = get_user()
    if not user or user.get("role") not in roles:
        # Return a simple '403' fragment for layouts
        return html.Div("403 — Not authorized.", style={"color": "crimson"})
    return None  # means allowed
```

### Login page

```python
# pages/login.py
from dash import html, dcc, callback, Input, Output, State
from urllib.parse import urlencode, urlparse, parse_qs
from models.users import verify_password
from controllers.session import set_user

layout = html.Div([
    html.H2("Login"),
    dcc.Location(id="url"),
    dcc.Input(id="username", placeholder="username"),
    dcc.Input(id="password", type="password", placeholder="password"),
    html.Button("Sign in", id="submit"),
    html.Div(id="msg")
])

@callback(
    Output("msg", "children"),
    Output("url", "href"),
    Input("submit", "n_clicks"),
    State("username", "value"),
    State("password", "value"),
    State("url", "href"),
    prevent_initial_call=True
)
def do_login(n, username, password, href):
    ok, user = verify_password(username or "", password or "")
    if not ok:
        return "Invalid credentials.", dash.no_update
    set_user({"username": user.username, "role": user.role})
    # redirect to ?next=... or home
    next_param = parse_qs(urlparse(href or "").query).get("next", ["/"])[0]
    return "Logged in!", next_param
```

### Public page

```python
# pages/home.py
from dash import html

layout = html.Div([
    html.H3("Home"),
    html.P("Everyone can see this.")
])
```

### Admin-only page (layout gate)

```python
# pages/admin.py
from dash import html
from guards import require_login_layout, require_role

def _admin_content():
    forbidden = require_role("admin")
    if forbidden:
        return forbidden
    return html.Div([
        html.H3("Admin dashboard"),
        html.P("Sensitive stuff here.")
    ])

layout = require_login_layout(_admin_content())
```

### Callback protection (inside a callback)

```python
# some_callbacks.py
from dash import callback, Input, Output
from guards import require_role

@callback(Output("admin-table", "data"), Input("refresh", "n_clicks"))
def refresh_admin(n):
    forbidden = require_role("admin")
    if forbidden:
        # Return empty/placeholder data if unauthorized
        return []
    # else fetch and return real data
    return [{"id": 1, "name": "Secret"}]
```

> Pattern: **check early, return harmless output** if unauthorized.

---

## Streamlit — login gate + role in session_state

### Simple login form + role store

```python
# streamlit_app.py
import streamlit as st
from models.users import verify_password

st.set_page_config(page_title="RBAC Demo", layout="wide")

def login_gate():
    if "auth" not in st.session_state:
        st.session_state.auth = None

    if st.session_state.auth:
        return True

    st.title("Login")
    u = st.text_input("Username")
    p = st.text_input("Password", type="password")
    if st.button("Sign in", type="primary"):
        ok, user = verify_password(u, p)
        if ok:
            st.session_state.auth = {"username": user.username, "role": user.role}
            st.success(f"Welcome, {user.username}!")
            st.rerun()
        else:
            st.error("Invalid credentials")
    st.stop()  # halt until logged in

def require_role(*roles):
    auth = st.session_state.get("auth")
    if not auth or auth["role"] not in roles:
        st.warning("403 — Not authorized for this section.")
        return False
    return True

# ---- App ----
if login_gate():
    auth = st.session_state.auth
    st.sidebar.write(f"Logged in as **{auth['username']}** ({auth['role']})")
    if st.sidebar.button("Logout"):
        st.session_state.auth = None
        st.rerun()

    st.header("Home (everyone)")
    st.write("Public content.")

    st.divider()
    st.subheader("Admin section")
    if require_role("admin"):
        st.write("Sensitive admin data below 👇")
        st.dataframe({"id": [1, 2], "secret": ["alpha", "beta"]})
```

> Pattern: **early gate** + small `require_role()` helper to **hide components** cleanly.

---

## Lab — Hide admin sections unless `role == "admin"`

### ✅ Your tasks

1. **Dash**

   * Create `pages/admin.py` and protect it:

     * If not logged in → redirect to `/login?next=/admin`.
     * If logged in but `role != admin` → show “403 — Not authorized.”
     * Else render a fake “Admin KPIs” grid.
   * Add a callback that **returns empty table** for non-admins.

2. **Streamlit**

   * Add a sidebar **role switcher** (for testing only) that sets `st.session_state.auth["role"]` to `"user"`/`"admin"`.
   * Hide a chart and a download button unless role is admin.

3. **Bonus**

   * Add a **“view as”** banner in both apps to remind when you’re in a limited role.
   * Persist auth across restarts using:

     * Dash: Flask session with a signed cookie (already).
     * Streamlit: `st.experimental_connection` or a tiny local file with **hashed** cookie (demo only).

### ⭐ Reference snippets

**Dash – admin KPIs**

```python
# pages/admin.py (inside allowed branch)
from dash import html

def kpi_card(title, value):
    return html.Div([
        html.H4(title), html.H2(value)
    ], style={"border":"1px solid #eee","padding":"12px","borderRadius":"10px"})

def _admin_content():
    forbidden = require_role("admin")
    if forbidden:
        return forbidden
    return html.Div([
        html.Div([
            kpi_card("Total Users", "128"),
            kpi_card("Active Today", "57"),
            kpi_card("Errors", "0"),
        ], style={"display":"grid","gridTemplateColumns":"repeat(3, 1fr)","gap":"12px"})
    ])
```

**Streamlit – hide controls**

```python
st.subheader("Admin tools")
if require_role("admin"):
    st.download_button("Download full dump", data="id,name\n1,Alice", file_name="dump.csv")
    st.line_chart({"visits":[10,20,17,30,25]})
```

---

## Testing ideas

* Try logging in as `bob` (role `user`) and confirm:

  * Dash `/admin` redirects to `/login` if not logged in.
  * After `bob` logs in, `/admin` shows **403** and admin callbacks return harmless defaults.
  * Streamlit hides the admin chart & download.
* Switch to `alice` (role `admin`) and confirm gated content appears.

---

## Upgrade path (production-ready options)

When you move beyond demos:

* **Token-based**: JWT (PyJWT) with short TTL, refresh tokens, role claims.
* **OAuth2 / OIDC**: Auth0, Azure AD, Google, Keycloak → validate ID token on each request; keep role/permissions in claims.
* **Dash**: consider `dash-enterprise-auth`, Flask-Login/Flask-Security (server-side), or reverse proxy (NGINX) with SSO headers.
* **Streamlit**: Streamlit Community Cloud auth (limited) or front a **reverse proxy** that enforces auth and passes headers; read role from header/env.

> Always: hash passwords (Argon2/bcrypt), use HTTPS, set secure cookies, add CSRF where applicable, log auth events, and **never** store plaintext secrets in code.

---

## Checklist

* [ ] In-memory user store in `models/users.py`
* [ ] Dash session helpers + guards
* [ ] Dash admin page gated + safe callbacks
* [ ] Streamlit login gate + `require_role()`
* [ ] Admin UI hidden unless `role == "admin"`
* [ ] Manual tests with `alice` (admin) and `bob` (user)

---

## Quick copy box — tiny guard APIs

```python
# Dash
from guards import require_login_layout, require_role
layout = require_login_layout(your_layout())
forbidden = require_role("admin")
if forbidden: return forbidden

# Streamlit
if "auth" not in st.session_state: login_gate()
if require_role("admin"):
    render_admin()
```

That’s it—your app now **feels** like it has auth, without dragging in a whole identity stack. Perfect for labs and demos.

