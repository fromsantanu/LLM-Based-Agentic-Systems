# Chapter 3 — Repositories (I/O only)

**Goal:** Put *all* DB/API/file access in one place so your controllers/services stay thin and your views stay clean.

**You’ll learn:**

* Creating an SQLAlchemy **engine** and **session factory** you can reuse
* A small, consistent **CRUD + query** shape (no business logic here)
* Returning **rows/DTOs** (from Chapter 2) instead of raw ORM objects

---

## 3.1 Why a Repository layer?

* **Single I/O boundary:** DB, external APIs, and filesystem calls live here—easy to mock and test.
* **Slim controllers/services:** They orchestrate; repositories fetch or persist.
* **Swapability:** Change SQLite → Postgres without touching controllers/views.
* **Repeatable patterns:** Every new entity gets predictable `list_*/get_*/create_*/update_*/delete_*` functions.

---

## 3.2 Session & engine setup

Use one engine per process and a short-lived session per operation/request.

```python
# app/repositories.py
from __future__ import annotations
from contextlib import contextmanager
from typing import Iterator, Optional, Sequence, Tuple

from sqlalchemy import create_engine, select, func
from sqlalchemy.orm import sessionmaker, Session

# Import ORM models and DTOs from earlier chapters
from app.models import Customer, Order  # SQLAlchemy ORM models
from app.dtos import CustomerRead, OrderCreate, OrderRead  # Pydantic DTOs

# ── Engine & Session factory ────────────────────────────────────────────────
ENGINE_URL = "sqlite:///./app.db"  # swap via config in real apps
engine = create_engine(ENGINE_URL, echo=False, future=True)
SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False, future=True)

@contextmanager
def get_session() -> Iterator[Session]:
    """
    Scoped session per use. Controllers/services call repo functions which
    open/close sessions internally unless a session is explicitly passed.
    """
    session: Session = SessionLocal()
    try:
        yield session
        session.commit()
    except:  # noqa: E722
        session.rollback()
        raise
    finally:
        session.close()
```

> If your web framework provides request-scoped sessions (e.g., FastAPI dependency), let repo functions accept an optional `Session` so you can reuse it inside a request transaction.

---

## 3.3 Mapping ORM rows → DTOs

Keep mapping tiny and local to the repo so the rest of the app never depends on SQLAlchemy.

```python
# app/repositories.py (continued)

def _customer_to_read(c: Customer) -> CustomerRead:
    return CustomerRead(
        id=c.id,
        name=c.name,
        email=c.email,
        is_active=c.is_active,
        created_at=c.created_at,
    )

def _order_to_read(o: Order) -> OrderRead:
    return OrderRead(
        id=o.id,
        customer_id=o.customer_id,
        sku=o.sku,
        quantity=o.quantity,
        unit_price=o.unit_price,
        status=o.status,
        created_at=o.created_at,
    )
```

---

## 3.4 Queries that return rows/DTOs

### 3.4.1 `list_customers()` with simple filters + paging

* **I/O only:** Build a query, run it, map to DTOs.
* **No business rules:** e.g., “who can see whom” belongs in services.

```python
# app/repositories.py (continued)
from dataclasses import dataclass

@dataclass(frozen=True)
class Page:
    items: Sequence[CustomerRead]
    total: int
    page: int
    size: int
    pages: int

def list_customers(
    *,
    search: Optional[str] = None,
    is_active: Optional[bool] = None,
    page: int = 1,
    size: int = 20,
    session: Optional[Session] = None,
) -> Page:
    """Return paged customers as DTOs. No business logic here."""
    owns_session = session is None
    if owns_session:
        cm = get_session()
        session = cm.__enter__()

    try:
        stmt = select(Customer)
        if search:
            like = f"%{search}%"
            stmt = stmt.where((Customer.name.ilike(like)) | (Customer.email.ilike(like)))
        if is_active is not None:
            stmt = stmt.where(Customer.is_active == is_active)

        # total count (separate query keeps it simple and portable)
        total = session.execute(
            select(func.count()).select_from(stmt.subquery())
        ).scalar_one()

        # pagination
        page = max(page, 1)
        size = max(min(size, 200), 1)  # cap page size
        stmt = stmt.order_by(Customer.created_at.desc()).offset((page - 1) * size).limit(size)

        rows = session.execute(stmt).scalars().all()
        items = [_customer_to_read(r) for r in rows]

        pages = (total + size - 1) // size
        return Page(items=items, total=total, page=page, size=size, pages=pages)
    finally:
        if owns_session:
            cm.__exit__(None, None, None)
```

### 3.4.2 `create_order()` that returns the created record

* Validate minimal referential integrity (customer exists).
* Commit inside the repo (I/O boundary), return an **OrderRead** DTO.

```python
# app/repositories.py (continued)
from sqlalchemy.exc import NoResultFound

class NotFoundError(RuntimeError): ...
class IntegrityError(RuntimeError): ...

def create_order(
    payload: OrderCreate,
    *,
    session: Optional[Session] = None,
) -> OrderRead:
    """
    Insert an order and return it as DTO.
    Only I/O and minimal integrity checks live here.
    """
    owns_session = session is None
    if owns_session:
        cm = get_session()
        session = cm.__enter__()

    try:
        # ensure customer exists
        customer = session.get(Customer, payload.customer_id)
        if not customer:
            raise NotFoundError(f"Customer {payload.customer_id} not found")

        order = Order(
            customer_id=payload.customer_id,
            sku=payload.sku,
            quantity=payload.quantity,
            unit_price=payload.unit_price,
            status=payload.status or "NEW",
        )
        session.add(order)
        session.flush()   # assign PKs
        session.refresh(order)

        return _order_to_read(order)
    finally:
        if owns_session:
            cm.__exit__(None, None, None)
```

---

## 3.5 Using the repository from a controller/service

Keep this thin—compose use cases, handle authorization/validation **outside** the repo if it’s not I/O-related.

```python
# app/services/orders.py
from sqlalchemy.orm import Session
from app.repositories import create_order
from app.dtos import OrderCreate, OrderRead

def place_order(dto: OrderCreate, *, session: Session) -> OrderRead:
    # Example: business rules could live here (e.g., credit checks)
    return create_order(dto, session=session)
```

**FastAPI-style DI (optional):**

```python
# app/api/routes_orders.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.repositories import create_order, get_session
from app.dtos import OrderCreate, OrderRead

router = APIRouter(prefix="/orders")

def session_dep() -> Session:
    with get_session() as s:
        yield s

@router.post("/", response_model=OrderRead)
def api_create_order(dto: OrderCreate, session: Session = Depends(session_dep)):
    try:
        return create_order(dto, session=session)
    except RuntimeError as e:
        raise HTTPException(status_code=400, detail=str(e))
```

---

## 3.6 Testing the repository (no web stack needed)

```python
# tests/test_repositories.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.models import Base, Customer
from app.repositories import list_customers, create_order
from app.dtos import OrderCreate

def make_memory_session():
    engine = create_engine("sqlite+pysqlite:///:memory:", future=True)
    TestingSession = sessionmaker(bind=engine, future=True)
    Base.metadata.create_all(engine)
    return TestingSession()

def test_list_customers_empty():
    s = make_memory_session()
    page = list_customers(session=s)
    assert page.total == 0 and page.items == []

def test_create_order_happy_path():
    s = make_memory_session()
    # seed
    cust = Customer(name="Alice", email="alice@x.com", is_active=True)
    s.add(cust); s.commit(); s.refresh(cust)

    dto = OrderCreate(customer_id=cust.id, sku="SKU-1", quantity=2, unit_price=199.0, status=None)
    created = create_order(dto, session=s)
    assert created.customer_id == cust.id
    assert created.sku == "SKU-1"
```

---

## 3.7 Patterns & guidelines

* **Only I/O here:** SQL, HTTP calls, file reads/writes, and simple integrity checks.
* **Return DTOs, not ORM:** Keeps your outer layers decoupled from SQLAlchemy.
* **Paging everywhere:** predictable UX and performance.
* **Session ownership:** Let repo open/close its own session *or* accept an injected one.
* **Narrow APIs:** Prefer many small composable functions over mega-queries.

---

## 3.8 Lab — Build `repositories.py`

**Your tasks:**

1. **Create `app/repositories.py`** as above.
2. Implement:

   * `list_customers(search=None, is_active=None, page=1, size=20, session=None) -> Page`
   * `create_order(OrderCreate, session=None) -> OrderRead`
3. **Wire it up** in your controller/service and run a quick end-to-end path:

   * Create a customer (you can seed directly or via your API)
   * Call `create_order()`
   * Verify `list_customers()` filters/paging work
4. **Write tests** using an in-memory SQLite engine (example provided).

**Stretch goals:**

* Add `get_customer_by_email(email)` with a **unique** constraint at the DB level.
* Support **sorting** (`sort_by`, `sort_dir`) in `list_customers`.
* Implement `update_order_status(order_id, new_status)` using optimistic checks.
* Add a `UnitOfWork` wrapper if you prefer transaction scripts over ad-hoc sessions.

---

### Quick reference: DTOs assumed from Chapter 2

```python
# app/dtos.py (recap)
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional

class CustomerRead(BaseModel):
    id: int
    name: str
    email: str
    is_active: bool
    created_at: datetime

class OrderCreate(BaseModel):
    customer_id: int
    sku: str
    quantity: int = Field(..., ge=1)
    unit_price: float = Field(..., ge=0.0)
    status: Optional[str] = None

class OrderRead(BaseModel):
    id: int
    customer_id: int
    sku: str
    quantity: int
    unit_price: float
    status: str
    created_at: datetime
```
---
