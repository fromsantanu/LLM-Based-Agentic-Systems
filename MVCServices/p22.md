
# **Chapter 22: Prompting LLMs to generate MVC Project Structure**

Here’s a set of copy-paste prompt templates you can reuse so any LLM you use will generate Dash/Streamlit apps in a consistent MVC + service-controller style. Use them as-is, tweak the project name, and go.

## 0) Global “System” / Preamble (paste once per session)

```
You are a senior Python architect. Generate production-ready code organized in an MVC style:

- Model = services & repositories (pure functions / classes). No UI calls.
- View = UI layout & rendering helpers (Dash components or Streamlit sections).
- Controller = event/callback handlers (Dash callbacks or Streamlit actions using session_state) that orchestrate Models and update Views.
- “Service-Controller mechanism” = controllers call service layer (models/services/*.py). No business logic in controllers/views.

Conventions
- Use typed functions, docstrings, small modules, and dependency-injection-friendly constructor args.
- No global DB clients; provide a get_<resource>() factory in models/repositories.py.
- Keep all I/O (DB, APIs, files) inside models/repositories.py; business rules in models/services.py; schemas in models/schemas.py.
- For Dash: each page = {views/<page>.py + controllers/<page>_callbacks.py}. For Streamlit: each page file imports views/* and controllers/* only.
- Never mix UI code inside services or repositories.
- Provide a README.md with how to run and where each layer lives.
- Add TODO comments where environment vars or real credentials belong, with dummy values.

Deliverables must include: file tree, each file content, and run commands. If something is out of scope, stub it cleanly.
```

---

## 1) Project Bootstrap (Dash)

```
Create a new Dash project named "SalesSuite" using MVC + service-controller:

Targets
- Multipage Dash app with pages: dashboard, orders, customers.
- Data store: SQLite (via SQLAlchemy).
- Structure exactly like:

app/
  main.py                 # app factory, page registry
  routes.py               # register pages (+path->layout map)
  assets/                 # (empty, add placeholder CSS)
  views/
    dashboard.py
    orders.py
    customers.py
    components.py
  controllers/
    dashboard_callbacks.py
    orders_callbacks.py
    customers_callbacks.py
  models/
    schemas.py
    repositories.py
    services.py
    seed.py
  config/
    settings.py
  tests/
    test_services.py
README.md
requirements.txt

Details
- repositories.py: SQLAlchemy engine/session factory; CRUD for customers/orders; pure DB access.
- services.py: business funcs (e.g., get_sales_summary(year), create_order(order_in), validate_order()).
- schemas.py: Pydantic models for DTOs (Create/Update/Read).
- views/*.py: pure layout builders (functions returning Dash components). No callbacks.
- controllers/*_callbacks.py: only callbacks; import services.*; never import repositories directly.
- main.py: app factory, register pages via routes.py; mount callbacks by importing controllers modules.
- Include 1–2 realistic callbacks per page.
- Add seed.py with demo data; README shows how to run `python -m app.models.seed` then `python -m app.main`.
- Add basic tests for services layer.

Output
1) The full file tree
2) The content of every file
3) Commands to run, including DB init and environment variables
```

---

## 2) Project Bootstrap (Streamlit, multipage)

```
Create a Streamlit multipage app "ClinicBoard" in MVC + service-controller style.

Targets
- Pages: 1_Dashboard.py, 2_Appointments.py, 3_Patients.py
- Models: SQLite via SQLAlchemy
- Use session_state to hold user selections and cached data keys.
- Use @st.cache_data for read-only service queries, @st.cache_resource for engine/session_factory.

Structure
app/
  Home.py
  pages/
    1_Dashboard.py
    2_Appointments.py
    3_Patients.py
  views/
    sections.py          # reusable UI sections (tables, filters, cards)
    widgets.py
  controllers/
    actions.py           # event handlers that mutate session_state and call services
    state.py             # init/reset helpers (keys, defaults)
  models/
    schemas.py           # Pydantic DTOs
    repositories.py      # DB access (SQLAlchemy)
    services.py          # business logic
    seed.py
  config/
    settings.py
  utils/
    caching.py
  tests/
    test_services.py
README.md
requirements.txt

Rules
- Page files only compose views and call controllers.actions.*; no business logic.
- controllers.actions.* functions call services.* (never repositories directly).
- views.* contain only st.* UI composition; accept dataframes/DTOs as params.
- Provide one example flow per page (filter -> action -> view).
- Include seed.py with demo data and README run steps.

Output: file tree, all file contents, run commands.
```

---

## 3) “Add a New Page” Template (Dash)

```
Add a new Dash page "inventory" to an existing MVC project.

Scope
- New files:
  views/inventory.py          # layout builder with filters and table
  controllers/inventory_callbacks.py
- Update routes.py to register path "/inventory".
- Services:
  - Add services.get_inventory_summary(category: str|None, min_stock: int|None) -> pd.DataFrame
- Repositories:
  - Add repositories.list_inventory(filters...) and seed sample rows.

Acceptance
- The controller reads inputs (dropdown category, slider min stock), calls services, updates a DataTable.
- No business logic in controller; services validate and shape data.
- Provide brief tests for services.get_inventory_summary.

Output: modified tree and the exact diffs or full file contents.
```

---

## 4) “Add a New Service/Use-Case” Template (Streamlit)

```
Add a new use-case "export_appointments_csv" to ClinicBoard.

Changes
- models/services.py: add export_appointments_csv(date_from, date_to) -> Path (temp file)
- controllers/actions.py: add action to run export and set session_state["export_path"]
- views/sections.py: add a download button section that appears when session_state["export_path"] exists.
- tests/test_services.py: add a test for file creation and basic CSV headers.

Constraints
- repositories provide raw rows; services handle CSV writing (no st.*).
- Page file 2_Appointments.py wires a button to controllers.actions.export_appointments_csv() and renders views.sections.download_export() if available.

Deliverables: updated files only and a short snippet showing how the page calls the action.
```

---

## 5) “Refactor to MVC” Template (for messy single-file code)

```
Refactor the following single-file Dash/Streamlit app into MVC + service-controller.

Inputs
- (Paste current code here)

Targets
- Extract all DB/API calls into models/repositories.py
- Move business rules into models/services.py with typed functions.
- Convert UI-rendering blocks into views/sections.py (Streamlit) or views/<page>.py (Dash).
- Create controllers/actions.py (Streamlit) or controllers/<page>_callbacks.py (Dash) that only orchestrate.
- Add models/schemas.py with Pydantic DTOs for request/response shapes.
- Keep identical runtime behavior and UI.
- Provide a diff summary and final full files.

Constraints
- No circular imports.
- No service referencing st.* or dash.*.
- Add smoke tests in tests/test_services.py.
```

---

## 6) “Definition of Done” (paste to every task)

```
Definition of Done (DoD):
[ ] File tree matches the requested structure
[ ] Controllers import services only (never repositories)
[ ] Views contain only UI code; pure functions accepting data
[ ] Services are pure & typed; repositories isolated I/O
[ ] No business logic in pages/callbacks
[ ] One happy-path test for each new service function
[ ] README updated with run steps and env variables
```

---

## 7) Micro-Prompts you can sprinkle inside any request

* **Enforce layering:**
  “If any business rule appears in a controller/view, move it into services with a clear function name and unit test.”
* **DTO hygiene:**
  “Represent request/response bodies with Pydantic models in models/schemas.py; controllers validate using these DTOs.”
* **DI friendly:**
  “Repository constructors accept a session or engine argument; services accept repositories via parameters to ease testing.”
* **Caching (Streamlit):**
  “Use @st.cache_data on read-only service functions; invalidate cache when session_state[‘last_write_at’] changes.”

---


