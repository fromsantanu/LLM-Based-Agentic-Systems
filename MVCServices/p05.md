## **Chapter 5 — Dependency Injection & Testing**

### **🎯 Goal**

Be able to **test service logic without connecting to a real database**.

You’ll learn how to:

* Pass **repository interfaces** into services rather than creating them inside.
* Use **fake / mock repositories** to isolate business logic.
* Write **pytest fixtures** that supply these fakes for clean, repeatable tests.

---

### **5.1 Why Dependency Injection (DI)?**

If a service function *creates* its own repository object, you can’t swap that repository easily.
By **injecting** the repository, you decouple the logic from infrastructure and can plug in:

* a real SQLAlchemy repo in production,
* a fake or in-memory repo in unit tests.

```python
# ❌ tightly coupled
def get_sales_summary(year: int):
    repo = SalesRepository()             # fixed dependency
    sales = repo.fetch_by_year(year)
    return sum(s.amount for s in sales)

# ✅ injected dependency
def get_sales_summary(year: int, repo):
    sales = repo.fetch_by_year(year)
    return sum(s.amount for s in sales)
```

---

### **5.2 Designing a Repository Interface**

We’ll express the *contract* that any repository must fulfill.

```python
# repositories/interfaces.py
from typing import Protocol, List
from dtos import SaleRead

class SalesRepo(Protocol):
    def fetch_by_year(self, year: int) -> List[SaleRead]: ...
```

---

### **5.3 Implementing a Real Repository**

```python
# repositories/sales_repo.py
from sqlalchemy.orm import Session
from .interfaces import SalesRepo
from models import Sale
from dtos import SaleRead

class SqlSalesRepo(SalesRepo):
    def __init__(self, session: Session):
        self.session = session

    def fetch_by_year(self, year: int):
        rows = (
            self.session.query(Sale)
            .filter(Sale.date.between(f"{year}-01-01", f"{year}-12-31"))
            .all()
        )
        return [SaleRead.model_validate(r.__dict__) for r in rows]
```

---

### **5.4 Writing a Fake Repository**

```python
# tests/fakes.py
from dtos import SaleRead

class FakeSalesRepo:
    def __init__(self, data):
        self.data = data

    def fetch_by_year(self, year):
        return [s for s in self.data if s.date.year == year]
```

---

### **5.5 Pure Service Function**

```python
# services/sales_service.py
def get_sales_summary(year: int, repo):
    """Return total and count of sales for a given year."""
    sales = repo.fetch_by_year(year)
    total = sum(s.amount for s in sales)
    count = len(sales)
    return {"year": year, "total": total, "count": count}
```

---

### **5.6 Testing with Pytest Fixtures**

```python
# tests/test_sales_service.py
import datetime as dt
import pytest
from dtos import SaleRead
from services.sales_service import get_sales_summary
from tests.fakes import FakeSalesRepo

@pytest.fixture
def fake_repo():
    sample = [
        SaleRead(id=1, date=dt.date(2023, 5, 1), amount=100.0),
        SaleRead(id=2, date=dt.date(2023, 7, 3), amount=150.0),
        SaleRead(id=3, date=dt.date(2024, 1, 5), amount=200.0),
    ]
    return FakeSalesRepo(sample)

def test_get_sales_summary(fake_repo):
    result = get_sales_summary(2023, repo=fake_repo)
    assert result["year"] == 2023
    assert result["total"] == 250.0
    assert result["count"] == 2
```

Run:

```bash
pytest -v
```

---

### **5.7 Takeaways**

| Concept                    | Benefit                                   |
| -------------------------- | ----------------------------------------- |
| **Dependency Injection**   | Makes logic testable and flexible.        |
| **Protocols / Interfaces** | Define expectations, not implementations. |
| **Fakes / Mocks**          | Allow offline, fast unit tests.           |
| **Fixtures**               | Keep test setup clean and reusable.       |

---

### **🧪 Lab Recap**

✅ Create `SalesRepo` interface
✅ Implement `FakeSalesRepo`
✅ Write `get_sales_summary(year, repo)`
✅ Verify behavior using **pytest fixture**

---



