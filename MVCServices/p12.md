# Chapter 12 — View Layer in **Streamlit**

**Goal:** Build clean, reusable UI “sections” with `st.columns`, `st.dataframe`, and small view functions you can plug into pages or controllers.

---

## What you’ll learn

* How to compose responsive layouts with `st.columns`
* How (and when) to use `st.dataframe` vs `st.table`
* How to write **modular section functions** (pure “view” helpers) that:

  * accept inputs (props)
  * render UI
  * return user intent (filters / events) to the controller

---

## 12.1 Streamlit View Layer: quick mental model

* **Repository/Service**: fetches & shapes data (no Streamlit imports).
* **Controller**: orchestrates the request → calls services → passes props to views → handles returned events.
* **View (this chapter)**: Streamlit-only code. Small, testable functions that render UI sections.
  *Rule of thumb*: Views don’t fetch data and don’t mutate business state; they just render and report user choices.

---

## 12.2 `st.columns`—building responsive layouts

### Basics

```python
import streamlit as st

col1, col2 = st.columns(2)            # equal width
wide, narrow = st.columns([3, 1])     # 3:1 ratio
```

* **Gutters** are handled automatically; no manual CSS needed.
* Use **ratios** when one area (e.g., a table) deserves more space.
* Prefer 1–3 columns; more can feel cramped on laptops.

### Pattern: Inputs on the left, actions on the right

```python
left, right = st.columns([3,1])
with left:
    year = st.selectbox("Year", [2022, 2023, 2024, 2025], index=3)
    q = st.text_input("Search", placeholder="Name, email, …")
with right:
    st.write("")  # spacer
    apply = st.button("Apply Filters", use_container_width=True)
```

---

## 12.3 `st.dataframe`—interactive, scalable tables

`st.dataframe` is scrollable, resizable, supports sorting and optional column config.

```python
import pandas as pd
import streamlit as st

df = pd.DataFrame(
    {"customer": ["Alice", "Bob"], "orders": [5, 2], "revenue": [1200.0, 320.0]}
)

st.dataframe(
    df,
    use_container_width=True,
    hide_index=True,
    column_config={
        "customer": "Customer",
        "orders": st.column_config.NumberColumn("Orders", help="Total orders"),
        "revenue": st.column_config.NumberColumn("Revenue (USD)", format="$%d"),
    },
)
```

**When to use `st.table`?** Small, static snapshots. For everything else, prefer `st.dataframe`.

**Tip:** If you pre-sort/filter the dataframe in the controller, the view stays trivial.

---

## 12.4 Modular “section functions”

Design your views as tiny components:

* **Inputs → UI**: accept props (`title`, `df`, `options`, defaults).
* **Outputs → Events**: return a dict with user choices (e.g., `{"year": 2025, "q": "alice", "clicked": True}`).
* **No side effects** beyond Streamlit rendering.

### Example: a pure view section

```python
import streamlit as st
from typing import Dict, Any, Optional, Sequence
import pandas as pd

def render_filters(
    years: Sequence[int],
    default_year: Optional[int] = None,
    show_search: bool = True,
) -> Dict[str, Any]:
    left, right = st.columns([3, 1])

    with left:
        selected_year = st.selectbox(
            "Year",
            years,
            index=years.index(default_year) if default_year in years else 0
        )
        search = st.text_input("Search", placeholder="Type to filter…") if show_search else ""

    with right:
        st.write("")  # spacer
        clicked = st.button("Apply Filters", use_container_width=True)

    return {"year": selected_year, "q": search, "apply": clicked}


def render_table(df: pd.DataFrame, title: str = "Results") -> None:
    st.subheader(title)
    if df.empty:
        st.info("No results to display.")
        return

    st.dataframe(
        df,
        use_container_width=True,
        hide_index=True,
        column_config={c: c for c in df.columns},  # adjust in real apps
    )
```

**Why return events?** The controller can decide whether to re-query or reuse cache based on `apply`.

---

## 12.5 Controller ↔ View handshake (mini demo)

```python
# app.py (page/controller)
import streamlit as st
import pandas as pd
from views.sections import render_filters, render_table

st.title("Customers")

# --- Controller default state (could also use st.session_state)
YEARS = [2023, 2024, 2025]
events = render_filters(YEARS, default_year=2025)

# --- Orchestration: only fetch/transform when user applies
if events["apply"]:
    year = events["year"]
    q = (events["q"] or "").lower()

    # pretend service call
    raw = pd.DataFrame({
        "name": ["Alice", "Bob", "Carlos", "Dina"],
        "year": [2025, 2025, 2024, 2025],
        "orders": [5, 2, 3, 8],
        "revenue": [1200, 320, 500, 2400],
    })

    df = raw[raw["year"] == year]
    if q:
        df = df[df["name"].str.lower().str.contains(q)]

    render_table(df[["name", "orders", "revenue"]], title=f"Results for {year}")
else:
    st.caption("Set filters and click **Apply Filters**.")
```

**Notes**

* The **controller** owns data fetching and filtering.
* The **view** just renders and returns user intent.

---

## 12.6 Practical tips & pitfalls

* **Alignment:** Lightly use `st.write("")` as a spacer to align buttons inside columns.
* **Performance:** Cache service calls (`@st.cache_data`) in the controller; keep view functions stateless.
* **Column config:** Give human-friendly headers and formats (`NumberColumn`, `DateColumn`).
* **Empty states:** Always handle empty dataframes gracefully with `st.info()`.
* **Accessibility:** Clear labels, concise help text, avoid overcrowding columns.
* **Reusability:** Keep `views/` free of repository/service imports.

---

## Lab — Build `views/sections.py`

**Objective:** Create a small view module with two reusable sections.

### 1) File layout

```
app/
  controllers/
  services/
  views/
    __init__.py
    sections.py   <-- (create this)
  app.py
```

### 2) Implement `views/sections.py`

```python
# views/sections.py
from typing import Dict, Any, Optional, Sequence
import streamlit as st
import pandas as pd

def render_filters(
    years: Sequence[int],
    default_year: Optional[int] = None,
    placeholders: Optional[Dict[str, str]] = None,
) -> Dict[str, Any]:
    """
    Renders a filter bar with (Year, Search, Apply).
    Returns a dict: {"year": int, "q": str, "apply": bool}
    """
    placeholders = placeholders or {}
    left, mid, right = st.columns([2, 3, 1])

    with left:
        idx = years.index(default_year) if (default_year in years) else 0
        year = st.selectbox("Year", years, index=idx)

    with mid:
        q = st.text_input("Search", placeholder=placeholders.get("search", "Name, email, …"))

    with right:
        st.write("")  # spacer
        apply_clicked = st.button("Apply Filters", use_container_width=True)

    return {"year": year, "q": q, "apply": apply_clicked}


def render_table(
    df: pd.DataFrame,
    title: str = "Results",
    column_config: Optional[Dict[str, Any]] = None,
    hide_index: bool = True,
) -> None:
    """
    Renders a dataframe with sensible defaults.
    """
    st.subheader(title)
    if df is None or df.empty:
        st.info("No results to display.")
        return

    st.dataframe(
        df,
        use_container_width=True,
        hide_index=hide_index,
        column_config=column_config or {c: c for c in df.columns},
    )
```

### 3) Wire it up in a page/controller

```python
# app.py (example usage)
import streamlit as st
import pandas as pd
from views.sections import render_filters, render_table

st.set_page_config(page_title="Streamlit View Sections", layout="wide")
st.title("Sales Dashboard")

events = render_filters([2023, 2024, 2025], default_year=2025)

if events["apply"]:
    # simulate service result
    data = pd.DataFrame({
        "region": ["East", "West", "North", "South"],
        "year":   [2025,   2025,   2024,    2025],
        "orders": [120,    85,     60,      140],
        "revenue":[180000, 105000, 70000,   220000],
    })

    df = data[data["year"] == events["year"]]
    if events["q"]:
        q = events["q"].lower()
        df = df[df["region"].str.lower().str.contains(q)]

    render_table(
        df[["region", "orders", "revenue"]],
        title=f"Sales for {events['year']}",
        column_config={
            "region": "Region",
            "orders": st.column_config.NumberColumn("Orders"),
            "revenue": st.column_config.NumberColumn("Revenue", format="$%d"),
        },
    )
else:
    st.caption("Choose filters and click **Apply Filters** to load data.")
```

### 4) Stretch goals

* Add a **download** button (`st.download_button`) next to the table title.
* Add a **“Reset Filters”** button in `render_filters` that clears the search box.
* Add **column-level toggles** (checkboxes) to show/hide optional columns.
* Provide **row selection** (use a separate component like `st-aggrid` if needed).

---



