# Chapter 9 — Controller Layer: Callbacks

**Goal:** Wire the UI (Views) to your business logic (Services) cleanly and predictably using Dash callbacks.
**Focus:** `@callback(Input, Output, State)`, `PreventUpdate`, `no_update`, and pattern-matching IDs (`MATCH`, `ALL`, `ALLSMALLER`).

---

## 9.1 Why “Controllers” in Dash?

In MVC terms, **controllers** translate user actions into service calls and push results back into the view.
In Dash, the controller layer is implemented with **callbacks**: pure(ish) Python functions that connect inputs → logic → outputs.

* **View**: `views/` — builds `html.*` and `dcc.*` components.
* **Controller**: `controllers/` — registers `@callback(...)` functions.
* **Service**: `services/` — performs business logic (I/O-free “pure” functions preferred; I/O via repositories when needed).

---

## 9.2 Callback Anatomy

```python
from dash import callback, Input, Output, State, no_update
from dash.exceptions import PreventUpdate

@callback(
    Output("out-id", "children"),               # what to update
    Input("btn-id", "n_clicks"),                # what triggers it
    State("text-id", "value"),                  # read-only at trigger time
    prevent_initial_call=True                   # skip page-load firing
)
def on_click(n, text):
    if not n:                        # None or 0 → do nothing
        raise PreventUpdate
    if not text:
        return "Please type something."
    return f"You typed: {text}"
```

**Key points**

* `Input`: changes in these props **trigger** the function.
* `State`: values are **read**, but **don’t trigger**.
* `Output`: components/props you **mutate**.
* `PreventUpdate`: *don’t* touch the outputs (no visual change).
* `no_update`: selectively skip updating particular outputs.

---

## 9.3 Preventing Noise

### When to use `PreventUpdate`

* Before any user intent (e.g., `n_clicks` is `None`).
* Validation fails (missing/invalid inputs).
* Service returns “nothing to do”.

### When to use `no_update`

* You have **multiple Outputs** but want to update only some.

```python
@callback(
    Output("msg", "children"),
    Output("panel", "hidden"),
    Input("toggle", "n_clicks"),
    prevent_initial_call=True
)
def toggle_panel(n):
    if n % 2 == 0:
        # update msg only; leave panel as-is
        return "Even click", no_update
    return "Odd click", False
```

---

## 9.4 Pattern-Matching IDs

Pattern-matching lets one callback handle **dynamic or repeated** components.

```python
from dash import MATCH, ALL, ALLSMALLER

# MATCH → one-to-one mapping inside a repeated group
@callback(
    Output({"role": "row-total", "row": MATCH}, "children"),
    Input({"role": "qty", "row": MATCH}, "value"),
    Input({"role": "price", "row": MATCH}, "value"),
)
def compute_row_total(qty, price):
    if qty is None or price is None:
        raise PreventUpdate
    return round(qty * price, 2)

# ALL → fan-in across many items
@callback(
    Output("grand-total", "children"),
    Input({"role": "row-total", "row": ALL}, "children"),
)
def sum_all(row_totals):
    nums = [float(x) for x in row_totals if x not in (None, "")]
    return f"₹ {sum(nums):,.2f}"

# ALLSMALLER → items with an index smaller than the triggering one (ordering logic)
```

**ID Pattern Tip:** Use a **dict** as the component `id`:

```python
id={"role": "qty", "row": i}
```

This keeps selectors explicit and easy to test.

---

## 9.5 Reading “who triggered me?”

Sometimes you need to know **which** input fired. Use `dash.ctx`:

```python
from dash import ctx

@callback(Output("last-trigger", "children"), Input("a", "n_clicks"), Input("b", "n_clicks"))
def last_clicked(a, b):
    if not ctx.triggered_id:
        raise PreventUpdate
    return f"Triggered by: {ctx.triggered_id}"
```

---

## 9.6 Controller Best Practices

1. **Thin controllers:** Do validation + orchestration, then call services. Avoid data munging here.
2. **Pure services:** Return DTOs / DataFrames; keep I/O in repositories.
3. **Explicit validation:** Fail fast with clear messages; `PreventUpdate` for “no change”.
4. **Deterministic outputs:** Always return values for all declared `Output`s (or `no_update`).
5. **Test services, not callbacks:** Unit-test service functions; spot-check callbacks with Dash’s testing tools if needed.
6. **Use `prevent_initial_call=True`** when rendering should start empty.
7. **Cache thoughtfully** (e.g., per user inputs) if the service is expensive.

---

## 9.7 Mini Patterns You’ll Reuse

### “Load on Click”

* Typical for “Run” buttons that fetch/compute on demand.

```python
@callback(
    Output("result", "children"),
    Input("run", "n_clicks"),
    State("year", "value"),
    prevent_initial_call=True
)
def run_report(n, year):
    if not year:
        return "Pick a year."
    data = services.sales.summary_by_year(year)
    return f"Records: {len(data)}"
```

### “Form + Validate + Submit”

* Validate fields; show inline errors without breaking the page.

### “Multi-output Controller”

* Fan out results to a table + message + chart in one call.

---

## 9.8 LAB — Button → Service Call → Update `DataTable`

**What you’ll build**

A page with:

* Year dropdown + **Load** button
* When clicked, controller calls `services.sales.get_sales(year)`
* The result populates a `dash_table.DataTable`
* The controller also updates a status message (rows loaded, time taken)

### Folder snapshot

```
app/
  main.py
  views/
    dashboard.py
  controllers/
    dashboard.py
  services/
    sales.py
  repositories/
    sales_repo.py
```

### `services/sales.py` (business logic)

```python
# app/services/sales.py
from time import perf_counter
from . import dto  # optional if you defined DTOs; else return list[dict]
from ..repositories.sales_repo import fetch_sales_for_year

def get_sales(year: int):
    """
    Orchestrates fetching + lightweight shaping.
    Returns (rows, meta) where rows is list[dict].
    """
    t0 = perf_counter()
    rows = fetch_sales_for_year(year)  # pure data (list of dicts or DataFrame.to_dict('records'))
    # optional: validate / compute derived cols here
    elapsed = perf_counter() - t0
    meta = {"year": year, "count": len(rows), "elapsed_secs": round(elapsed, 3)}
    return rows, meta
```

### `repositories/sales_repo.py` (I/O only; here we fake it)

```python
# app/repositories/sales_repo.py
import random

def fetch_sales_for_year(year: int):
    # Simulated dataset (replace with DB/API later)
    rng = random.Random(year)
    regions = ["East", "West", "North", "South"]
    products = ["Alpha", "Beta", "Gamma", "Delta"]
    rows = []
    for i in range(1, 51):
        rows.append({
            "id": i,
            "year": year,
            "region": rng.choice(regions),
            "product": rng.choice(products),
            "qty": rng.randint(1, 20),
            "price": rng.choice([99.0, 149.0, 199.0, 299.0]),
        })
    # add computed value if you like; otherwise keep pure
    return rows
```

### `views/dashboard.py` (UI only)

```python
# app/views/dashboard.py
from dash import html, dcc
from dash import dash_table

def layout():
    return html.Div(
        [
            html.H2("Sales Browser"),
            html.Div(
                [
                    dcc.Dropdown(
                        id="year-dd",
                        options=[{"label": str(y), "value": y} for y in range(2019, 2026)],
                        value=2023,
                        placeholder="Select year",
                        style={"width": "200px", "marginRight": "12px"},
                    ),
                    html.Button("Load", id="load-btn", n_clicks=0),
                    html.Span(id="load-status", style={"marginLeft": "12px"}),
                ],
                style={"display": "flex", "alignItems": "center", "gap": "8px"},
            ),
            html.Hr(),
            dash_table.DataTable(
                id="sales-table",
                columns=[
                    {"name": "ID", "id": "id"},
                    {"name": "Year", "id": "year"},
                    {"name": "Region", "id": "region"},
                    {"name": "Product", "id": "product"},
                    {"name": "Qty", "id": "qty", "type": "numeric"},
                    {"name": "Price", "id": "price", "type": "numeric", "format": {"specifier": ".2f"}},
                ],
                data=[],                         # start empty
                page_size=10,
                sort_action="native",
                filter_action="native",
                style_table={"overflowX": "auto"},
            ),
        ],
        style={"padding": "1rem"},
    )
```

### `controllers/dashboard.py` (the callback/controller)

```python
# app/controllers/dashboard.py
from dash import callback, Input, Output, State, no_update
from dash.exceptions import PreventUpdate
from ..services.sales import get_sales

@callback(
    Output("sales-table", "data"),
    Output("load-status", "children"),
    Input("load-btn", "n_clicks"),
    State("year-dd", "value"),
    prevent_initial_call=True,
)
def load_sales(n_clicks, year):
    if not n_clicks:
        raise PreventUpdate
    if year is None:
        return no_update, "Please choose a year."

    rows, meta = get_sales(int(year))
    msg = f"Loaded {meta['count']} rows for {meta['year']} in {meta['elapsed_secs']}s."
    return rows, msg
```

### `app/main.py` (compose app)

```python
# app/main.py
from dash import Dash
from .views.dashboard import layout as dashboard_layout
from .controllers import dashboard as _controller_import  # noqa: F401  (ensure callbacks register)

def create_app() -> Dash:
    app = Dash(__name__, suppress_callback_exceptions=True)
    app.layout = dashboard_layout()
    return app

app = create_app()

if __name__ == "__main__":
    app.run_server(debug=True)
```

> **Run it:** `python -m app.main` (or `python app/main.py`) and click **Load**.

---

## 9.9 Pattern-Matching Mini-Lab (Optional)

Add a “per-row Recalc” button and compute totals with `MATCH`:

**View (snippet):**

```python
from dash import html, dcc, dash_table

# Add per-row buttons by giving pattern IDs:
# id={"role": "recalc", "row": row["id"]}
# id={"role": "row-total", "row": row["id"]}
```

**Controller (snippet):**

```python
from dash import callback, Input, Output, State, MATCH
from dash.exceptions import PreventUpdate

@callback(
    Output({"role": "row-total", "row": MATCH}, "children"),
    Input({"role": "recalc", "row": MATCH}, "n_clicks"),
    State("sales-table", "data"),
    State({"role": "recalc", "row": MATCH}, "row"),  # custom prop if you store it
    prevent_initial_call=True
)
def recalc_row(n, table_data, row_id):
    if not n:
        raise PreventUpdate
    # find row by id, recompute total
    row = next((r for r in table_data if r["id"] == row_id), None)
    if not row:
        raise PreventUpdate
    total = round(row["qty"] * row["price"], 2)
    return total
```

---

## 9.10 Debugging Checklist

* **Callback not firing?** Check `prevent_initial_call`, IDs, and the Input prop names.
* **“A nonexistent object was used”**: Make sure the view created the component **before** callbacks run, or set `suppress_callback_exceptions=True`.
* **Type errors**: Cast `year` to `int`, handle `None`.
* **Multiple Outputs**: Always return a tuple/list matching the declared Outputs (use `no_update` where needed).

---

## 9.11 Exercises

1. **Validation Practice**
   Add input checks: if `year < 2020`, show “Limited historical data” and don’t query the repo.

2. **Multi-Output Update**
   Add a second output that shows total revenue (sum of `qty*price`) when data loads.

3. **Pattern-Matching**
   Add a per-row “Delete” (client-side removal) using pattern IDs and update the table data accordingly.

---

**You now have a clean controller pattern:** small, testable callbacks that validate inputs, call services, and update views. In the next chapter, we’ll connect these controllers to more advanced views (charts and filters) and talk about keeping state predictable across pages.

