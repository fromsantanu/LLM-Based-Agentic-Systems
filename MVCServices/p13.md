# Chapter 13 — Controller Layer: Actions + Session State

**Goal:** Wire your UI to business logic using **event handlers** that safely write to `st.session_state`, and understand **how/when Streamlit re-runs**.

---

## 1) The Controller’s Job (recap)

* **Views** render widgets and read state.
* **Services** do the work (pure logic, I/O orchestrations).
* **Controllers** glue them: react to user events, call services, **write** results into `st.session_state`, and trigger a rerun when needed.

> Mental model: *UI event → controller action → service call → state update → rerender.*

---

## 2) Event Handlers in Streamlit

You attach controller functions via:

* `on_click=` for `st.button`, `st.download_button`
* `on_change=` for inputs like `st.selectbox`, `st.text_input`, `st.slider`
* `on_submit=` for `st.form`

**Handler signature:** a callable with no args *or* with `args=()`/`kwargs={}` provided by you.

```python
st.button(
    "Load data",
    key="btn_load",
    on_click=controllers.actions.load_data,  # no-arg handler
)
```

With parameters:

```python
st.selectbox(
    "Year",
    options=[2022, 2023, 2024, 2025],
    key="year",
    on_change=controllers.actions.change_year,
    kwargs={"key": "year"},  # pass which session key changed
)
```

---

## 3) `st.session_state` Lifecycle (What actually happens)

* **Initial run**: all your script executes top-to-bottom. Missing keys don’t exist.
* **Widget creation**: each widget registers its value under a key (auto or your custom `key=`).
* **User interaction**: when a user clicks/changes/ submits, Streamlit **re-runs** the entire script with updated state and calls the handler(s) you attached.
* **Your job in controllers**: write canonical results (DTOs, DataFrames, messages) into **namespaced keys** so views can render them.

**Initialize defensively** (once per run):

```python
def ensure_defaults():
    ss = st.session_state
    ss.setdefault("data", None)                 # canonical payload slot
    ss.setdefault("ui.filters", {"year": 2024})
    ss.setdefault("ui.flash", None)
```

> Tip: use dotted keys like `"ui.filters"` to visually namespace related state.

---

## 4) Rerun Mechanics (when and why)

* Streamlit **auto-reruns** after handler execution. Often you **don’t need** to call `st.rerun()`.
* Use `st.rerun()` **only when**:

  * You modify multiple keys and want to short-circuit rendering until state is coherent.
  * You navigate (e.g., `st.switch_page("pages/inventory.py")`) and then return.
  * You want to “reset” transient UI (e.g., clear a form).

> `st.experimental_rerun` is deprecated; prefer `st.rerun()`.

---

## 5) Controller Design Patterns

* **Thin controllers**: validate inputs, call service, store result.

* **Never** import Streamlit in services. Controllers may import both `services.*` and `streamlit`.

* **Stable keys**: pick a few canonical keys the views rely on, e.g.:

  * `"data"`: the current DataFrame/DTO rendered by table views.
  * `"ui.filters"`: user-selected filters.
  * `"ui.busy"`: optional flag to avoid double-submits.
  * `"ui.flash"`: last message (success/error).

* **Error policy**: catch `DomainError/ValidationError` raised by services and store a safe message instead of crashing the app.

---

## 6) Lab — `controllers/actions.py`

**What you’ll build:** A controller module with actions that call a service and set `st.session_state["data"]`. You’ll also handle filters and errors.

### 6.1 Folder structure (context)

```
your_app/
  controllers/
    __init__.py
    actions.py         <-- (new)
  services/
    __init__.py
    reporting.py       <-- service you already have (e.g., get_sales_summary)
  views/
    sections.py
    dashboard.py
  app.py
```

### 6.2 `services/reporting.py` (example service)

> If you already have one (e.g., from Chapter 4/5), keep it. Otherwise use this stub.

```python
# services/reporting.py
from typing import Dict, Any
import pandas as pd

class DomainError(Exception):
    pass

def get_sales_summary(year: int) -> pd.DataFrame:
    if year < 2000 or year > 2100:
        raise DomainError(f"Unsupported year: {year}")
    # Replace with real repo calls and logic:
    data = [
        {"month": "Jan", "revenue": 120_000, "orders": 340},
        {"month": "Feb", "revenue": 95_500, "orders": 310},
    ]
    df = pd.DataFrame(data)
    df["year"] = year
    return df
```

### 6.3 `controllers/actions.py`

```python
# controllers/actions.py
from __future__ import annotations
import streamlit as st
from typing import Any, Dict
from services.reporting import get_sales_summary, DomainError

# ---- Helpers ---------------------------------------------------------------

def _ss() -> st.session_state.__class__:
    return st.session_state

def ensure_defaults() -> None:
    ss = _ss()
    ss.setdefault("data", None)
    ss.setdefault("ui.filters", {"year": 2024})
    ss.setdefault("ui.flash", None)
    ss.setdefault("ui.busy", False)

def _set_flash(msg: str) -> None:
    _ss()["ui.flash"] = msg

# ---- Actions ---------------------------------------------------------------

def load_data() -> None:
    """
    Fetch data using current filters and store into session_state['data'].
    Intended for on_click of 'Load' button or initial auto-load.
    """
    ensure_defaults()
    ss = _ss()
    if ss.get("ui.busy"):
        return
    ss["ui.busy"] = True
    try:
        year = ss["ui.filters"]["year"]
        df = get_sales_summary(year)
        ss["data"] = df
        _set_flash(f"Loaded summary for {year}.")
    except DomainError as e:
        ss["data"] = None
        _set_flash(f"⚠️ {e}")
    except Exception as e:
        ss["data"] = None
        _set_flash("❌ Something went wrong while loading data.")
        # Optional: log exception somewhere
    finally:
        ss["ui.busy"] = False
    # Usually no explicit rerun needed; uncomment if you chain multiple steps:
    # st.rerun()

def change_year(key: str = "year") -> None:
    """
    Update filter.year when a selectbox changes, and optionally auto-reload.
    Connect via on_change with kwargs={'key': 'year'}.
    """
    ensure_defaults()
    ss = _ss()
    new_year = ss.get(key)  # value stored by the widget
    ss["ui.filters"]["year"] = int(new_year)
    # Auto-fetch after filter change:
    load_data()

def clear_data() -> None:
    ensure_defaults()
    _ss()["data"] = None
    _set_flash("Cleared data.")
```

### 6.4 Minimal view wiring (`views/sections.py`)

```python
# views/sections.py
import streamlit as st
from controllers import actions

def render_filters():
    actions.ensure_defaults()
    ss = st.session_state
    years = list(range(2022, 2026))
    st.selectbox(
        "Year",
        options=years,
        index=years.index(ss["ui.filters"]["year"]),
        key="year",
        on_change=actions.change_year,
        kwargs={"key": "year"},
    )
    st.button("Load", on_click=actions.load_data)
    st.button("Clear", on_click=actions.clear_data)

def render_table():
    actions.ensure_defaults()
    ss = st.session_state
    if ss["ui.flash"]:
        st.info(ss["ui.flash"])
    if ss["data"] is None:
        st.warning("No data loaded yet.")
        return
    st.dataframe(ss["data"], use_container_width=True)
```

### 6.5 Page file (`app.py`)

```python
# app.py
import streamlit as st
from views.sections import render_filters, render_table
from controllers.actions import ensure_defaults, load_data

st.set_page_config(page_title="Sales Summary", layout="wide")

ensure_defaults()

st.title("Sales Summary")
with st.sidebar:
    render_filters()

# Optional: auto-load on first run if no data
if st.session_state["data"] is None:
    load_data()

render_table()
```

**Run:** `streamlit run app.py`

---

## 7) Common Pitfalls & Fixes

* **Pitfall:** Circular imports (view → controller → view).
  **Fix:** Views only import controllers; controllers never import views.

* **Pitfall:** Handlers relying on locals not in `session_state`.
  **Fix:** Always read inputs from `st.session_state` (e.g., filters stored under `"ui.filters"`).

* **Pitfall:** Multiple handlers fighting over state.
  **Fix:** Use a `"ui.busy"` flag or serialize long actions; avoid overlapping long tasks.

* **Pitfall:** Silent failures.
  **Fix:** Catch service exceptions and write a user-facing message to `"ui.flash"`.

* **Pitfall:** Storing huge objects.
  **Fix:** Keep `session_state` slim (DataFrames/DTOs OK; avoid massive blobs or open connections).

---

## 8) Mini-Checklist (use before you wire a new action)

* [ ] Namespaced keys exist (`ensure_defaults()`).
* [ ] Event handler persists outputs to `"data"` (or a dedicated key).
* [ ] Errors become friendly messages in `"ui.flash"`.
* [ ] Views **only read** state; no direct service calls.
* [ ] No unnecessary `st.rerun()` calls.

---

## 9) Practice Tasks

1. **Add a filter** for `region` and make `load_data()` pass it to the service.
2. **Add a refresh button** that simply calls `load_data()`; show a spinner while busy.
3. **Add an error banner** that disappears when `Load` succeeds (clear `"ui.flash"` on success).
4. **Write a new action** `export_csv()` that writes the current `"data"` to a CSV and stores the file path in `session_state["ui.download"]` for the view to render a `st.download_button`.

---

## 10) Key Takeaways

* Controllers are your **event brain**: they translate UI intent into **state changes**.
* `st.session_state` is the **contract** between controllers (writers) and views (readers).
* Understand Streamlit’s **rerun flow** to avoid confusion and race conditions.

You’re now ready to scale your Streamlit MVC with predictable, testable controller actions.

