# **Chapter 16: Async Services (Optional)**

### 🚀 *Goal:*

Learn how to build **asynchronous service layers** that can handle **multiple I/O-bound operations concurrently**, such as API calls or database queries, using Python’s `asyncio` framework.

---

## **1. Why Async Services Matter**

When a service calls multiple APIs or database queries that take time to respond, it can **block** the main thread.
Asynchronous programming allows your app to:

* Handle multiple I/O operations at once.
* Improve responsiveness for web dashboards or controllers.
* Reduce latency for data-heavy dashboards (e.g., multiple REST APIs).

### Example scenario:

Your app needs to:

* Fetch patient data from `patient_api`.
* Fetch lab results from `lab_api`.
  Instead of waiting for one to finish before starting the other, async lets both run **in parallel**.

---

## **2. Threading vs Asyncio**

| Feature     | Threading                | Asyncio                           |
| ----------- | ------------------------ | --------------------------------- |
| Model       | Multiple OS threads      | Single-threaded event loop        |
| Ideal for   | CPU-bound tasks          | I/O-bound tasks (APIs, DB, files) |
| Simplicity  | Easier for small scripts | Requires async/await syntax       |
| Performance | More overhead            | Very lightweight                  |

Use **asyncio** when you are dealing with:

* Network I/O (HTTP APIs, WebSockets)
* Database drivers like `asyncpg`, `aiosqlite`
* File I/O operations with async libraries

---

## **3. Key Concepts**

### 🧩 async / await

* `async def` defines a coroutine (a non-blocking function)
* `await` pauses until the coroutine finishes

```python
import asyncio

async def fetch_data():
    print("Fetching...")
    await asyncio.sleep(2)
    print("Done!")
```

### 🧩 asyncio.gather()

Runs multiple coroutines concurrently and waits for all results:

```python
results = await asyncio.gather(fetch_data(), fetch_data())
```

---

## **4. Async Service Example (HTTP APIs)**

Let’s create a **service** that fetches data from two fake APIs simultaneously.

### 📁 Folder structure

```
app/
 ├── services/
 │    └── async_services.py
 ├── controllers/
 │    └── actions.py
 ├── views/
 │    └── dashboard.py
 └── main.py
```

---

### 📘 **async_services.py**

```python
import asyncio
import httpx

async def fetch_patient_data():
    async with httpx.AsyncClient() as client:
        response = await client.get("https://jsonplaceholder.typicode.com/users")
        return response.json()

async def fetch_lab_data():
    async with httpx.AsyncClient() as client:
        response = await client.get("https://jsonplaceholder.typicode.com/posts")
        return response.json()

async def merge_patient_lab_data():
    # Run both API calls concurrently
    patient_data, lab_data = await asyncio.gather(
        fetch_patient_data(),
        fetch_lab_data()
    )

    # Merge results by index (for demo)
    merged = []
    for p, l in zip(patient_data, lab_data):
        merged.append({
            "patient_name": p["name"],
            "lab_title": l["title"]
        })
    return merged
```

---

### 📘 **controllers/actions.py**

```python
import asyncio
from services.async_services import merge_patient_lab_data

def list_patients_with_labs():
    # Run the async function from sync context
    merged = asyncio.run(merge_patient_lab_data())
    return merged
```

---

### 📘 **views/dashboard.py**

```python
import streamlit as st
from controllers.actions import list_patients_with_labs

def render_dashboard():
    st.title("Async Service Example")
    if st.button("Load Patients & Labs"):
        data = list_patients_with_labs()
        st.dataframe(data)
```

---

### 📘 **main.py**

```python
from views.dashboard import render_dashboard

if __name__ == "__main__":
    import streamlit as st
    render_dashboard()
```

---

## **5. Running the App**

Run:

```bash
streamlit run main.py
```

Click **“Load Patients & Labs”**
You’ll see both API calls complete concurrently — typically **2× faster** than sequential execution.

---

## **6. Notes for Async DB**

If using async DB drivers:

* Use `asyncpg` for PostgreSQL.
* Use `aiosqlite` for SQLite.
* Example:

  ```python
  import aiosqlite

  async with aiosqlite.connect("example.db") as db:
      async with db.execute("SELECT * FROM patients") as cursor:
          async for row in cursor:
              print(row)
  ```

---

## **7. Debugging & Performance Tips**

✅ Use `asyncio.run()` at the **top-level only**.
✅ Avoid blocking calls (like `time.sleep()`) inside async functions; use `await asyncio.sleep()` instead.
✅ Use `asyncio.gather()` instead of manual loops for concurrency.
✅ When combining with Streamlit/Dash, perform async logic **in the service layer only**, not inside UI callbacks.

---

## **🧪 Lab Exercise**

**Goal:**
Fetch two APIs concurrently and merge results in a service.

**Steps:**

1. Create `services/async_services.py` as shown above.
2. Modify `controllers/actions.py` to call `asyncio.run()`.
3. In the UI, add a button to trigger the async operation.
4. Measure how much faster the async version runs compared to the sequential one using `time.perf_counter()`.

**Bonus:**
Try replacing the HTTP APIs with two database queries using `aiosqlite`.

---

## ✅ **Summary**

| Concept            | Key Takeaway                                    |
| ------------------ | ----------------------------------------------- |
| `async` / `await`  | Enables non-blocking I/O                        |
| `asyncio.gather()` | Runs tasks concurrently                         |
| Async Repositories | Useful for DB or API access                     |
| Integration        | Use in service layer, keep controller/view sync |
| Benefit            | Reduced waiting time, smoother UI updates       |

---


