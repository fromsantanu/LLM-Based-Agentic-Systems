# **Chapter 10 â€” Multipage Apps**

## ğŸ¯ **Goal**

Enable multi-page navigation in Dash with separate layouts and controllers for each page, maintaining clear MVC separation.

---

## ğŸ” **Concept Overview**

As your application grows, itâ€™s better to split functionality across **multiple pages** instead of stacking everything into one long layout.
Dash provides a **page registry system** to register and navigate between multiple pages seamlessly.

---

## ğŸ§  **Learn**

### 1. **Page Registry in Dash**

Since Dash 2.5, you can easily define multipage apps using the **Dash Pages** feature.

```python
from dash import Dash, html, dcc

app = Dash(__name__, use_pages=True)

app.layout = html.Div([
    html.H1("My Multipage App"),
    html.Div([
        dcc.Link(page['name'] + " | ", href=page['path'])
        for page in dash.page_registry.values()
    ]),
    dash.page_container
])

if __name__ == "__main__":
    app.run_server(debug=True)
```

âœ… `use_pages=True` â€” enables Dashâ€™s built-in page registry
âœ… `dash.page_container` â€” placeholder for the current pageâ€™s layout
âœ… `dash.page_registry` â€” holds info about all registered pages

---

### 2. **Creating Individual Pages**

Each page is a separate Python file (view + controller) inside a `/pages` folder.

#### Example: `/pages/inventory.py`

```python
from dash import html, dcc, register_page, callback, Output, Input

register_page(__name__, path="/inventory", name="Inventory")

layout = html.Div([
    html.H2("Inventory Dashboard"),
    html.Button("Refresh", id="refresh-btn"),
    html.Div(id="inventory-table")
])

@callback(
    Output("inventory-table", "children"),
    Input("refresh-btn", "n_clicks")
)
def update_inventory(n):
    if not n:
        return "Click refresh to load inventory data."
    return html.Ul([
        html.Li("Stethoscopes: 25"),
        html.Li("Syringes: 500"),
        html.Li("Gloves: 1200 pairs")
    ])
```

âœ… Each page defines its **own layout** and **page-scoped callbacks**
âœ… `register_page(__name__, path="/inventory")` registers it automatically
âœ… The callback logic here acts as the **controller** for that page

---

### 3. **Per-Page Layouts**

Each page can have:

* Its own layout structure
* Independent components and callbacks
* Shared style or theme from a global config

You can even use a **layout factory** for consistent styling:

```python
def page_card(title, content):
    return html.Div([
        html.H3(title),
        html.Div(content, className="card-body")
    ], className="card")
```

Then in `/pages/inventory.py`:

```python
layout = page_card("Inventory Page", [
    html.Button("Refresh", id="refresh-btn"),
    html.Div(id="inventory-table")
])
```

---

### 4. **Global vs. Page-Scoped Callbacks**

| Type            | Where Defined        | Scope                     |
| --------------- | -------------------- | ------------------------- |
| Global callback | main controller      | Can affect multiple pages |
| Page callback   | inside `/pages/*.py` | Affects only that page    |

Page callbacks are automatically registered when the page file is imported.

---

## âš™ï¸ **MVC Integration**

| Layer          | Role                                       | Example                                |
| -------------- | ------------------------------------------ | -------------------------------------- |
| **Model**      | Data access logic (repositories, services) | `/models/inventory_repo.py`            |
| **View**       | Page layout in Dash                        | `/views/pages/inventory.py`            |
| **Controller** | Page callbacks                             | `/controllers/inventory_controller.py` |

You can import the model layer into the controller for real data fetching.

Example:

```python
# controllers/inventory_controller.py
from models.inventory_repo import get_inventory

@callback(Output("inventory-table", "children"), Input("refresh-btn", "n_clicks"))
def show_inventory(n):
    if not n:
        raise PreventUpdate
    data = get_inventory()
    return html.Ul([html.Li(f"{item['name']}: {item['qty']}") for item in data])
```

---

## ğŸ§ª **Lab Exercise â€” Add /inventory Page**

### ğŸ§© **Task**

1. Create a new file `/pages/inventory.py`
2. Register the page with `register_page(__name__, path="/inventory")`
3. Build a layout showing a title, refresh button, and table
4. Add a callback that displays inventory data on button click

### ğŸ—ï¸ **Folder Structure**

```
app/
â”‚
â”œâ”€â”€ main.py              # Root app with page registry
â”œâ”€â”€ models/
â”‚   â””â”€â”€ inventory_repo.py
â”œâ”€â”€ controllers/
â”‚   â””â”€â”€ inventory_controller.py
â”œâ”€â”€ views/
â”‚   â”œâ”€â”€ dashboard.py
â”‚   â””â”€â”€ pages/
â”‚       â””â”€â”€ inventory.py
â””â”€â”€ assets/
    â””â”€â”€ styles.css
```

### âœ… **Example Output**

When running `python main.py`,
youâ€™ll see navigation links like:

```
Dashboard | Inventory
```

Clicking **Inventory** opens the `/inventory` page with dynamic updates.

---

## ğŸ§© **Mini Practice**

**Question:**
How would you create a `/patients` page that lists all patients fetched from a database?

**Hint:**
Use the same pattern:
`register_page(__name__, path="/patients")` â†’ fetch data from repository â†’ render as table.

---

## ğŸ§­ **Summary**

* Multipage apps keep Dash projects modular.
* `register_page()` and `dash.page_registry` make navigation automatic.
* Each page can have its own layout and controller logic.
* MVC structure makes adding new pages easy and maintainable.

---
