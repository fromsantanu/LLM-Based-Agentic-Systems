# **Chapter 11: State & Performance**

## üéØ **Goal**

Optimize user experience and performance by managing state efficiently and preventing unnecessary recomputation or blocking UI.

---

## üß† **Concepts to Learn**

### 1. Clientside Callbacks

Dash normally executes callbacks on the **server** (Python side).
For lightweight operations (e.g., formatting text, toggling styles), you can move them to the **browser** using **JavaScript**.

This avoids a server round-trip ‚Üí faster UI updates.

```python
from dash import Dash, html, Input, Output, clientside_callback

app = Dash(__name__)

app.layout = html.Div([
    html.H3("Clientside Example"),
    html.Button("Click Me", id="btn"),
    html.Div(id="output")
])

# This JS code runs in the browser
clientside_callback(
    """
    function(n_clicks) {
        return "Clicked " + n_clicks + " times";
    }
    """,
    Output("output", "children"),
    Input("btn", "n_clicks")
)

if __name__ == "__main__":
    app.run_server(debug=True)
```

‚úÖ *Result:* No server load; instantaneous updates.

---

### 2. Memoization (Caching)

If your service or controller functions perform expensive computations (like database queries or aggregations), you can **cache** results.

Dash integrates easily with:

* `functools.lru_cache`
* `flask_caching.Cache`

#### Example ‚Äì Cache a Service Function

```python
# models/services.py
from functools import lru_cache
import time

@lru_cache(maxsize=32)
def get_sales_summary(year):
    print("Fetching fresh data...")
    time.sleep(3)  # simulate slow computation
    return {"year": year, "sales": 120000 + year}
```

#### Controller

```python
# controllers/dashboard_controller.py
from dash import Input, Output, State, callback
from models.services import get_sales_summary

@callback(
    Output("sales-output", "children"),
    Input("load-btn", "n_clicks"),
    State("year-input", "value"),
    prevent_initial_call=True
)
def load_sales_summary(n, year):
    data = get_sales_summary(year)
    return f"Sales for {year}: ${data['sales']}"
```

üß© *When the same year is requested again, it loads instantly.*

---

### 3. Long Callbacks and Spinners

Dash provides **background callbacks** for long-running operations to keep the app responsive.

You can combine this with **spinners** to show a ‚Äúloading‚Äù message.

```python
from dash import Dash, html, Input, Output, dcc
import time

app = Dash(__name__, suppress_callback_exceptions=True)

app.layout = html.Div([
    html.H3("Long Callback Example"),
    html.Button("Process Data", id="process-btn"),
    dcc.Loading(
        id="loading",
        type="circle",
        children=html.Div(id="process-output")
    )
])

@app.callback(
    Output("process-output", "children"),
    Input("process-btn", "n_clicks"),
    prevent_initial_call=True
)
def long_process(n):
    time.sleep(5)  # Simulate heavy task
    return "Processing Complete!"

if __name__ == "__main__":
    app.run_server(debug=True)
```

‚öôÔ∏è The **spinner** keeps the UI alive while processing.

---

## üß™ **Lab: Cache Service Function + Spinner**

### Step 1 ‚Äì Service

```python
# models/services.py
from functools import lru_cache
import time

@lru_cache(maxsize=16)
def fetch_inventory_data():
    time.sleep(4)
    return [{"id": 1, "name": "Laptop", "qty": 12},
            {"id": 2, "name": "Mouse", "qty": 50}]
```

### Step 2 ‚Äì Controller

```python
# controllers/inventory_controller.py
from dash import Input, Output, callback
from models.services import fetch_inventory_data

@callback(Output("inventory-table", "children"), Input("refresh-btn", "n_clicks"), prevent_initial_call=True)
def load_inventory(n):
    data = fetch_inventory_data()
    rows = [f"{item['id']}: {item['name']} (Qty: {item['qty']})" for item in data]
    return [html.Div(row) for row in rows]
```

### Step 3 ‚Äì View

```python
# views/inventory.py
from dash import html, dcc

def layout():
    return html.Div([
        html.H3("Inventory Data"),
        html.Button("Refresh", id="refresh-btn"),
        dcc.Loading(
            id="loading-spinner",
            type="circle",
            children=html.Div(id="inventory-table")
        )
    ])
```

‚úÖ When you press **Refresh**, the spinner appears for ~4 seconds, then displays results.
‚úÖ Second press loads **instantly** due to caching.

---

## üí° **Tips**

* Use caching for deterministic results (no randomness or changing state).
* Use `memoize` or Redis for multi-user caching in production.
* Offload heavy tasks (ML inference, report generation) via **Celery workers** or **async tasks**.
* Prefer clientside callbacks for UI-only logic (like toggling visibility or style changes).

---
