# Chapter 6: Type Aliases

### 6.1 What Are Type Aliases?

A **type alias** is a way to give a descriptive name to an existing type.
It does not create a new type but helps make code more **readable** and **self-documenting**.

For example, if a function works with a user ID represented by an `int`, using a type alias makes the purpose clearer.

---

### 6.2 Creating Type Aliases

You can create a type alias by assigning a type to a variable:

```python
from typing import List, Dict

# Simple alias
UserId = int

# Alias for a list of integers
Vector = List[int]

# Alias for a dictionary with string keys and int values
ScoreBoard = Dict[str, int]
```

---

### 6.3 Example 1: Using a Simple Alias

```python
UserId = int

def get_user_name(user_id: UserId) -> str:
    # pretend we fetch a username from a database
    return f"User_{user_id}"

print(get_user_name(101))  # Output: User_101
```

Here, `UserId` is just an `int`, but the alias makes it clear that this `int` represents a **user ID**.

---

### 6.4 Example 2: Complex Aliases

```python
from typing import List

Vector = List[int]

def add_vectors(v1: Vector, v2: Vector) -> Vector:
    return [x + y for x, y in zip(v1, v2)]

print(add_vectors([1, 2, 3], [4, 5, 6]))  # Output: [5, 7, 9]
```

Here, `Vector` makes the function signature easier to understand compared to repeatedly writing `List[int]`.

---

### 6.5 Example 3: Aliases for Dictionaries

```python
from typing import Dict

ScoreBoard = Dict[str, int]

def update_score(board: ScoreBoard, player: str, points: int) -> None:
    board[player] = board.get(player, 0) + points

scores: ScoreBoard = {}
update_score(scores, "Alice", 10)
update_score(scores, "Bob", 5)

print(scores)  # Output: {'Alice': 10, 'Bob': 5}
```

Here, `ScoreBoard` makes it obvious that the dictionary is storing player names and their scores.

---

### 6.6 Example 4: Nested Aliases

```python
from typing import Dict, List

# Alias for more complex types
StudentName = str
Grades = List[int]
ClassRecord = Dict[StudentName, Grades]

def add_grade(record: ClassRecord, student: StudentName, grade: int) -> None:
    if student not in record:
        record[student] = []
    record[student].append(grade)

students: ClassRecord = {}
add_grade(students, "John", 85)
add_grade(students, "John", 90)
add_grade(students, "Alice", 92)

print(students)  
# Output: {'John': [85, 90], 'Alice': [92]}
```

Using aliases makes the structure easier to understand at a glance.

---

### 6.7 Key Points

* Type aliases improve **readability** and **maintainability**.
* They don’t create new types; they just give a descriptive name to existing ones.
* Use them for complex types (nested `Dict`, `List`, `Tuple`) to simplify function signatures.

---

✅ **Best Practice**: Use type aliases when a type has a **specific role or meaning** in your code.

---
