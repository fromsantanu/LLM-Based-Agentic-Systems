# Chapter 4 — Optional & Union Types

This chapter clarifies when to use `Optional` vs `Union`, how they’re equivalent in some cases, and the practical patterns you’ll use in real code.

---

## 1) Quick definitions

* **`Union[A, B, ...]`**: A value that can be **one of several types**.
  Shorthand (PEP 604): `A | B | ...`

* **`Optional[T]`**: Exactly the same as `Union[T, None]` (and the same as `T | None`).
  Use it when you specifically mean “**maybe missing / maybe `None`**”.

> Rule of thumb:
> Use `Optional[T]` when the only extra possibility is `None`.
> Use `Union[...]` when **multiple** distinct non-`None` types are allowed.

---

## 2) Optional vs Union (the core idea)

```python
from typing import Optional, Union

# These three are equivalent
age1: Optional[int] = None
age2: Union[int, None] = None
age3: int | None = None
```

* `Optional[int]` communicates intent: “This `int` might be absent.”
* `Union[int, str]` communicates a genuine either/or type with **two non-None** types.

---

## 3) Common use cases

### 3.1 Function parameters that can be omitted (`None` means “use default”)

```python
from typing import Optional

def greet(name: Optional[str] = None) -> str:
    if name is None:
        name = "friend"
    return f"Hello, {name}!"

print(greet())         # "Hello, friend!"
print(greet("Santanu"))  # "Hello, Santanu!"
```

### 3.2 Return values that might not exist

```python
from typing import Optional

def find_user_age(user_id: int) -> Optional[int]:
    database = {1: 42, 2: 35}
    return database.get(user_id)  # returns int or None
```

### 3.3 True multi-type unions (not just “maybe missing”)

```python
from typing import Union

JsonScalar = Union[str, int, float, bool, None]

def normalize_scalar(x: JsonScalar) -> str:
    return "null" if x is None else str(x)
```

---

## 4) Pattern: Narrowing `Optional` safely

Type checkers require you to **prove** a value isn’t `None` before using it as `T`.

```python
from typing import Optional

def first_char(s: Optional[str]) -> str:
    if s is None:
        return ""          # early return
    return s[0]            # now s is narrowed to str
```

### Alternatives for narrowing

* **Guard clause** (shown above)
* **Local temporary variable**
* **`assert s is not None`** (use when it’s a programming invariant)
* **`typing.cast(T, value)`** (escape hatch; use sparingly)

```python
from typing import Optional, cast

def require_name(name: Optional[str]) -> str:
    assert name is not None, "name is required here"
    return name.upper()

def require_name_cast(name: Optional[str]) -> str:
    return cast(str, name).upper()   # will crash at runtime if name is None
```

---

## 5) Optional parameters vs default values

An `Optional[T]` parameter doesn’t need a default, but **if you want it to be optional at call site**, give it a default (usually `None`):

```python
# Caller must pass something (could be None)
def save(label: Optional[str]) -> None:
    ...

# Caller may omit the argument entirely
def save2(label: Optional[str] = None) -> None:
    ...
```

---

## 6) Dataclasses & Optional fields

```python
from dataclasses import dataclass
from typing import Optional

@dataclass
class Person:
    name: str
    email: Optional[str] = None   # can be missing

p = Person(name="Aparajita")
# p.email is None → acceptable
```

**Tip:** If the field is a container and you want a default, use `default_factory`, not a mutable default.

```python
from dataclasses import dataclass, field
from typing import Optional, List

@dataclass
class Course:
    title: str
    tags: List[str] = field(default_factory=list)
    note: Optional[str] = None
```

---

## 7) TypedDict and “maybe missing” vs “present but None”

In **`TypedDict`**, `Optional[T]` means **present and can be `None`**.
If you want a key that **may be absent**, use `NotRequired` (Python 3.11+) or `typing_extensions`.

```python
from typing import Optional, TypedDict
from typing_extensions import NotRequired  # if < 3.11 use typing_extensions

class UserTD(TypedDict):
    id: int
    # key can be omitted entirely:
    nickname: NotRequired[str]
    # key is present but its value may be None:
    email: Optional[str]
```

* `nickname` may not appear at all.
* `email` must appear, but might be `None`.

---

## 8) Unions with `|` (PEP 604 syntax)

Modern, concise, and preferred on Python 3.10+:

```python
def stringify(x: int | float | str | None) -> str:
    return "null" if x is None else str(x)
```

This is equivalent to `Union[int, float, str, None]`.

---

## 9) Worked examples

### 9.1 `Optional[int]` vs `Union[int, None]`

```python
from typing import Optional, Union

def add_one_opt(x: Optional[int]) -> Optional[int]:
    return None if x is None else x + 1

def add_one_union(x: Union[int, None]) -> Union[int, None]:
    return None if x is None else x + 1

# same behavior & same type semantics
```

### 9.2 Business logic with clear intent

```python
from typing import Optional, Union

TaxId = Union[int, str]        # genuinely two non-None types
Email = Optional[str]          # may be missing

def register(tax_id: TaxId, email: Email = None) -> str:
    # validate tax_id (int path vs str path)
    if isinstance(tax_id, int):
        tid = f"PAN{tax_id:010d}"
    else:
        tid = tax_id.upper()

    contact = email or "<no-email>"
    return f"Registered {tid} with contact {contact}"
```

### 9.3 Parsing-with-fallbacks

```python
from typing import Optional

def to_int_safe(s: str) -> Optional[int]:
    try:
        return int(s)
    except ValueError:
        return None

val = to_int_safe("123")  # 123
bad = to_int_safe("abc")  # None
```

---

## 10) Pitfalls & pro tips

1. **Don’t overuse `Optional`**: Only annotate `Optional[T]` when `None` is a real, expected state.
2. **Always narrow before use**: Type checkers will (rightly) complain if you index or call methods on a `T | None` without checking `None`.
3. **Prefer `|` syntax on 3.10+** for readability.
4. **Communicate intent**: Use `Optional[T]` to signal “may be missing”, and `Union[...]` for true either/or types.
5. **TypedDict nuance**: `Optional[T]` ≠ “key may be absent”. Use `NotRequired[...]` for genuinely optional keys.

---

## 11) Mini exercises

1. Write a function `head(xs: list[int]) -> Optional[int]` that returns the first item or `None` if the list is empty.
2. Create a `Union` named `PathLike = Union[str, bytes]` and write `open_readable(p: PathLike) -> str` that returns file contents (you can stub/pretend the IO if needed).
3. Define a `TypedDict` for a product where `sku` is required, `description` may be **absent**, and `discount_code` is **present but may be `None`**.

---

## 12) Key takeaways

* `Optional[T]` is exactly `Union[T, None]` and best for “maybe missing” values.
* `Union[...]` expresses multiple possible types (not just “maybe `None`”).
* Always **narrow** `T | None` before using it as `T`.
* Prefer the modern `|` syntax on Python 3.10+ for clarity.

