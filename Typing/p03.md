# Chapter 3: Collections & Generics

In Python, collections like **list, tuple, dictionary, and set** are widely used to group and manage data. Type hints make these collections clearer by specifying what kind of elements they contain. This helps with readability, tooling support, and catching errors early.

---

## 3.1 Lists

* A **list** is an ordered, mutable collection.
* Without type hints, a list can hold any type of elements.
* With type hints, you can specify what types it should hold.

```python
from typing import List

# A list of integers
numbers: List[int] = [1, 2, 3, 4]

# A list of strings
names: List[str] = ["Alice", "Bob", "Charlie"]

# Wrong type (detected by static checkers, but Python runs anyway)
numbers.append("five")  # ❌ type checker will warn
```

---

## 3.2 Tuples

* A **tuple** is an ordered, immutable collection.
* Tuples can store a fixed number of elements with defined types.

```python
from typing import Tuple

# A tuple of (string, int)
person: Tuple[str, int] = ("Alice", 30)

# A tuple of three floats
coordinates: Tuple[float, float, float] = (12.5, 45.3, 9.0)

# Wrong type
person = ("Bob", "thirty")  # ❌ static checker warning
```

---

## 3.3 Dictionaries

* A **dictionary** maps keys to values.
* With type hints, you can declare what type the keys and values should be.

```python
from typing import Dict

# Dictionary with string keys and integer values
scores: Dict[str, int] = {"Alice": 95, "Bob": 88}

# Dictionary with string keys and float values
prices: Dict[str, float] = {"apple": 0.99, "banana": 0.59}

# Wrong type
scores["Charlie"] = "high"  # ❌ static checker warning
```

---

## 3.4 Sets

* A **set** is an unordered collection of unique elements.
* Use generics to declare the type of items in the set.

```python
from typing import Set

# Set of integers
unique_ids: Set[int] = {1, 2, 3, 4}

# Set of strings
tags: Set[str] = {"python", "typing", "generics"}

# Wrong type
unique_ids.add("five")  # ❌ static checker warning
```

---

## 3.5 Parameterized Generics

You can use **parameterized generics** to make type hints more precise:

* `List[int]`: a list containing only integers
* `Dict[str, float]`: a dictionary mapping strings to floats
* `Tuple[str, int, float]`: a tuple with exactly three elements: string, int, float

Example:

```python
from typing import List, Dict, Tuple

# A list of integers
ages: List[int] = [25, 30, 40]

# A dictionary mapping names to ages
age_map: Dict[str, int] = {"Alice": 25, "Bob": 30}

# A tuple representing (Name, Age, Height)
profile: Tuple[str, int, float] = ("Charlie", 35, 5.9)
```

---

✅ **Key Takeaways**

* Collections can be parameterized with type hints to enforce consistency.
* Static checkers (like mypy, Pyright, or IDEs) will warn if wrong types are used.
* Python itself does not enforce types at runtime, but hints greatly improve code quality.

---

