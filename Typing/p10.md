# Chapter 10: Practical Use Cases

So far, we’ve seen how type hints improve readability and static analysis. In this chapter, we’ll look at **practical use cases** of type hints in real-world Python projects.

---

## 10.1 Type Hints in Data Models (Pydantic & FastAPI)

Type hints become powerful when combined with frameworks like **Pydantic** (for data validation) and **FastAPI** (for building APIs).

Pydantic uses type hints to **validate and parse data automatically**.

### Example 1: Using Pydantic Models

```python
from pydantic import BaseModel
from typing import List, Optional

class User(BaseModel):
    id: int
    name: str
    email: str
    age: Optional[int] = None
    tags: List[str] = []

# Incoming data (e.g., from API request)
data = {
    "id": 1,
    "name": "Alice",
    "email": "alice@example.com",
    "tags": ["premium", "verified"]
}

user = User(**data)
print(user)
print(user.dict())   # Convert back to dictionary
```

✅ **What happens here?**

* `User` automatically checks that `id` is an `int`, `name` is a `str`, and `tags` is a `list of str`.
* If invalid data is provided (e.g., `id="abc"`), Pydantic raises a validation error.

---

### Example 2: FastAPI Endpoint with Type Hints

```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List

app = FastAPI()

class Item(BaseModel):
    name: str
    price: float
    tags: List[str] = []

@app.post("/items/")
def create_item(item: Item):
    return {"message": "Item created", "item": item}
```

✅ **What happens here?**

* FastAPI uses type hints (`Item`) to validate incoming requests automatically.
* If the request JSON doesn’t match the expected schema, FastAPI returns a **400 Bad Request** with details.
* The OpenAPI documentation (`/docs`) is auto-generated based on type hints.

---

## 10.2 Improving IDE Auto-Completion & Documentation

Another practical benefit of type hints is **better tooling** support.

When you add type hints, IDEs (like PyCharm, VS Code) can:

* Suggest correct attributes and methods.
* Show inline documentation.
* Catch potential type errors **before runtime**.

---

### Example 3: Without Type Hints

```python
def add_user(user):
    return f"User {user['name']} added"
```

❌ Problem:

* IDE doesn’t know the structure of `user`.
* Auto-completion won’t work.
* Easy to make mistakes like `user['nam']`.

---

### Example 4: With Type Hints

```python
from typing import TypedDict

class UserDict(TypedDict):
    name: str
    age: int

def add_user(user: UserDict) -> str:
    return f"User {user['name']} added"

# IDE now suggests user["name"] and user["age"]
```

✅ Benefits:

* IDE now knows `user` must have `"name"` and `"age"`.
* Auto-completion works.
* Documentation is clearer.

---

### Example 5: Function Documentation

```python
from typing import List

def average(scores: List[int]) -> float:
    """Calculate the average score.

    Args:
        scores (List[int]): A list of integer scores.

    Returns:
        float: The average score.
    """
    return sum(scores) / len(scores)
```

✅ Benefits:

* IDE shows the function’s expected inputs/outputs.
* Documentation tools (like Sphinx) pick up type hints for API docs.

---

# ✅ Summary

* **Pydantic + FastAPI**: Type hints enable automatic validation, parsing, and API documentation.
* **IDEs**: Type hints improve auto-completion, reduce errors, and enhance readability.
* **Docs**: Type hints + docstrings make code more self-explanatory.

👉 Type hints are not just for static analysis — they also improve **real-world productivity**.

---

