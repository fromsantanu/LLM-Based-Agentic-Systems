# Chapter 7: Protocols & Structural Typing (Python 3.8+)

In Python, we often rely on **duck typing**:

> *“If it walks like a duck and quacks like a duck, it’s a duck.”*

This means that instead of checking the actual type of an object, we check whether it provides the required methods or attributes.

Starting with Python 3.8, the `typing` module introduced **Protocol**, which allows us to **formally declare interfaces** for duck typing.

---

## 7.1 What is a Protocol?

* A **Protocol** is like an interface (in other languages).
* If a class implements the methods/attributes defined in a Protocol, it is considered compatible—even if it doesn’t explicitly inherit from the Protocol.
* This is called **structural subtyping**.

---

## 7.2 Defining a Protocol

```python
from typing import Protocol

class FileLike(Protocol):
    def read(self) -> str: ...
    def write(self, data: str) -> None: ...
```

Here:

* `FileLike` is a Protocol.
* Any class with `read()` (returning `str`) and `write(data: str)` methods will be treated as a `FileLike`.

---

## 7.3 Example: Using Protocol for Duck Typing

```python
from typing import Protocol

class FileLike(Protocol):
    def read(self) -> str: ...
    def write(self, data: str) -> None: ...

# A class that follows the protocol
class MyFile:
    def __init__(self):
        self.content = ""
    
    def read(self) -> str:
        return self.content
    
    def write(self, data: str) -> None:
        self.content += data

# A function that expects FileLike objects
def save_and_read(file: FileLike, data: str) -> str:
    file.write(data)
    return file.read()

f = MyFile()
print(save_and_read(f, "Hello, World!"))  # ✅ Works: "Hello, World!"
```

👉 Even though `MyFile` does not inherit from `FileLike`, it works because it **structurally matches** the protocol.

---

## 7.4 Protocols with Built-in Classes

Python’s built-in file objects already have `read()` and `write()` methods, so they automatically match `FileLike`.

```python
with open("example.txt", "w+") as f:
    f.write("Python Protocols!")
    f.seek(0)
    print(save_and_read(f, " More text"))  
```

Output:

```
Python Protocols! More text
```

---

## 7.5 Extending Protocols

Protocols can also specify additional behavior.

```python
class ClosableFile(Protocol):
    def read(self) -> str: ...
    def write(self, data: str) -> None: ...
    def close(self) -> None: ...

class TextLogger:
    def read(self) -> str:
        return "Logs not readable"
    
    def write(self, data: str) -> None:
        print(f"Log: {data}")
    
    def close(self) -> None:
        print("Logger closed")

def process(file: ClosableFile):
    file.write("Start process")
    file.close()

process(TextLogger())  # ✅ Works fine
```

---

## 7.6 Why Use Protocols?

1. **Readability** – Makes contracts between functions and objects explicit.
2. **Tooling** – Type checkers like `mypy` or IDEs can catch type mismatches.
3. **Flexibility** – You don’t force inheritance; you only require structural compatibility.

---

✅ **Summary**:

* `Protocol` enables **structural typing** in Python.
* Any object that provides required methods/attributes can be used, without inheritance.
* Useful for duck typing with **type safety**.

---
