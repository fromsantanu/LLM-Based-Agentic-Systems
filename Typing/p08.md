# Chapter 8: Advanced Typing

In this chapter, we explore more **advanced type hinting features** introduced in Python’s `typing` module. These features help in creating precise and robust type annotations for real-world applications.

---

## 8.1 `Literal`

The `Literal` type allows you to restrict a variable or parameter to a specific set of constant values.

```python
from typing import Literal

def get_status(code: Literal[200, 404, 500]) -> str:
    if code == 200:
        return "OK"
    elif code == 404:
        return "Not Found"
    elif code == 500:
        return "Internal Server Error"

print(get_status(200))   # OK
print(get_status(404))   # Not Found
# get_status(403)  # ❌ Static type checker will flag this as invalid
```

✅ Useful for defining **enums or fixed choices**.

---

## 8.2 `TypedDict`

`TypedDict` is used to define **dictionary-like objects** with fixed keys and specified value types.

```python
from typing import TypedDict

class User(TypedDict):
    id: int
    name: str
    email: str

def get_user_info() -> User:
    return {"id": 1, "name": "Alice", "email": "alice@example.com"}

user = get_user_info()
print(user["name"])  # Alice
```

✅ Helps define **structured dictionaries** with better type checking.

---

## 8.3 `Final`

The `Final` type is used to indicate that a variable or method **cannot be reassigned or overridden**.

```python
from typing import Final

PI: Final = 3.14159

def area_of_circle(radius: float) -> float:
    return PI * radius * radius

# PI = 3.14  # ❌ Static type checker will raise an error
```

```python
from typing import Final

class Base:
    def method(self) -> None:
        print("Base method")

    def final_method(self) -> None:  # type: Final
        print("This cannot be overridden")

class Derived(Base):
    def method(self) -> None:  # ✅ Allowed
        print("Derived method")

    # def final_method(self) -> None:  # ❌ Error if overridden
    #     print("Overridden")
```

✅ Useful for **constants and methods that must not be overridden**.

---

## 8.4 `ClassVar`

`ClassVar` is used to declare **class-level variables** (not instance variables).

```python
from typing import ClassVar

class Student:
    school_name: ClassVar[str] = "Oxford University"  # shared by all instances
    name: str

    def __init__(self, name: str) -> None:
        self.name = name

s1 = Student("Alice")
s2 = Student("Bob")

print(Student.school_name)  # Oxford University
print(s1.school_name)       # Oxford University
```

✅ Ensures type checkers don’t confuse class variables with instance attributes.

---

## 8.5 `Generic` and `TypeVar`

When building **custom generic classes**, `TypeVar` is used to define type parameters, and `Generic` makes a class parameterized.

### Example 1: A Generic Box

```python
from typing import TypeVar, Generic

T = TypeVar('T')  # Define a type variable

class Box(Generic[T]):
    def __init__(self, content: T) -> None:
        self.content = content

    def get_content(self) -> T:
        return self.content

int_box = Box 
str_box = Box[str]("Hello")

print(int_box.get_content())  # 123
print(str_box.get_content())  # Hello
```

### Example 2: Generic Function

```python
from typing import TypeVar

T = TypeVar("T")

def first_element(lst: list[T]) -> T:
    return lst[0]

print(first_element([1, 2, 3]))      # 1
print(first_element(["a", "b", "c"]))  # a
```

✅ Makes functions and classes **type-safe** and reusable.

---

# ✅ Summary

* **`Literal`** → restricts values to specific constants.
* **`TypedDict`** → structured dictionary types.
* **`Final`** → constants or methods that cannot be changed.
* **`ClassVar`** → marks class-level variables.
* **`Generic` + `TypeVar`** → create custom generic classes and functions.

---

