# Chapter 1: Introduction to Type Hints

Python is a dynamically typed language. This means you can assign any type of value to a variable without explicitly declaring its type. While this flexibility makes Python easy to use, it can sometimes make code harder to read, maintain, or debug.

**Type hints** (introduced in [PEP 484](https://peps.python.org/pep-0484/)) allow developers to specify the expected types of variables, function parameters, and return values.

---

## Why Type Hints Are Useful

1. **Readability**
   Type hints act as documentation. Other developers (and your future self) can quickly understand what type of data is expected.

   ```python
   # Without type hints
   def area(radius):
       return 3.14 * radius * radius

   # With type hints
   def area(radius: float) -> float:
       return 3.14 * radius * radius
   ```

   👉 In the second example, it’s clear that `radius` must be a `float` and the function will return a `float`.

---

2. **Tooling Support**
   Editors like VS Code or PyCharm use type hints to provide **auto-completion** and **intelligent suggestions**.

   ```python
   from typing import List

   def total_length(words: List[str]) -> int:
       return sum(len(word) for word in words)
   ```

   👉 Here, the editor knows `words` is a list of strings, so it can suggest string methods when you access elements.

---

3. **Error Catching**
   Type hints don’t enforce correctness at runtime, but tools like `mypy`, `pyright`, or `pylance` can catch mistakes before execution.

   ```python
   def add(x: int, y: int) -> int:
       return x + y

   # Static checkers will warn:
   result = add(10, "20")   # ❌ Wrong: passing a string instead of int
   ```

   👉 Running `mypy` will raise:

   ```
   error: Argument 2 to "add" has incompatible type "str"; expected "int"
   ```

---

## Difference Between Runtime and Static Type Checking

* **Runtime (Python itself):**
  Python **ignores type hints** at runtime. The interpreter doesn’t enforce them.

  ```python
  def greet(name: str) -> str:
      return "Hello " + name

  print(greet("Alice"))  # ✅ Works
  print(greet(123))      # 😮 Still works, but not intended
  ```

  👉 At runtime, Python just concatenates `"Hello "` with `123`, which causes an error (`TypeError`) only when executed.

---

* **Static Type Checking (Tools like mypy):**
  Static type checkers analyze your code **before execution** and flag type inconsistencies.

  Example with `mypy`:

  ```python
  def multiply(a: int, b: int) -> int:
      return a * b

  result = multiply(5, "hello")  # ❌ Wrong type
  ```

  `mypy` output:

  ```
  error: Argument 2 to "multiply" has incompatible type "str"; expected "int"
  ```

---

✅ **Summary:**

* Type hints improve **readability**, help **tools** assist you, and **catch errors early**.
* Python doesn’t enforce type hints at runtime (dynamic typing remains), but static checkers like `mypy` do.

---
