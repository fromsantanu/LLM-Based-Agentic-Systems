# **Chapter 8. Tool Integration**

In Agentic AI, tools are the "hands" of the agent. While the LLM (Large Language Model) provides reasoning and language capabilities, tools allow it to interact with the outside world—fetching data, running computations, or calling external APIs. Integrating tools into your LangChain workflow makes agents more capable, reliable, and useful in real-world applications.

---

## Adding Built-in Tools

LangChain comes with a number of built-in tools that can be directly plugged into your agents. These cover common tasks such as search, knowledge lookup, and computation.

### Example Tools:

* **SerpAPI**: A search engine wrapper for real-time web queries.
* **Wikipedia**: Fetch summaries and article content from Wikipedia.
* **Math (LLMMathChain)**: Perform step-by-step calculations.

```python
from langchain.agents import initialize_agent, load_tools
from langchain.llms import OpenAI

# Load LLM
llm = OpenAI(temperature=0)

# Load built-in tools
tools = load_tools(["serpapi", "wikipedia", "llm-math"], llm=llm)

# Initialize agent with tools
agent = initialize_agent(tools, llm, agent="zero-shot-react-description", verbose=True)

# Example query
agent.run("Who won the Nobel Prize in Physics in 2020? Calculate the number of years since their award.")
```

Here, the agent combines search (SerpAPI), factual recall (Wikipedia), and calculation (Math) to provide a complete answer.

---

## Creating Custom Tools in Python

You can define your own tools using simple Python functions. This allows agents to call your application logic, database queries, or even device controls.

```python
from langchain.tools import tool

@tool
def convert_temperature(celsius: float) -> float:
    """Convert Celsius to Fahrenheit."""
    return (celsius * 9/5) + 32

# Register tool
custom_tools = [convert_temperature]

# Use in an agent
agent = initialize_agent(custom_tools, llm, agent="zero-shot-react-description", verbose=True)

agent.run("Convert 37 degrees Celsius to Fahrenheit.")
```

This approach makes it easy to expose custom logic as tools for the agent to use.

---

## Connecting External APIs

Tools can also wrap API calls, allowing the agent to interact with external services like weather, finance, or healthcare systems.

### Example: Weather API

```python
import requests
from langchain.tools import tool

@tool
def get_weather(city: str) -> str:
    """Get current weather for a given city using OpenWeather API."""
    api_key = "YOUR_API_KEY"
    url = f"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric"
    response = requests.get(url)
    data = response.json()
    if "main" in data:
        return f"The temperature in {city} is {data['main']['temp']}°C with {data['weather'][0]['description']}."
    return "Weather data not available."

# Example usage
agent = initialize_agent([get_weather], llm, agent="zero-shot-react-description", verbose=True)
agent.run("What is the weather in London right now?")
```

### Example: Finance API

```python
@tool
def get_stock_price(symbol: str) -> str:
    """Get the latest stock price for a company symbol."""
    url = f"https://finnhub.io/api/v1/quote?symbol={symbol}&token=YOUR_API_KEY"
    response = requests.get(url).json()
    return f"The current price of {symbol} is ${response['c']}."
```

### Example: Healthcare API

You can integrate healthcare APIs for patient data, treatment recommendations, or drug lookup (ensuring compliance with privacy and data security standards).

```python
@tool
def drug_info(drug_name: str) -> str:
    """Fetch drug information from FDA API."""
    url = f"https://api.fda.gov/drug/label.json?search=openfda.generic_name:{drug_name}"
    response = requests.get(url).json()
    if "results" in response:
        return response["results"][0]["description"][0]
    return "Drug information not found."
```

---

## Handling Errors and Retries in Tool Execution

External tools are not always reliable. APIs can fail, return malformed data, or hit rate limits. LangChain provides mechanisms to handle these gracefully.

### Best Practices:

1. **Use try/except blocks** inside your tool definitions.
2. **Return user-friendly error messages** instead of raw exceptions.
3. **Implement retries with exponential backoff** for unstable APIs.
4. **Set timeouts** on requests to prevent blocking.

```python
import time
import requests
from langchain.tools import tool

@tool
def safe_get_weather(city: str) -> str:
    """Fetch weather with retries and error handling."""
    api_key = "YOUR_API_KEY"
    url = f"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric"
    
    for attempt in range(3):  # Retry up to 3 times
        try:
            response = requests.get(url, timeout=5)
            response.raise_for_status()
            data = response.json()
            return f"{city}: {data['main']['temp']}°C"
        except Exception as e:
            time.sleep(2 ** attempt)  # exponential backoff
            error = str(e)
    return f"Failed to fetch weather data for {city}. Error: {error}"
```

---

## Key Takeaways

* **Built-in tools** cover common needs (search, math, Wikipedia).
* **Custom tools** let you expose your own Python functions as agent actions.
* **External API tools** extend agent capabilities into weather, finance, healthcare, and more.
* **Error handling & retries** are crucial for production-grade reliability.

With effective tool integration, you can transform a generic language model into a powerful agent that operates across knowledge domains and APIs.

---

