# Lesson 15: Real-Time Updates & Frontend Polling

**Goal:** show live job status to users via **FastAPI + WebSockets** and, as a fallback, **HTTP polling** from Streamlit or React. You’ll wire progress reporting from the worker to Redis, expose `/status/{job_id}` and `/ws/{job_id}`, and render progress bars.

---

## What you’ll build

* A **progress model** every job reports into Redis.
* A **REST status endpoint** (for polling).
* A **WebSocket endpoint** (for push/live updates).
* Two frontends:

  * **Streamlit**: simple polling `st.progress`.
  * **React**: both polling and WebSocket versions.

---

## 1) Progress model & Redis layout

Pick a consistent wire format so UI code stays simple.

```json
// Progress JSON (stored in Redis and broadcast over WS)
{
  "job_id": "abcd1234",
  "status": "queued|started|running|paused|canceled|failed|finished",
  "percent": 0,              // 0..100
  "message": "step 2/5...",
  "result": null,            // any JSON-serializable object on finish
  "error": null,             // {type, detail} if failed
  "updated_at": "2025-10-28T10:21:34Z"
}
```

**Redis keys:**

* `job:<id>:progress` → JSON string of the latest progress snapshot.
* (optional) `job:<id>:channel` → Pub/Sub channel name (e.g., `job:<id>:updates`) for WS push.

---

## 2) Updating progress from workers

### 2.1 RQ worker example

```python
# workers/tasks.py
import json, time, redis, datetime as dt
r = redis.Redis.from_url("redis://localhost:6379/0")

def _write_progress(job_id, status, percent=None, message=None, result=None, error=None):
    snap = {
        "job_id": job_id,
        "status": status,
        "percent": percent if percent is not None else 0,
        "message": message or "",
        "result": result,
        "error": error,
        "updated_at": dt.datetime.utcnow().isoformat() + "Z",
    }
    r.set(f"job:{job_id}:progress", json.dumps(snap))
    r.publish(f"job:{job_id}:updates", json.dumps(snap))  # for WebSocket push

def long_task(job_id: str, n_steps: int = 5):
    _write_progress(job_id, "started", 0, "starting...")
    try:
        for i in range(1, n_steps + 1):
            time.sleep(1)  # do real work here
            pct = int(i * 100 / n_steps)
            _write_progress(job_id, "running", pct, f"step {i}/{n_steps}")
        result = {"msg": "done", "value": 42}
        _write_progress(job_id, "finished", 100, "complete", result=result)
        return result
    except Exception as e:
        _write_progress(job_id, "failed", message="error", error={"type": type(e).__name__, "detail": str(e)})
        raise
```

> **Tip (RQ):** you can also use `job.meta['progress']=...; job.save_meta()` but writing a **separate Redis key** keeps API/UI agnostic to the queue backend.

### 2.2 ARQ worker example (async)

```python
# workers/arq_tasks.py
import json, datetime as dt
import asyncio, aioredis

async def write_progress(redis, job_id, **kw):
    snap = {
        "job_id": job_id,
        "status": kw.get("status", "running"),
        "percent": kw.get("percent", 0),
        "message": kw.get("message", ""),
        "result": kw.get("result"),
        "error": kw.get("error"),
        "updated_at": dt.datetime.utcnow().isoformat() + "Z",
    }
    await redis.set(f"job:{job_id}:progress", json.dumps(snap))
    await redis.publish(f"job:{job_id}:updates", json.dumps(snap))

async def long_task(ctx, job_id: str, n_steps: int = 5):
    redis = ctx["redis"]
    await write_progress(redis, job_id, status="started", percent=0, message="starting...")
    try:
        for i in range(1, n_steps + 1):
            await asyncio.sleep(1)
            pct = int(i * 100 / n_steps)
            await write_progress(redis, job_id, status="running", percent=pct, message=f"step {i}/{n_steps}")
        result = {"msg": "done", "value": 42}
        await write_progress(redis, job_id, status="finished", percent=100, message="complete", result=result)
        return result
    except Exception as e:
        await write_progress(redis, job_id, status="failed", message="error", error={"type": type(e).__name__, "detail": str(e)})
        raise
```

---

## 3) FastAPI: enqueue, status (poll), and WebSocket

```python
# app/progress_api.py
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, HTTPException
from fastapi import Depends
from pydantic import BaseModel
import redis, json, uuid

r = redis.Redis.from_url("redis://localhost:6379/0", decode_responses=True)
router = APIRouter()

class EnqueueRequest(BaseModel):
    n_steps: int = 5
    # add payload fields as needed

class EnqueueResponse(BaseModel):
    job_id: str

@router.post("/workflow/run", response_model=EnqueueResponse)
def run_workflow(body: EnqueueRequest):
    job_id = uuid.uuid4().hex[:12]
    # RQ example:
    # from rq import Queue
    # from workers.tasks import long_task
    # q = Queue("default", connection=r)
    # q.enqueue(long_task, job_id, body.n_steps, job_id=job_id)
    # Seed progress so UI has immediate state:
    r.set(f"job:{job_id}:progress", json.dumps({
        "job_id": job_id, "status": "queued", "percent": 0, "message": "queued", "result": None, "error": None
    }))
    return {"job_id": job_id}

@router.get("/status/{job_id}")
def get_status(job_id: str):
    val = r.get(f"job:{job_id}:progress")
    if not val:
        raise HTTPException(404, "job not found")
    return json.loads(val)

@router.websocket("/ws/{job_id}")
async def ws_job(websocket: WebSocket, job_id: str):
    await websocket.accept()
    pubsub = r.pubsub()
    channel = f"job:{job_id}:updates"
    pubsub.subscribe(channel)
    # Send the current snapshot first (useful if the client connected late)
    snap = r.get(f"job:{job_id}:progress")
    if snap:
        await websocket.send_text(snap)
    try:
        for message in pubsub.listen():
            if message["type"] != "message":
                continue
            await websocket.send_text(message["data"])
    except WebSocketDisconnect:
        pubsub.close()
    finally:
        pubsub.close()
```

> **Note:** In production, prefer **async Redis** (e.g., `redis.asyncio`) or a broadcast layer (e.g., `Starlette Broadcast`, Redis Streams). The above is a minimal, readable pattern.

---

## 4) Frontend: Streamlit (polling)

```python
# streamlit_app.py
import time, requests, streamlit as st

API = "http://localhost:8000"

st.title("Job Runner (Polling)")
n_steps = st.slider("Steps", 1, 20, 5)
if st.button("Run job"):
    resp = requests.post(f"{API}/workflow/run", json={"n_steps": n_steps}).json()
    job_id = resp["job_id"]
    st.write(f"Job ID: `{job_id}`")
    prog = st.progress(0, text="queued")
    status_area = st.empty()

    while True:
        data = requests.get(f"{API}/status/{job_id}").json()
        pct = data.get("percent", 0)
        msg = f"{data['status']}: {data.get('message','')}"
        prog.progress(pct, text=msg)
        status_area.code(data, language="json")
        if data["status"] in ("finished", "failed", "canceled"):
            break
        time.sleep(1.0)

    if data["status"] == "finished":
        st.success("✅ Completed")
        st.json(data["result"])
    elif data["status"] == "failed":
        st.error(f"❌ Failed: {data['error']}")
```

> **Why polling first?** Streamlit’s built-in flow is request/response; polling is simplest and robust. You can still do WebSockets with community libs, but polling covers 95% of use-cases.

---

## 5) Frontend: React (polling)

```tsx
// src/JobPoller.tsx
import { useEffect, useState } from "react";

type Progress = {
  job_id: string;
  status: string;
  percent: number;
  message: string;
  result?: any;
  error?: any;
};

export default function JobPoller({ jobId }: { jobId: string }) {
  const [snap, setSnap] = useState<Progress | null>(null);

  useEffect(() => {
    let timer = setInterval(async () => {
      const res = await fetch(`http://localhost:8000/status/${jobId}`);
      if (res.ok) {
        const data = await res.json();
        setSnap(data);
        if (["finished", "failed", "canceled"].includes(data.status)) {
          clearInterval(timer);
          timer = null as any;
        }
      }
    }, 1000);

    return () => {
      if (timer) clearInterval(timer);
    };
  }, [jobId]);

  if (!snap) return <div>Loading…</div>;
  return (
    <div style={{ maxWidth: 480 }}>
      <div>Job: {snap.job_id}</div>
      <progress value={snap.percent} max={100} style={{ width: "100%" }} />
      <div>{snap.status}: {snap.message}</div>
      {snap.status === "finished" && <pre>{JSON.stringify(snap.result, null, 2)}</pre>}
      {snap.status === "failed" && <pre>{JSON.stringify(snap.error, null, 2)}</pre>}
    </div>
  );
}
```

---

## 6) Frontend: React (WebSocket live)

```tsx
// src/JobLive.tsx
import { useEffect, useState, useRef } from "react";

type Progress = {
  job_id: string; status: string; percent: number; message: string;
  result?: any; error?: any;
};

export default function JobLive({ jobId }: { jobId: string }) {
  const [snap, setSnap] = useState<Progress | null>(null);
  const wsRef = useRef<WebSocket | null>(null);

  useEffect(() => {
    const ws = new WebSocket(`ws://localhost:8000/ws/${jobId}`);
    wsRef.current = ws;

    ws.onmessage = (evt) => {
      try { setSnap(JSON.parse(evt.data)); }
      catch { /* ignore parse errors */ }
    };
    ws.onerror = () => { /* optionally fall back to polling */ };
    ws.onclose = () => { /* optionally try reconnect */ };

    return () => { ws.close(); };
  }, [jobId]);

  if (!snap) return <div>Connecting…</div>;
  return (
    <div style={{ maxWidth: 480 }}>
      <div>Job: {snap.job_id}</div>
      <progress value={snap.percent} max={100} style={{ width: "100%" }} />
      <div>{snap.status}: {snap.message}</div>
      {snap.status === "finished" && <pre>{JSON.stringify(snap.result, null, 2)}</pre>}
      {snap.status === "failed" && <pre>{JSON.stringify(snap.error, null, 2)}</pre>}
    </div>
  );
}
```

---

## 7) Display patterns & UX tips

* **Progress bar rules:**

  * Show both **percent** and **message** (users need context).
  * When `status=finished`, lock bar at 100 and show **result**.
  * When `status=failed`, color the bar or show a red banner with **error.detail**.
* **Idempotent UI:** if a page refreshes, fetch `/status/{job_id}` immediately to restore state.
* **Backoff:** if you must poll, use **1s** interval for active jobs; **3–5s** for long idles.
* **Resilience:** WS failures should fall back to polling automatically.
* **Security:** if jobs are user-scoped, require auth on `/status` and `/ws` and enforce **RBAC**.

---

## 8) Testing checklist

1. Enqueue a job → instantly GET `/status/{id}` returns `queued`.
2. While running → percent increases and WS sends updates.
3. On finish → `status=finished`, `result` present.
4. On exception → `status=failed`, `error` present.
5. Frontend refresh still shows the **last snapshot**.
6. Simulate WS drop → client continues via polling (if implemented).

---

## 9) Common pitfalls

* **Blocking WS loop** with sync Redis client. Prefer `redis.asyncio` (or move Pub/Sub to a thread/Task).
* **Not sending initial snapshot** over WS → clients connect in the middle and render blank.
* **Unbounded setInterval** in React → always `clearInterval` on unmount.
* **Leaking pubsub connections** on WS disconnect → close them in `finally`.

---

## 10) Where this fits in your course

* **Before:** Lesson 8 (status endpoint) & Lessons 11–14 (workflow orchestration, metadata).
* **After:** You can add **Lesson 16: Notifications (Email/SMS/Push)** using progress transitions as triggers.

---

### Mini-exercise

* Add a **pause/resume** button to your UI (use Lesson 13 endpoints) that toggles a `status` change and demonstrates instant WS reflection.
* Record historical progress to a SQL table (`job_progress_events`) for analytics (pairs well with Lesson 14).

---

**You now have end-to-end live status:** the worker writes snapshots, FastAPI serves both polling and push, and Streamlit/React render a clean, responsive progress bar with messages and results.

