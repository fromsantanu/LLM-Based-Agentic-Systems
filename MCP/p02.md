# Chapter 2. Fundamentals of MCP Servers

## Architecture of MCP (Model Context Protocol)

The **Model Context Protocol (MCP)** provides a standardized way for large language models (LLMs) and agentic systems to interact with external tools, data sources, and applications. Instead of relying on ad-hoc integrations, MCP introduces a **client–server architecture** that makes tool usage reliable, discoverable, and secure.

* **Client (LLM / Agent Framework):**
  Initiates requests for external resources or capabilities. This could be a LangChain agent, an n8n workflow, or any LLM-based application.

* **MCP Server:**
  Acts as a mediator between the client and external resources. It defines a set of **capabilities (APIs, tools, datasets, plugins)** in a structured format.

* **External Resource / System:**
  The underlying database, API, or service that the MCP server exposes.

### Key Features

* Standardized schema for **capabilities and responses**
* **Tool discovery** (the agent knows what functions are available)
* Secure communication with **access control**
* Support for **multiple clients** connecting to the same server

---

## Communication Flow: Client ↔ Server ↔ Agent

The interaction follows a predictable pipeline:

1. **Agent → Client**
   The agent running inside LangChain, n8n, or another framework determines it needs an external capability (e.g., query a database, fetch a file).

2. **Client → MCP Server**
   The client sends a request to the MCP server in MCP’s standard protocol.

3. **MCP Server → External System**
   The server translates the request into the format the target system understands (SQL query, REST API call, etc.).

4. **External System → MCP Server**
   The system returns results (JSON, text, binary data).

5. **MCP Server → Client**
   The server reformats the response into MCP-compliant data structures and sends it back.

6. **Client → Agent**
   The client delivers the structured result to the agent, which can reason over it and continue its workflow.

This flow ensures **separation of concerns**—the agent doesn’t need to know how the system works internally; it only needs to know the protocol.

---

## Installing and Running an MCP Server

Running an MCP server depends on the ecosystem you’re using, but the general steps are:

1. **Install prerequisites**

   * Python 3.9+ or Node.js (depending on implementation)
   * Package manager (pip, npm, etc.)

2. **Install an MCP server package**
   Example (Python-based):

   ```bash
   pip install mcp-server
   ```

   Example (Node.js-based):

   ```bash
   npm install -g mcp-server
   ```

3. **Configure the server**
   Define your server configuration file (`config.json` or `server.yaml`) with:

   * Exposed tools (e.g., database query, file search)
   * Authentication (API keys, OAuth)
   * Data format settings

4. **Start the server**

   ```bash
   mcp-server start --config ./config.json
   ```

5. **Connect from a client**
   A LangChain or n8n workflow can now register the MCP server endpoint as a tool provider.

---

## Supported Data Formats and Interfaces

MCP servers support multiple structured formats so that LLMs can **consume, reason, and act on responses** effectively.

* **JSON** – Standard for structured data exchange
* **Text / Markdown** – For natural language or rich-text output
* **CSV / TSV** – Tabular data (datasets, analytics)
* **Binary (Base64 encoded)** – For images, audio, or documents

### Interfaces

* **REST/HTTP** – Expose capabilities as REST APIs wrapped by MCP
* **WebSockets** – For streaming updates or event-driven data
* **gRPC** – High-performance, strongly typed interaction (future direction in some implementations)

By supporting these formats and interfaces, MCP servers can bridge diverse ecosystems: databases, cloud APIs, medical records, financial systems, or IoT devices.

---

