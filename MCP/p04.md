## Chapter 4. Connecting MCP Servers with Agents

Once your MCP (Model Context Protocol) server is running, the next step is to make it usable by an **agent** within an agentic AI system (e.g., LangChain, n8n, or a custom framework). This chapter explains how MCP servers are registered as tools, how requests and responses are passed between components, and how structured data flows across the pipeline.

---

### Registering MCP Servers as Tools for Agents

In agentic frameworks, external services (APIs, functions, or MCP servers) are usually wrapped as **tools**. A tool defines:

* **Name** – a unique identifier for the MCP server.
* **Description** – what the server can do (used in prompt selection).
* **Input schema** – structured definition of required inputs.
* **Output schema** – structured definition of expected responses.

Example (pseudo-code for LangChain):

```python
from my_mcp_client import MCPClient
from langchain.agents import Tool

mcp = MCPClient("http://localhost:8000")

query_tool = Tool(
    name="mcp_query",
    description="Query structured data from the MCP server",
    func=mcp.query
)
```

This makes the MCP server a callable tool for the agent.

---

### Defining Message Passing and Request/Response Cycles

MCP uses a **request/response cycle** where:

1. **Agent sends a query** → passes input to MCP server.
2. **MCP server processes request** → applies its logic, accesses data, or runs computations.
3. **MCP server returns response** → structured in JSON or other supported formats.
4. **Agent consumes response** → integrates into reasoning chain or outputs directly.

Message flow:

```
Agent → MCP (request) → MCP (processing) → MCP (response) → Agent
```

Key considerations:

* **Synchronous vs. asynchronous** – Some MCP servers return immediately, while others stream or require polling.
* **Error handling** – Agents should capture and interpret error codes, retries, or null responses.
* **Context awareness** – Agents may include metadata (e.g., session ID, conversation state).

---

### Handling Structured Data (JSON, Embeddings, Metadata)

MCP servers typically return structured outputs such as:

* **JSON** – e.g., `{ "result": "blood pressure: 120/80", "confidence": 0.95 }`
* **Embeddings** – numerical vectors for semantic search, clustering, or retrieval.
* **Metadata** – timestamps, source references, user IDs, etc.

Example response:

```json
{
  "query": "patient symptoms",
  "results": [
    {
      "diagnosis": "Viral fever",
      "confidence": 0.87,
      "recommended_tests": ["CBC", "CRP"]
    }
  ],
  "metadata": {
    "server": "healthcare_mcp",
    "timestamp": "2025-09-19T12:00:00Z"
  }
}
```

Agents should **parse and validate** these structures before incorporating them into reasoning steps.

---

### Examples: Query → MCP → Agent → Output

#### Example 1: Text Query

```
User: "What is the patient’s blood pressure trend over the last week?"
↓
Agent → calls MCP (request: {"patient_id": 123, "metric": "blood_pressure"})
↓
MCP Server → queries EHR database → returns structured JSON
↓
Agent → formats into human-readable response:
"The patient’s blood pressure has averaged 118/76 over the last 7 days."
```

#### Example 2: Embedding Search

```
User: "Find related research on lung cancer treatment."
↓
Agent → calls MCP with embedding vector
↓
MCP Server → performs vector similarity search in medical database
↓
Response: Top 5 relevant papers with metadata
↓
Agent → summarizes into plain text for user.
```

---

✅ **Key Takeaways**

* MCP servers are wrapped as **tools** for agents.
* Communication follows a **request/response cycle**.
* Structured data (JSON, embeddings, metadata) must be **parsed and validated**.
* Clear mapping between **user intent → MCP request → agent reasoning → final output** is crucial.

---

