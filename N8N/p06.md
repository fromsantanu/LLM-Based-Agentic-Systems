# **Chapter 6 - Creating Multi-Step Agents**

Agentic AI systems often need to perform more than a single task. Instead of just answering a question or running one tool, they may need to **chain tasks together**, make decisions based on intermediate results, and decide the best next step in a workflow. In N8N, this is made possible by **multi-step agents**—where multiple nodes are linked, conditional routing is applied, and reasoning patterns like **ReAct (Reason + Act)** are embedded.

---

## Chaining Tasks Across Nodes

In N8N, each node performs a single function: querying a database, calling an API, generating text with an LLM, or running a Python script. To create a multi-step agent:

1. **Define the stages** of your task.

   * Example: “Summarize a research paper → Extract key findings → Generate a presentation.”
2. **Map each stage to a node** in N8N.

   * LLM node → Text Splitter node → OpenAI Embeddings node → Markdown/Presentation generator node.
3. **Connect nodes sequentially** to create a pipeline.

   * The output of one node flows as the input of the next.

This approach is like building a chain in LangChain (`SequentialChain`), but inside N8N’s visual interface.

---

## Routing Workflows with Conditional Logic

Not all workflows follow a straight line. Multi-step agents often need to branch:

* **Decision-making nodes** in N8N allow routing based on:

  * If/Else conditions
  * Switch-case routing
  * Boolean checks
* **Examples of conditional routing**:

  * A healthcare chatbot checks if symptoms are mild or severe → mild symptoms trigger lifestyle advice, severe symptoms trigger “doctor consultation” workflow.
  * A customer service bot routes complaints about billing to a finance workflow, and product issues to a technical workflow.

This conditional routing makes agents **adaptive** instead of rigid.

---

## Building a ReAct (Reason + Act) Style Agent in N8N

The **ReAct pattern** is one of the most powerful approaches for agent design. It combines two key steps:

1. **Reasoning**: The agent thinks step-by-step, generating a plan.
2. **Acting**: The agent executes actions (using tools, APIs, or knowledge bases).

### How to Implement ReAct in N8N:

1. **LLM Node (Reasoning Step)**

   * Prompt the model to generate a thought process in structured JSON (e.g., `{ "thought": "...", "action": "...", "input": "..." }`).
   * Example: *“I need to find the weather before I recommend an outdoor activity.”*

2. **Router Node (Acting Step)**

   * Based on the LLM’s output, route the workflow to the correct tool:

     * If action = “SearchWeather” → call Weather API node.
     * If action = “SearchWiki” → call Wikipedia node.
     * If action = “Summarize” → pass to LLM node.

3. **Loop Back (Reflection Step)**

   * Feed the tool’s result back into the LLM node for further reasoning.
   * Example: Weather API result → LLM decides if it’s suitable for outdoor activity.

4. **Final Output Node**

   * After reasoning and acting cycles, generate a final user-friendly response.

This **Reason → Act → Reflect loop** allows the agent to dynamically select tools, perform tasks, and refine answers.

---

## Example Use Case: Travel Assistant Agent

* **User Input**: “Plan my weekend trip to Oxford based on weather and train availability.”
* **Workflow**:

  1. LLM (Reason) → decide: check weather + train API.
  2. Weather API Node → return sunny forecast.
  3. Train API Node → return available train times.
  4. LLM (Reflect + Summarize) → generate itinerary.

The agent doesn’t follow a fixed script; instead, it reasons and acts based on live data.

---

✅ **Key Takeaway**: Multi-step agents in N8N combine sequential chaining, conditional routing, and the ReAct reasoning loop. This makes them flexible, adaptive, and capable of solving real-world problems beyond simple one-shot LLM calls.

---

