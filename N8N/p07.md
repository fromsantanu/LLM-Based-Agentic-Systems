# **Chapter 7 - Multi-Agent Systems in N8N**

Multi-agent systems (MAS) extend the power of individual agents by allowing multiple autonomous agents to collaborate toward a shared objective. Within **N8N**, you can design, orchestrate, and monitor these systems using workflows, queues, and conditional routing. This creates a flexible environment for distributing work, delegating responsibilities, and ensuring that agents can operate in parallel without losing coordination.

---

## Supervisor → Worker Agent Design

The **Supervisor → Worker** pattern is one of the most common designs in multi-agent systems.

* **Supervisor Agent**

  * Acts as the coordinator.
  * Breaks down complex tasks into smaller subtasks.
  * Distributes subtasks to worker agents.
  * Collects and integrates results from workers.

* **Worker Agents**

  * Specialized in specific domains or tasks.
  * Operate independently, taking subtasks from the supervisor.
  * Return results asynchronously (e.g., to a queue or database).

**In N8N**:

* The **Supervisor** can be a workflow that receives the user’s input and routes it to multiple workers.
* **Workers** can be independent workflows listening for messages in a queue (like RabbitMQ, Redis, or N8N’s own workflow triggers).
* Communication between supervisor and workers happens via **Webhook nodes, message queues, or database writes/reads**.

---

## Orchestrating Agents with Queues

Queues are crucial for handling multiple workers and ensuring reliability.

* **Why Queues?**

  * Allow tasks to be processed asynchronously.
  * Ensure fault tolerance—failed tasks can be retried or reassigned.
  * Scale easily—add more workers to handle higher loads.

* **Tools in N8N:**

  * **RabbitMQ / Redis / Kafka nodes** for robust distributed processing.
  * **N8N’s Workflow Trigger node** to activate workers when new tasks are added.
  * **Rate Limiting & Error Handling** features to avoid overloading APIs or agents.

**Flow Example**:

1. Supervisor workflow places subtasks into a **RabbitMQ queue**.
2. Worker workflows are subscribed to the queue.
3. Each worker processes tasks independently and sends results back.
4. Supervisor collects results and finalizes the response.

---

## Case Study: Research Agent + Summarizer + Reporter

Imagine a research pipeline where you want to **collect information, summarize it, and generate a final report**.

### Step 1: Supervisor Workflow

* Input: Topic = “AI in Healthcare”
* Tasks:

  1. Research Agent → Find top 5 articles on the topic.
  2. Summarizer Agent → Create concise summaries of each article.
  3. Reporter Agent → Compile the summaries into a structured report.

### Step 2: Worker Workflows

* **Research Agent Workflow**:

  * Uses **Web Search API / SerpAPI node** to fetch article links.
  * Extracts content with a **Document Loader or Web Scraper node**.
  * Pushes results to the queue.

* **Summarizer Agent Workflow**:

  * Reads article content from the queue.
  * Sends it to an **LLM node (e.g., OpenAI, Hugging Face)** for summarization.
  * Returns summaries into another queue.

* **Reporter Agent Workflow**:

  * Collects summaries.
  * Structures them into a final report (Markdown, PDF, or HTML).
  * Sends the output via **Email node, Slack node, or stores in a Database**.

### Step 3: Orchestration

* The **Supervisor** ensures tasks flow in order: Research → Summarize → Report.
* Queues handle load balancing and retries if one agent fails.
* The final report is delivered automatically.

---

✅ **Key Benefits of Multi-Agent Systems in N8N**

* Scalability: Add more workers for higher throughput.
* Specialization: Each agent focuses on its domain expertise.
* Reliability: Queues ensure retries and smooth task handling.
* Flexibility: New agents (e.g., “Translator Agent”) can be added easily without redesigning the entire pipeline.

---

