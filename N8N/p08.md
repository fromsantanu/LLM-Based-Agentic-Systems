# **Chapter 8 - Tool Integration for Agents**

Agentic AI becomes powerful when agents can use tools to interact with the outside worldâ€”retrieving live data, executing calculations, or triggering workflows. In **N8N**, tool integration is straightforward: you can connect APIs, create custom code blocks, and manage errors systematically. This chapter explores three major aspects: **API usage**, **custom function nodes**, and **error handling with rate limits**.

---

## Using APIs Inside Workflows

External APIs let agents pull real-time data and act beyond static knowledge. With N8Nâ€™s native HTTP Request node, you can connect to almost any REST API.

### Examples of API integrations:

* **Weather APIs** (e.g., OpenWeatherMap): Provide real-time weather updates for a travel assistant agent.
* **Finance APIs** (e.g., Alpha Vantage, Yahoo Finance): Fetch stock prices, currency rates, or market summaries.
* **Healthcare APIs** (e.g., FHIR servers, drug information services): Allow medical assistant agents to retrieve clinical data or treatment guidelines.

### Steps:

1. **Set up API keys** securely (using N8Nâ€™s credentials manager).
2. **Build the request**: configure endpoint, method (GET/POST), and parameters.
3. **Parse the response**: use JSON parsing to structure results into agent-friendly formats.
4. **Pass the output** downstream to the LLM or other agents.

> ðŸ’¡ Best practice: Always transform raw API responses into a clean JSON schema before passing them to an LLM, so prompts remain structured.

---

## Custom Python/JavaScript Function Nodes

Sometimes built-in integrations arenâ€™t enough. N8N provides **Function** and **Function Item** nodes (JavaScript) and the **Code Node** (Python in sandbox). These let you build mini-tools directly in your workflows.

### Use cases:

* **Preprocessing API responses**: e.g., normalizing units, filtering fields.
* **Math/logic computations**: e.g., forecasting sales from historical data.
* **Custom connectors**: when an API doesnâ€™t have a ready-made N8N node, you can write your own fetch logic.

### Example (JavaScript Function node):

```javascript
// Normalize weather API output
return items.map(item => {
  const tempC = item.json.main.temp - 273.15;
  return {
    json: {
      city: item.json.name,
      temperature: tempC.toFixed(2),
      condition: item.json.weather[0].description
    }
  }
});
```

### Example (Python Code node):

```python
import statistics

temps = [item['json']['temperature'] for item in items]
avg_temp = statistics.mean(temps)

output = [{'json': {'average_temperature': avg_temp}}]
```

---

## Handling API Limits and Errors

APIs often impose **rate limits** or return errors when overloaded. Agents must be resilient to these issues.

### Common strategies in N8N:

1. **Error Workflow Triggers**

   * Configure a secondary workflow that catches failed executions and retries them.
2. **Rate Limiting & Throttling**

   * Use the **Interval node** or **Wait node** to pace requests.
   * Batch queries instead of sending one per item when possible.
3. **Retries with Backoff**

   * Configure the HTTP Request node to retry failed calls with exponential backoff.
4. **Graceful Degradation**

   * Provide fallback responses:

     * If a finance API fails, show cached prices.
     * If weather API times out, respond with a generic forecast.

### Example Retry Logic:

* Workflow: Agent â†’ HTTP Request â†’ If Error â†’ Wait 10s â†’ Retry
* Limit retries to 3 attempts before escalating to human intervention.

---

## Key Takeaways

* **APIs** extend agent capabilities with live, domain-specific data.
* **Custom code nodes** (Python/JS) let you build tailored tools inside workflows.
* **Error handling & rate limits** ensure reliability and prevent workflow breakdowns.

With robust tool integration, agents in N8N move from being **chatbots** to **actionable digital workers**, capable of executing complex real-world tasks.

---

