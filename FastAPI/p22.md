# Chapter 22: Deployment

Developing and testing FastAPI apps locally is only the first step. To make them accessible to users, you‚Äôll need to deploy them. In this chapter, we‚Äôll explore multiple deployment strategies, from containerization with Docker to cloud platforms and CI/CD pipelines.

---

## üöÄ 22.1 Deploying with Docker & Docker Compose

### Why Docker?

* **Portability**: ‚ÄúIt works on my machine‚Äù is no longer an issue.
* **Consistency**: Same environment across dev, staging, and production.
* **Scalability**: Containers can be replicated and scaled easily.

### Dockerfile for FastAPI

```dockerfile
# Use an official Python runtime
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy project files
COPY . .

# Run with Uvicorn
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### docker-compose.yml

With **PostgreSQL** as a database:

```yaml
version: '3.9'

services:
  web:
    build: .
    container_name: fastapi_app
    ports:
      - "8000:8000"
    depends_on:
      - db

  db:
    image: postgres:14
    container_name: fastapi_db
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: fastapidb
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

Run:

```bash
docker-compose up --build
```

Your FastAPI app is now running inside a container with PostgreSQL.

---

## ‚òÅÔ∏è 22.2 Deploying on Cloud Platforms (AWS/GCP/Azure)

### AWS

* Use **Elastic Beanstalk** or **ECS/Fargate** for container deployment.
* Store secrets in **AWS Secrets Manager**.
* Use **RDS (PostgreSQL)** as your database.

### GCP

* Use **Cloud Run** for serverless container execution.
* Store container images in **Artifact Registry**.
* Use **Cloud SQL (PostgreSQL)** for the database.

### Azure

* Use **Azure App Service** for containerized web apps.
* Store secrets in **Azure Key Vault**.
* Use **Azure Database for PostgreSQL**.

‚ö° Tip: All providers support **Kubernetes (K8s)** for more complex deployments.

---

## üîÑ 22.3 CI/CD with GitHub Actions

CI/CD (Continuous Integration / Continuous Deployment) automates:

* Running tests on every push.
* Building Docker images.
* Deploying automatically to your server/cloud.

### Example GitHub Actions Workflow

```yaml
name: CI/CD Pipeline

on:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: pip install -r requirements.txt

    - name: Run tests
      run: pytest

    - name: Build Docker image
      run: docker build -t my-fastapi-app .

    - name: Push to DockerHub
      run: |
        echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
        docker tag my-fastapi-app mydockerhub/fastapi-app:latest
        docker push mydockerhub/fastapi-app:latest
```

With this pipeline, every commit to `main` builds and pushes a new image.

---

## üõ†Ô∏è 22.4 Example: FastAPI + PostgreSQL + Nginx Deployment

We‚Äôll build a **production-grade setup**:

1. **FastAPI App** (Uvicorn workers).
2. **PostgreSQL Database**.
3. **Nginx** as a reverse proxy.

### docker-compose.prod.yml

```yaml
version: '3.9'

services:
  web:
    build: .
    container_name: fastapi_app
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --workers 4
    depends_on:
      - db
    expose:
      - "8000"

  db:
    image: postgres:14
    container_name: fastapi_db
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: fastapidb
    volumes:
      - postgres_data:/var/lib/postgresql/data

  nginx:
    image: nginx:latest
    container_name: fastapi_nginx
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - web

volumes:
  postgres_data:
```

### nginx.conf

```nginx
events {}

http {
    upstream fastapi {
        server web:8000;
    }

    server {
        listen 80;

        location / {
            proxy_pass http://fastapi;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
```

Run:

```bash
docker-compose -f docker-compose.prod.yml up --build -d
```

Your FastAPI app is now production-ready with:

* PostgreSQL for persistence.
* Nginx for load balancing and static file serving.
* Scalable containers.

---

‚úÖ **Summary**

* Use **Docker + Docker Compose** for local and small-scale deployments.
* Use **AWS/GCP/Azure** for scalable production.
* Automate with **GitHub Actions** for CI/CD.
* Add **Nginx** for production-grade reverse proxying.

---

