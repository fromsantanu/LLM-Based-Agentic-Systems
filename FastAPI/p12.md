# Chapter 12 â€” Testing

This chapter makes your FastAPI apps *provably correct* with a clean testing setup. Youâ€™ll learn how to write unit and integration tests with `pytest`, exercise routes via `TestClient`, and mock your database and other dependencies. Weâ€™ll finish with a compact example that tests a CRUD API end-to-end.

---

## 12.1 Why test FastAPI apps?

* Catch regressions early (before deploys).
* Document expected behavior as executable specs.
* Enable confident refactoring.
* Make CI/CD meaningful (green = shippable).

---

## 12.2 Project skeleton (testing-friendly)

```
fastapi-tutorial/
â”œâ”€ app/
â”‚  â”œâ”€ main.py
â”‚  â”œâ”€ deps.py
â”‚  â”œâ”€ db.py
â”‚  â”œâ”€ models.py
â”‚  â”œâ”€ schemas.py
â”‚  â””â”€ routers/
â”‚     â””â”€ items.py
â””â”€ tests/
   â”œâ”€ conftest.py
   â””â”€ test_items.py
```

---

## 12.3 Installing testing tools

```bash
pip install pytest httpx pytest-asyncio anyio
# If youâ€™ll use TestClient (sync) only: httpx/anyio are optional.
```

> **When to choose which client?**
>
> * **`fastapi.testclient.TestClient`** (sync): simple, great for most route tests.
> * **`httpx.AsyncClient` with `asgi-lifespan`**: needed to test **async** flows and lifespan events (`startup`/`shutdown`).

---

## 12.4 Minimal app weâ€™ll test (CRUD: Items)

### `app/db.py`

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, DeclarativeBase

SQLALCHEMY_DATABASE_URL = "sqlite:///./app.db"

engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

class Base(DeclarativeBase):
    pass

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### `app/models.py`

```python
from sqlalchemy import String, Integer
from sqlalchemy.orm import Mapped, mapped_column
from .db import Base

class Item(Base):
    __tablename__ = "items"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    name: Mapped[str] = mapped_column(String(100), index=True)
    description: Mapped[str] = mapped_column(String(255), default="")
```

### `app/schemas.py`

```python
from pydantic import BaseModel, Field

class ItemCreate(BaseModel):
    name: str = Field(min_length=1, max_length=100)
    description: str = Field(default="", max_length=255)

class ItemRead(BaseModel):
    id: int
    name: str
    description: str

    class Config:
        from_attributes = True  # pydantic v2: map from ORM
```

### `app/routers/items.py`

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from ..db import get_db
from .. import models, schemas

router = APIRouter(prefix="/items", tags=["items"])

@router.post("/", response_model=schemas.ItemRead, status_code=status.HTTP_201_CREATED)
def create_item(payload: schemas.ItemCreate, db: Session = Depends(get_db)):
    item = models.Item(name=payload.name, description=payload.description)
    db.add(item)
    db.commit()
    db.refresh(item)
    return item

@router.get("/{item_id}", response_model=schemas.ItemRead)
def get_item(item_id: int, db: Session = Depends(get_db)):
    item = db.get(models.Item, item_id)
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    return item

@router.put("/{item_id}", response_model=schemas.ItemRead)
def update_item(item_id: int, payload: schemas.ItemCreate, db: Session = Depends(get_db)):
    item = db.get(models.Item, item_id)
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    item.name = payload.name
    item.description = payload.description
    db.commit()
    db.refresh(item)
    return item

@router.delete("/{item_id}", status_code=204)
def delete_item(item_id: int, db: Session = Depends(get_db)):
    item = db.get(models.Item, item_id)
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    db.delete(item)
    db.commit()
    return None
```

### `app/main.py`

```python
from fastapi import FastAPI
from .db import Base, engine
from .routers import items

Base.metadata.create_all(bind=engine)
app = FastAPI(title="Items API")
app.include_router(items.router)
```

---

## 12.5 Pytest essentials

* **Test file names**: `test_*.py` or `*_test.py`
* **Test functions**: start with `test_`
* **Fixtures**: reusable setup/teardown (DBs, clients)
* **Marks**: `@pytest.mark.anyio` for async tests; custom marks to group suites

---

## 12.6 Overriding dependencies (DB mocking)

For *deterministic* tests, use an **in-memory SQLite** engine and **override** `get_db`:

### `tests/conftest.py`

```python
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

from app.main import app
from app.db import Base
from app import db as app_db  # to access get_db symbol

# Create an isolated in-memory DB per test session
TEST_DB_URL = "sqlite+pysqlite:///:memory:"
engine = create_engine(TEST_DB_URL, connect_args={"check_same_thread": False})
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

@pytest.fixture(scope="session", autouse=True)
def create_test_db():
    Base.metadata.create_all(bind=engine)
    yield
    Base.metadata.drop_all(bind=engine)

def override_get_db():
    db = TestingSessionLocal()
    try:
        yield db
    finally:
        db.close()

# Apply the override once for all tests
app.dependency_overrides[app_db.get_db] = override_get_db

@pytest.fixture()
def client():
    return TestClient(app)
```

> **Why override?** It swaps the production DB with a throwaway test DB without changing app code.

---

## 12.7 Unit tests for CRUD routes

### `tests/test_items.py`

```python
def test_create_item(client):
    payload = {"name": "Stethoscope", "description": "Standard adult"}
    r = client.post("/items/", json=payload)
    assert r.status_code == 201
    data = r.json()
    assert data["id"] > 0
    assert data["name"] == "Stethoscope"
    assert data["description"] == "Standard adult"

def test_get_item_found(client):
    # arrange
    created = client.post("/items/", json={"name": "Thermometer", "description": "Digital"}).json()
    # act
    r = client.get(f"/items/{created['id']}")
    # assert
    assert r.status_code == 200
    assert r.json()["name"] == "Thermometer"

def test_get_item_not_found(client):
    r = client.get("/items/99999")
    assert r.status_code == 404
    assert r.json()["detail"] == "Item not found"

def test_update_item(client):
    created = client.post("/items/", json={"name": "BP Cuff", "description": "Adult"}).json()
    r = client.put(f"/items/{created['id']}", json={"name": "BP Cuff", "description": "Pediatric"})
    assert r.status_code == 200
    assert r.json()["description"] == "Pediatric"

def test_delete_item(client):
    created = client.post("/items/", json={"name": "Pulse Ox", "description": ""}).json()
    r = client.delete(f"/items/{created['id']}")
    assert r.status_code == 204
    # Verify gone
    r2 = client.get(f"/items/{created['id']}")
    assert r2.status_code == 404
```

Run:

```bash
pytest -q
```

---

## 12.8 Testing async apps (optional)

If you rely on `lifespan` events or async flows, use `httpx.AsyncClient`:

```python
import pytest, anyio
from httpx import AsyncClient
from app.main import app

@pytest.mark.anyio
async def test_healthcheck_async():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        r = await ac.get("/items/999")
        assert r.status_code in (404, 200)
```

---

## 12.9 Mocking other dependencies (emails, 3rd-party APIs)

Use `monkeypatch` to replace a function during tests.

```python
# Suppose in app/deps.py you have:
# def send_email(to:str, subject:str, body:str) -> bool: ...

def test_route_that_sends_email(client, monkeypatch):
    calls = {}
    def fake_send_email(to, subject, body):
        calls["to"] = to; calls["subject"] = subject; calls["body"] = body
        return True

    from app import deps
    monkeypatch.setattr(deps, "send_email", fake_send_email)

    r = client.post("/items/", json={"name": "ECG", "description": "12-lead"})
    assert r.status_code == 201
    assert calls["subject"].lower().find("new item") != -1  # assert side effect
```

> Prefer monkeypatching *module attributes* (not imports inside functions). If your function does `from app.deps import send_email` *inside* the route, patch *that* import site.

---

## 12.10 Factories & fixtures (nice to have)

For larger suites, create data factories:

```python
import itertools
import pytest

_counter = itertools.count(1)

@pytest.fixture
def item_payload():
    i = next(_counter)
    return {"name": f"Item-{i}", "description": f"Desc-{i}"}
```

Use in tests:

```python
def test_create_many(client, item_payload):
    r = client.post("/items/", json=item_payload)
    assert r.status_code == 201
```

---

## 12.11 Validations & error paths

Add tests for:

* Body validation errors (`422 Unprocessable Entity`)
* Auth failures (`401/403`)
* Conflict/uniqueness (`409`)
* Pagination/filtering correctness

Example validation test:

```python
def test_create_item_validation_error(client):
    r = client.post("/items/", json={"name": "", "description": "x"})
    assert r.status_code == 422
```

---

## 12.12 Coverage & CI (quick start)

Install coverage and add a CI job.

```bash
pip install coverage
coverage run -m pytest && coverage report -m
```

**GitHub Actions (`.github/workflows/tests.yml`)**

```yaml
name: tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: '3.11' }
      - run: pip install -r requirements.txt
      - run: pip install pytest httpx pytest-asyncio anyio coverage
      - run: coverage run -m pytest -q
      - run: coverage report -m
```

---

## 12.13 Troubleshooting

* **`sqlite3.ProgrammingError: SQLite objects created in a threadâ€¦`**
  Ensure `connect_args={"check_same_thread": False}` and use a single, in-process engine.

* **DB state leaking between tests**
  Use an **in-memory** database and recreate schema per session/test, or run each test in a transaction with rollback in a per-test fixture.

* **Dependency override not applied**
  Override the **exact** symbol used in `Depends(...)`. If your route imports `from app.db import get_db`, you must override `app.db.get_db`, not a different alias.

---

## 12.14 What to test (a practical checklist)

* âœ… 2xx happy paths (create, read, update, delete)
* âœ… 4xx/5xx edge cases (not found, validation)
* âœ… Side effects (DB writes, emails, external calls â†’ **mock**)
* âœ… Security (auth required, role checks)
* âœ… Performance constraints (optional; e.g., N â‰¤ 100ms)
* âœ… Serialization contracts (response models)

---

## 12.15 Takeaways

* Use `TestClient` (sync) or `httpx.AsyncClient` (async) to exercise routes.
* Override `get_db` to isolate tests from prod data.
* Rely on `pytest` fixtures for clean setup/teardown.
* Mock non-deterministic dependencies (network, time, randomness).
* Keep tests small, isolated, and fastâ€”so you actually run them often.

---

### ðŸŽ¯ Your turn

1. Drop the chapterâ€™s files into your project,
2. run `pytest -q`, and
3. add one more test for a *list/paginate* endpointâ€”then watch your confidence grow with every green checkmark.

