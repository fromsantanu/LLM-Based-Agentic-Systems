# Chapter 13: Asynchronous Programming

One of the key strengths of **FastAPI** is its native support for **asynchronous programming** with Pythonâ€™s `asyncio`. This allows you to build highly concurrent applications that can handle many requests without blocking.

---

## 1. Synchronous vs Asynchronous Routes

* **Synchronous route**: Runs in a standard blocking way. Each request waits for the function to finish before returning a response.
* **Asynchronous route**: Declared with `async def`, allowing the server to handle multiple requests concurrently while waiting for I/O (database, API calls, etc.).

```python
from fastapi import FastAPI
import time
import asyncio

app = FastAPI()

# Synchronous route
@app.get("/sync")
def sync_endpoint():
    time.sleep(3)  # Blocking sleep
    return {"message": "Finished sync after 3 seconds"}

# Asynchronous route
@app.get("/async")
async def async_endpoint():
    await asyncio.sleep(3)  # Non-blocking sleep
    return {"message": "Finished async after 3 seconds"}
```

ðŸ‘‰ If you hit `/sync`, other requests must wait for 3 seconds.
ðŸ‘‰ If you hit `/async`, other requests can still be served while this one is waiting.

---

## 2. Async Database Queries

Many modern database drivers support async operations. Example with **SQLAlchemy Async**:

```python
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker
from fastapi import Depends

DATABASE_URL = "sqlite+aiosqlite:///./test.db"

engine = create_async_engine(DATABASE_URL, echo=True)
SessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def get_db():
    async with SessionLocal() as session:
        yield session

@app.get("/users")
async def get_users(db: AsyncSession = Depends(get_db)):
    result = await db.execute("SELECT * FROM users")
    users = result.fetchall()
    return {"users": [dict(row) for row in users]}
```

ðŸ’¡ Using `await` ensures non-blocking database queries.

---

## 3. Running Blocking Tasks in Threads

Some libraries (e.g., image processing, ML models) are not async-compatible. FastAPI lets you run them in a separate thread to avoid blocking.

```python
import time
from fastapi import BackgroundTasks
from fastapi.concurrency import run_in_threadpool

def blocking_task(x: int):
    time.sleep(5)  # Heavy computation
    return x * x

@app.get("/compute/{x}")
async def compute(x: int):
    result = await run_in_threadpool(blocking_task, x)
    return {"result": result}
```

Here, the blocking function is executed in a **thread pool**, freeing up the main event loop.

---

## 4. Example: Fetching Data from External API Asynchronously

Imagine fetching data from multiple external APIs. With async, you can do it concurrently.

```python
import httpx

@app.get("/fetch-data")
async def fetch_data():
    async with httpx.AsyncClient() as client:
        r1, r2 = await asyncio.gather(
            client.get("https://jsonplaceholder.typicode.com/posts/1"),
            client.get("https://jsonplaceholder.typicode.com/posts/2")
        )
    return {
        "post1": r1.json(),
        "post2": r2.json()
    }
```

* `httpx.AsyncClient` allows non-blocking HTTP requests.
* `asyncio.gather()` runs both requests **concurrently**, improving performance.

---

âœ… **Summary of this chapter**:

* Use `async def` for routes to enable concurrency.
* Prefer async-supported libraries (databases, HTTP clients).
* Run blocking code safely in threads with `run_in_threadpool`.
* Async API calls can significantly reduce response time.

---
