# Chapter 11 — Error Handling

## Why error handling matters in FastAPI

Great error handling turns confusing crashes into clear, actionable responses. In FastAPI, you’ll typically combine three layers:

1. **Raise** an exception as close as possible to the cause (e.g., invalid ID).
2. **Handle** specific exceptions with **custom exception handlers** for clean JSON and telemetry.
3. **Guard** the whole app with **global error-handling middleware** to catch anything unexpected.

---

## 11.1 Raising `HTTPException`

Use `HTTPException` for HTTP-friendly errors (status code + detail).

```python
from fastapi import FastAPI, HTTPException

app = FastAPI()

FAKE_DB = {1: {"id": 1, "name": "Aspirin"}}

@app.get("/items/{item_id}")
def read_item(item_id: int):
    item = FAKE_DB.get(item_id)
    if not item:
        # 404 with JSON: {"detail": "Item not found"}
        raise HTTPException(status_code=404, detail="Item not found")
    return item

@app.get("/restricted")
def restricted():
    # Add headers to instruct clients
    raise HTTPException(
        status_code=403,
        detail="You do not have access to this resource.",
        headers={"X-Reason": "PolicyBlock"},
    )
```

**Tips**

* Prefer specific status codes (400, 401, 403, 404, 409, 422, 429, 500).
* Use `headers` for extra context (e.g., retry hints).

---

## 11.2 Handling validation errors (`RequestValidationError`)

FastAPI automatically validates request bodies, query, path, and headers with Pydantic. When validation fails, it raises `RequestValidationError` (422 Unprocessable Entity by default). You can override the response format:

```python
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse
from starlette.requests import Request

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    # Flatten or reformat the default payload
    return JSONResponse(
        status_code=422,
        content={
            "error": {
                "type": "validation_error",
                "message": "Invalid request.",
                "details": exc.errors(),  # keep structured errors
                "path": str(request.url),
            }
        },
    )
```

---

## 11.3 Creating your own domain exceptions

Define lightweight exception classes for your business logic and map them to HTTP responses.

```python
class InventoryEmptyError(Exception):
    def __init__(self, item_id: int):
        self.item_id = item_id

@app.get("/buy/{item_id}")
def buy_item(item_id: int, qty: int = 1):
    stock = 0  # pretend we computed this
    if stock < qty:
        raise InventoryEmptyError(item_id=item_id)
    return {"ok": True}
```

Now add a **custom exception handler**:

```python
from fastapi import status

@app.exception_handler(InventoryEmptyError)
async def inventory_empty_handler(request: Request, exc: InventoryEmptyError):
    return JSONResponse(
        status_code=status.HTTP_409_CONFLICT,
        content={
            "error": {
                "type": "inventory_empty",
                "message": f"Item {exc.item_id} is out of stock.",
            }
        },
    )
```

---

## 11.4 Custom handlers for `HTTPException`

You can also customize `HTTPException` globally (e.g., add tracking IDs).

```python
from starlette.exceptions import HTTPException as StarletteHTTPException
import uuid

@app.exception_handler(StarletteHTTPException)
async def http_exception_handler(request: Request, exc: StarletteHTTPException):
    tracking_id = str(uuid.uuid4())
    # log here if you like
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": {
                "type": "http_error",
                "message": exc.detail,
                "tracking_id": tracking_id,
            }
        },
        headers=exc.headers or None,
    )
```

> Note: FastAPI re-exports `HTTPException`, but Starlette’s `HTTPException` is what actually bubbles through handlers. Using `StarletteHTTPException` in the handler is a common pattern.

---

## 11.5 Global error-handling middleware (catch-all)

Middleware wraps every request and can intercept *any* unhandled exception—perfect for logging and returning a standardized 500 response.

```python
from starlette.middleware.base import BaseHTTPMiddleware
import traceback
import logging

logger = logging.getLogger("uvicorn.error")

class GlobalErrorMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        try:
            response = await call_next(request)
            return response
        except Exception as ex:
            # Log a detailed traceback for ops
            logger.exception("Unhandled error: %s", ex)
            return JSONResponse(
                status_code=500,
                content={
                    "error": {
                        "type": "internal_server_error",
                        "message": "Something went wrong. Please try again later.",
                    }
                },
            )

app.add_middleware(GlobalErrorMiddleware)
```

**Best practices**

* **Log full tracebacks** server-side; keep client messages clear but generic.
* **Never** leak secrets, SQL, or stack traces to clients in production.
* Keep a **tracking/request ID** in logs and responses to correlate incidents.

---

## 11.6 Structured error model (recommended)

Define a consistent shape for all error responses.

```python
from pydantic import BaseModel
from typing import Any, List, Optional

class ErrorDetail(BaseModel):
    loc: Optional[List[str]] = None
    msg: str
    type: str

class ErrorResponse(BaseModel):
    error: dict

# Example response_model usage (for docs)
@app.get("/always-error", response_model=ErrorResponse, responses={400: {"model": ErrorResponse}})
def always_error():
    raise HTTPException(status_code=400, detail="Always bad")
```

---

## 11.7 Example — Custom JSON response for **404** errors

Here’s a minimal, copy-paste example that **overrides only 404** to a neat JSON format:

```python
from fastapi import FastAPI
from fastapi.responses import JSONResponse
from starlette.requests import Request
from starlette.exceptions import HTTPException as StarletteHTTPException
from starlette.status import HTTP_404_NOT_FOUND

app = FastAPI(title="Custom 404 Example")

@app.get("/books/{book_id}")
def get_book(book_id: int):
    # simulate not found
    raise StarletteHTTPException(status_code=404, detail=f"Book {book_id} not found")

@app.exception_handler(StarletteHTTPException)
async def custom_http_handler(request: Request, exc: StarletteHTTPException):
    # Only customize 404; pass through others
    if exc.status_code == HTTP_404_NOT_FOUND:
        return JSONResponse(
            status_code=404,
            content={
                "error": {
                    "type": "not_found",
                    "message": str(exc.detail) if exc.detail else "Resource not found",
                    "resource": str(request.url.path),
                }
            },
        )
    # fallback to default shape for other http errors
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail},
        headers=exc.headers or None,
    )
```

**Try it**

```bash
# Not found (custom JSON)
curl -i http://127.0.0.1:8000/books/999

# A route that doesn't exist at all (also 404, custom JSON)
curl -i http://127.0.0.1:8000/nowhere
```

---

## 11.8 Returning problem+json (optional but nice)

If your consumers prefer RFC-7807 “problem+json”:

```python
PROBLEM_JSON = "application/problem+json"

@app.exception_handler(StarletteHTTPException)
async def problem_http_handler(request: Request, exc: StarletteHTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        media_type=PROBLEM_JSON,
        content={
            "type": f"https://httpstatuses.com/{exc.status_code}",
            "title": "HTTP Error",
            "status": exc.status_code,
            "detail": exc.detail,
            "instance": str(request.url),
        },
        headers=exc.headers or None,
    )
```

---

## 11.9 Common pitfalls & tips

* **Do not swallow** `HTTPException` in middleware; let your custom HTTP handler format it.
* For **CORS preflight** and **redirects**, avoid wrapping with custom bodies that break browser expectations.
* Add **rate-limit** errors as 429 with a `Retry-After` header.
* For **auth** errors, send 401 with `WWW-Authenticate` header when appropriate.
* Keep a **consistent schema** across all errors for easy client parsing and testability.

---

## 11.10 Quick checklist

* [ ] Raise `HTTPException` for expected client errors.
* [ ] Create **custom exception classes** for domain errors; map them to 4xx/5xx.
* [ ] Override `RequestValidationError` to unify validation error format.
* [ ] Add a **global middleware** for unexpected exceptions + logging.
* [ ] Consider **problem+json** or a single **ErrorResponse** schema for consistency.
* [ ] Include **tracking IDs** in responses and logs for production debugging.

---

### Complete mini-app (copy-paste)

```python
from fastapi import FastAPI, HTTPException, status
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from starlette.requests import Request
from starlette.exceptions import HTTPException as StarletteHTTPException
from starlette.middleware.base import BaseHTTPMiddleware
import logging, uuid

app = FastAPI(title="Chapter 11 Error Handling Demo")
logger = logging.getLogger("uvicorn.error")

# ---------- Models ----------
class CreateUser(BaseModel):
    email: str = Field(..., pattern=r".+@.+\..+")
    age: int = Field(..., ge=0, le=130)

# ---------- Domain Exceptions ----------
class UserAlreadyExists(Exception):
    def __init__(self, email: str):
        self.email = email

# ---------- Routes ----------
@app.post("/users")
def create_user(payload: CreateUser):
    if payload.email == "taken@example.com":
        raise UserAlreadyExists(payload.email)
    return {"ok": True, "user": payload.model_dump()}

@app.get("/boom")
def boom():
    # Unexpected error
    1 / 0  # noqa

@app.get("/users/{user_id}")
def get_user(user_id: int):
    if user_id == 404:
        raise HTTPException(status_code=404, detail="User not found")
    return {"id": user_id, "email": "ok@example.com"}

# ---------- Validation Handler ----------
@app.exception_handler(RequestValidationError)
async def validation_handler(request: Request, exc: RequestValidationError):
    return JSONResponse(
        status_code=422,
        content={
            "error": {
                "type": "validation_error",
                "message": "Invalid request.",
                "details": exc.errors(),
                "instance": str(request.url),
            }
        },
    )

# ---------- HTTPException Handler (includes custom 404 JSON) ----------
@app.exception_handler(StarletteHTTPException)
async def http_handler(request: Request, exc: StarletteHTTPException):
    if exc.status_code == 404:
        return JSONResponse(
            status_code=404,
            content={
                "error": {
                    "type": "not_found",
                    "message": exc.detail or "Resource not found",
                    "resource": request.url.path,
                }
            },
        )
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": {
                "type": "http_error",
                "message": exc.detail,
                "tracking_id": str(uuid.uuid4()),
            }
        },
        headers=exc.headers or None,
    )

# ---------- Domain Handler ----------
@app.exception_handler(UserAlreadyExists)
async def user_exists_handler(request: Request, exc: UserAlreadyExists):
    return JSONResponse(
        status_code=status.HTTP_409_CONFLICT,
        content={
            "error": {
                "type": "user_exists",
                "message": f"User with email '{exc.email}' already exists.",
            }
        },
    )

# ---------- Global Catch-all Middleware ----------
class GlobalErrors(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        try:
            return await call_next(request)
        except Exception as e:
            logger.exception("Unhandled error: %s", e)
            return JSONResponse(
                status_code=500,
                content={
                    "error": {
                        "type": "internal_server_error",
                        "message": "Something went wrong. Please try again later.",
                    }
                },
            )

app.add_middleware(GlobalErrors)
```
