# Chapter 23: Case Studies & Projects

In this chapter, weâ€™ll consolidate everything weâ€™ve learned by building **end-to-end projects** using FastAPI. Each project will combine different conceptsâ€”routing, models, authentication, databases, async programming, and WebSockets.

---

## 1. RESTful Todo API

A simple but complete CRUD application.

### Features

* Create, read, update, delete tasks.
* Use Pydantic models for validation.
* Store tasks in an in-memory dictionary or SQLite DB.

### Example

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Dict

app = FastAPI(title="Todo API")

class Todo(BaseModel):
    id: int
    task: str
    completed: bool = False

todos: Dict[int, Todo] = {}

@app.post("/todos/", response_model=Todo)
def create(todo: Todo):
    if todo.id in todos:
        raise HTTPException(status_code=400, detail="Todo already exists")
    todos[todo.id] = todo
    return todo

@app.get("/todos/{todo_id}", response_model=Todo)
def read(todo_id: int):
    if todo_id not in todos:
        raise HTTPException(status_code=404, detail="Todo not found")
    return todos[todo_id]

@app.put("/todos/{todo_id}", response_model=Todo)
def update(todo_id: int, todo: Todo):
    if todo_id not in todos:
        raise HTTPException(status_code=404, detail="Todo not found")
    todos[todo_id] = todo
    return todo

@app.delete("/todos/{todo_id}")
def delete(todo_id: int):
    if todo_id not in todos:
        raise HTTPException(status_code=404, detail="Todo not found")
    del todos[todo_id]
    return {"message": "Todo deleted"}
```

---

## 2. Authentication System with JWT

### Features

* User registration and login.
* Password hashing with `bcrypt`.
* JWT token generation with `PyJWT`.

### Example

```python
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from passlib.context import CryptContext
import jwt
from datetime import datetime, timedelta

app = FastAPI(title="JWT Auth API")

SECRET_KEY = "supersecret"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

users_db = {}

def create_access_token(data: dict, expires_delta: timedelta):
    to_encode = data.copy()
    to_encode.update({"exp": datetime.utcnow() + expires_delta})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

@app.post("/register")
def register(username: str, password: str):
    if username in users_db:
        raise HTTPException(status_code=400, detail="User already exists")
    hashed_password = pwd_context.hash(password)
    users_db[username] = {"username": username, "password": hashed_password}
    return {"message": "User registered successfully"}

@app.post("/login")
def login(form_data: OAuth2PasswordRequestForm = Depends()):
    user = users_db.get(form_data.username)
    if not user or not pwd_context.verify(form_data.password, user["password"]):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")
    access_token = create_access_token(
        data={"sub": user["username"]},
        expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    )
    return {"access_token": access_token, "token_type": "bearer"}
```

---

## 3. E-commerce Backend

### Features

* Users, products, orders.
* Relationships between tables.
* Authentication for placing orders.

### Schema

* **Users**: id, username, password
* **Products**: id, name, price
* **Orders**: id, user_id, product_id, quantity

*(Use SQLAlchemy/SQLModel for persistenceâ€”simplified schema below)*

```python
from fastapi import FastAPI, Depends
from pydantic import BaseModel
from typing import List

app = FastAPI(title="E-commerce API")

class Product(BaseModel):
    id: int
    name: str
    price: float

class Order(BaseModel):
    id: int
    user: str
    product_id: int
    quantity: int

products = [
    Product(id=1, name="Laptop", price=1000.0),
    Product(id=2, name="Phone", price=500.0),
]

orders: List[Order] = []

@app.get("/products", response_model=List[Product])
def list_products():
    return products

@app.post("/orders", response_model=Order)
def create_order(order: Order):
    orders.append(order)
    return order
```

---

## 4. Healthcare API

### Features

* Manage **patients, appointments, prescriptions**.
* Example of a real-world domain (healthcare system).
* Uses relational data.

```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List

app = FastAPI(title="Healthcare API")

class Patient(BaseModel):
    id: int
    name: str
    age: int

class Appointment(BaseModel):
    id: int
    patient_id: int
    date: str

class Prescription(BaseModel):
    id: int
    patient_id: int
    medicine: str
    dosage: str

patients: List[Patient] = []
appointments: List[Appointment] = []
prescriptions: List[Prescription] = []

@app.post("/patients/", response_model=Patient)
def add_patient(patient: Patient):
    patients.append(patient)
    return patient

@app.get("/patients/", response_model=List[Patient])
def get_patients():
    return patients

@app.post("/appointments/", response_model=Appointment)
def add_appointment(appointment: Appointment):
    appointments.append(appointment)
    return appointment

@app.post("/prescriptions/", response_model=Prescription)
def add_prescription(prescription: Prescription):
    prescriptions.append(prescription)
    return prescription
```

---

## 5. Real-Time Chat App with WebSockets

### Features

* WebSocket-based communication.
* Broadcast messages to all connected clients.

```python
from fastapi import FastAPI, WebSocket, WebSocketDisconnect

app = FastAPI(title="Chat App")

class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            await connection.send_text(message)

manager = ConnectionManager()

@app.websocket("/ws/chat")
async def chat(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            await manager.broadcast(f"Message: {data}")
    except WebSocketDisconnect:
        manager.disconnect(websocket)
```

Run with:

```bash
uvicorn main:app --reload
```

Connect via WebSocket client (e.g., browser JS or Postman) to `/ws/chat`.

---

## ðŸ”‘ Key Takeaways

* **Todo API** â†’ CRUD basics.
* **JWT Auth** â†’ Secure authentication.
* **E-commerce backend** â†’ Relational data & business logic.
* **Healthcare API** â†’ Practical domain application.
* **Chat App** â†’ Real-time communication with WebSockets.

By working through these case studies, youâ€™ll gain confidence in building **real-world FastAPI applications** that combine multiple features.

---
