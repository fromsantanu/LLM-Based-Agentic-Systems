# Chapter 17: Security Features

Security is one of the most critical aspects of building production-ready applications. FastAPI provides powerful tools to help you secure APIs using authentication, authorization, and protection mechanisms.

In this chapter, weâ€™ll cover:

* Password hashing with **bcrypt**
* Protecting forms with **CSRF tokens**
* Using **OAuth2 scopes** for fine-grained permissions
* Example: A secure API with **JWT + role-based permissions**

---

## 17.1 Password Hashing with bcrypt

Storing plain text passwords is a serious vulnerability. Instead, you must hash passwords using a secure algorithm such as **bcrypt**.

### Installing bcrypt

```bash
pip install passlib[bcrypt]
```

### Example: Hashing and Verifying Passwords

```python
from passlib.context import CryptContext

# Create a CryptContext with bcrypt
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

# Usage
hashed = hash_password("mysecret")
print("Hashed password:", hashed)

print("Verify:", verify_password("mysecret", hashed))  # True
print("Verify wrong:", verify_password("wrongpass", hashed))  # False
```

ðŸ”‘ Always store **hashed passwords** in the database, never the plain text.

---

## 17.2 CSRF Protection

**Cross-Site Request Forgery (CSRF)** is an attack where a malicious site tricks a logged-in user into sending unintended requests to your app.

FastAPI doesnâ€™t provide CSRF protection directly because itâ€™s usually handled at the frontend (for web forms) or by using frameworks like **Starlette CSRF middleware**.

### Using `starlette-wtf` for CSRF

```bash
pip install starlette-wtf
```

```python
from starlette_wtf import CSRFProtectMiddleware
from fastapi import FastAPI

app = FastAPI()

# Enable CSRF protection with a secret key
app.add_middleware(CSRFProtectMiddleware, csrf_secret="supersecretkey")
```

ðŸ“Œ CSRF is **not required** for APIs using **JWT** or **OAuth2 tokens**, since they are usually sent in headers (not cookies).

---

## 17.3 OAuth2 Scopes

Scopes provide **fine-grained permissions** in OAuth2. For example:

* `read:items` â†’ can only read items
* `write:items` â†’ can create/update items
* `admin` â†’ full access

### Example: Defining OAuth2 Scopes

```python
from fastapi import Depends, FastAPI, Security
from fastapi.security import OAuth2PasswordBearer, SecurityScopes
from fastapi import HTTPException, status

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="token",
    scopes={"read": "Read items", "write": "Create/update items", "admin": "Admin access"}
)

def get_current_user(security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)):
    # For simplicity, decode manually (in real case use JWT verification)
    if token != "admintoken":
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token")

    token_scopes = ["read", "write", "admin"]
    for scope in security_scopes.scopes:
        if scope not in token_scopes:
            raise HTTPException(status_code=403, detail="Not enough permissions")
    return {"username": "admin", "scopes": token_scopes}

@app.get("/items/", dependencies=[Security(get_current_user, scopes=["read"])])
def read_items():
    return {"msg": "You can read items"}

@app.post("/items/", dependencies=[Security(get_current_user, scopes=["write"])])
def create_item():
    return {"msg": "You can create items"}
```

---

## 17.4 Example: Secure API with JWT + Role-Based Permissions

Now letâ€™s put everything together:

* Users **register with a hashed password**
* Login generates a **JWT token**
* Role-based access control (RBAC) ensures only authorized users can access certain routes

### Install dependencies

```bash
pip install python-jose[cryptography]
```

### Secure API Example

```python
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta

app = FastAPI()

# Security settings
SECRET_KEY = "supersecretkey"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# OAuth2 scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# Fake database
users_db = {
    "alice": {"username": "alice", "hashed_password": pwd_context.hash("alicepass"), "role": "user"},
    "admin": {"username": "admin", "hashed_password": pwd_context.hash("adminpass"), "role": "admin"},
}

# Utils
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

# Login route
@app.post("/token")
def login(form_data: OAuth2PasswordRequestForm = Depends()):
    user = users_db.get(form_data.username)
    if not user or not verify_password(form_data.password, user["hashed_password"]):
        raise HTTPException(status_code=400, detail="Invalid credentials")

    token = create_access_token({"sub": user["username"], "role": user["role"]},
                                timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    return {"access_token": token, "token_type": "bearer"}

# Get current user
def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        role: str = payload.get("role")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid token")
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")
    return {"username": username, "role": role}

# Routes with RBAC
@app.get("/users/me")
def read_users_me(current_user: dict = Depends(get_current_user)):
    return current_user

@app.get("/admin")
def read_admin_data(current_user: dict = Depends(get_current_user)):
    if current_user["role"] != "admin":
        raise HTTPException(status_code=403, detail="Not enough permissions")
    return {"msg": "Welcome Admin!"}
```

âœ… Features in this example:

* Passwords are stored **hashed**
* Tokens are **JWT-based**
* Roles determine access (`admin` vs `user`)

---

## ðŸ”‘ Key Takeaways

* Always **hash passwords** using a secure algorithm like **bcrypt**.
* **CSRF protection** is important for cookie-based forms but not for APIs using JWTs.
* **OAuth2 scopes** let you define fine-grained permissions.
* Use **JWT + RBAC** for scalable and secure APIs.

---
st.

