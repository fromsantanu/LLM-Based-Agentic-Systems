# Chapter 3 — Data Validation & Serialization

This chapter shows how **Pydantic (v2)** powers FastAPI’s request/response validation and how to serialize clean JSON back to clients.

---

## 3.1 Field validation with `Field(...)`

Use type hints + `Field()` constraints. Common ones:

* Strings: `min_length`, `max_length`, `pattern` (regex)
* Numbers: `ge` (≥), `gt` (>), `le` (≤), `lt` (<)
* Emails: `EmailStr`
* Datetimes: `datetime`, `date`

```python
# app/models.py
from pydantic import BaseModel, EmailStr, Field

class Address(BaseModel):
    line1: str = Field(..., min_length=3, max_length=100)
    city: str = Field(..., min_length=2)
    pin: str = Field(..., pattern=r"^\d{6}$")  # e.g., 6-digit Indian PIN

class UserBase(BaseModel):
    email: EmailStr
    full_name: str = Field(..., min_length=3, max_length=60)
    age: int = Field(..., ge=13, le=120)  # example rule
```

---

## 3.2 Nested models

Nest models to validate complex JSON structures automatically:

```python
class Profile(BaseModel):
    bio: str | None = Field(None, max_length=280)
    address: Address | None = None
```

---

## 3.3 Default values & optional fields

* Default with `=` (e.g., `is_active: bool = True`)
* Optional with `| None` (or `Optional[T]`)
* Provide sensible defaults to avoid extra client burden.

```python
from datetime import datetime

class UserCreate(UserBase):
    phone: str | None = Field(None, pattern=r"^\+?[1-9]\d{7,14}$")
    referred_by: EmailStr | None = None
    is_marketing_opt_in: bool = False
    created_at: datetime = Field(default_factory=datetime.utcnow)
```

---

## 3.4 Custom validators (Pydantic v2)

In v2, use `@field_validator` and `@model_validator`.

### Field-level checks

```python
from pydantic import field_validator

COMMON_PASSWORDS = {"password", "Password123", "12345678", "qwerty"}

class PasswordMixin(BaseModel):
    password: str = Field(..., min_length=8, max_length=64)

    @field_validator("password")
    @classmethod
    def strong_password(cls, v: str) -> str:
        if v in COMMON_PASSWORDS:
            raise ValueError("Password is too common.")
        # require at least one letter, one digit, one special char
        import re
        if not re.search(r"[A-Za-z]", v) or not re.search(r"\d", v) or not re.search(r"[^\w\s]", v):
            raise ValueError("Password must include letters, digits, and a special character.")
        return v
```

### Cross-field (model) checks

```python
from pydantic import model_validator

class UserRegister(PasswordMixin, UserCreate, Profile):
    confirm_password: str

    @model_validator(mode="after")
    def passwords_match(self):
        if self.password != self.confirm_password:
            raise ValueError("Passwords do not match.")
        return self
```

> Tip: Prefer **field validators** for single-field logic and **model validators** for multi-field consistency rules.

---

## 3.5 FastAPI endpoint with validation & response models

```python
# app/main.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from app.models import UserRegister, UserBase, Profile

app = FastAPI(title="User Registration Demo")

# What you store/return (hide sensitive fields)
class UserPublic(BaseModel):
    id: int
    email: str
    full_name: str
    profile: Profile | None = None
    is_active: bool = True

FAKE_DB: dict[int, UserPublic] = {}
_seq = 1

@app.post("/register", response_model=UserPublic, status_code=201)
def register_user(payload: UserRegister):
    # Example: reject duplicate email
    if any(u.email == payload.email for u in FAKE_DB.values()):
        raise HTTPException(status_code=409, detail="Email already registered.")

    global _seq
    user = UserPublic(
        id=_seq,
        email=payload.email,
        full_name=payload.full_name,
        profile=Profile(bio=payload.bio, address=payload.address) if (payload.bio or payload.address) else None,
    )
    FAKE_DB[_seq] = user
    _seq += 1
    return user
```

* **Incoming JSON** is validated against `UserRegister`:

  * Email format
  * Password strength + confirmation
  * Optional phone matches E.164-like regex
  * Nested `address` validated recursively
* **Outgoing JSON** is shaped by `response_model=UserPublic` (no password leaks).

---

## 3.6 Serialization: `model_dump` & `model_dump_json`

Pydantic v2 provides explicit serialization methods:

```python
u = UserPublic(
    id=1, email="alice@example.com", full_name="Alice", profile=None
)

python_dict = u.model_dump()             # standard Python types
json_string = u.model_dump_json()        # JSON string

# Control serialization:
python_dict_excluding_none = u.model_dump(exclude_none=True)
```

### Aliases & config (advanced)

```python
from pydantic import BaseModel, Field

class UserPublicOut(BaseModel):
    id: int
    email: str = Field(serialization_alias="userEmail")
    full_name: str = Field(serialization_alias="fullName")

    model_config = {
        "populate_by_name": True  # allows using field names when aliases exist
    }

u = UserPublicOut(id=1, email="a@b.com", full_name="Alice")
u.model_dump(by_alias=True)  # {"id":1,"userEmail":"a@b.com","fullName":"Alice"}
```

---

## 3.7 End-to-end Example: Validating user registration

### Request JSON (valid)

```json
{
  "email": "mita@example.com",
  "full_name": "Mita Karmakar",
  "age": 25,
  "phone": "+447911123456",
  "password": "S3cure@2025",
  "confirm_password": "S3cure@2025",
  "bio": "Data scientist & runner.",
  "address": {
    "line1": "221B Baker Street",
    "city": "London",
    "pin": "560001"
  }
}
```

### Response JSON

```json
{
  "id": 1,
  "email": "mita@example.com",
  "full_name": "Mita Karmakar",
  "profile": {
    "bio": "Data scientist & runner.",
    "address": {
      "line1": "221B Baker Street",
      "city": "London",
      "pin": "560001"
    }
  },
  "is_active": true
}
```

### Try it quickly (with `uvicorn`)

```bash
uvicorn app.main:app --reload
# POST the JSON above to: http://127.0.0.1:8000/register
```

---

## 3.8 Testing invalid inputs (what users see)

* **Weak password** → `422 Unprocessable Entity` with `detail` → “Password must include letters, digits, and a special character.”
* **Mismatched passwords** → `422` with “Passwords do not match.”
* **Bad phone** → `422` with regex error.
* **Invalid pin** → `422` with “string does not match pattern …”

FastAPI automatically returns a precise error path (e.g., `address.pin`).

---

## 3.9 Best practices & pitfalls

1. **Pydantic v2 syntax**

   * Prefer `@field_validator` / `@model_validator` (v1’s `@validator`/`@root_validator` are deprecated).
2. **Never return secrets**

   * Use `response_model` (e.g., `UserPublic`) to exclude sensitive fields.
3. **Regex performance**

   * Compile heavy regexes once at module import if they’re expensive.
4. **Enums for known sets**

   * Use `Enum` for stable choices (e.g., country codes) to get automatic validation.
5. **`exclude_none=True`** for clean JSON when optional fields are absent.

---

## 3.10 Complete file structure (for this chapter)

```
app/
  __init__.py
  main.py         # FastAPI app + /register
  models.py       # Pydantic models, validators
```

You now have a robust foundation for **validation and serialization**. Next up: we’ll wire these models into richer endpoints and start enforcing **business rules** consistently across the app.

