# Chapter 4: Dependency Injection

FastAPI comes with a powerful **dependency injection system** that allows you to manage reusable logic across your application. This feature helps in keeping code clean, modular, and testable. Common use cases include **authentication, database sessions, request validation, and shared utilities**.

---

## 4.1 What is Dependency Injection?

Dependency Injection (DI) is a design pattern where objects or functions receive their dependencies from external sources rather than creating them internally.

In FastAPI, this is achieved using the `Depends()` function.

* Promotes **reusability** (one dependency can be used across multiple routes).
* Encourages **separation of concerns** (business logic separated from infrastructure).
* Makes testing easier (mock dependencies can be injected).

---

## 4.2 The `Depends()` Function

The simplest form of dependency injection is passing a function wrapped with `Depends()` to a route.

```python
from fastapi import FastAPI, Depends

app = FastAPI()

def common_parameters(q: str = None, skip: int = 0, limit: int = 10):
    return {"q": q, "skip": skip, "limit": limit}

@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):
    return commons
```

* `common_parameters` is a dependency function.
* FastAPI automatically calls it and injects the result into `read_items`.

---

## 4.3 Using Dependencies for Authentication

Dependencies are very useful for handling authentication and authorization.

```python
from fastapi import HTTPException, status

def get_current_user(token: str = "fake-token"):
    if token != "secret-token":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )
    return {"username": "alice"}

@app.get("/users/me")
async def read_current_user(user: dict = Depends(get_current_user)):
    return user
```

* Here, `get_current_user` acts as an authentication dependency.
* It can be reused in multiple routes that need authentication.

---

## 4.4 Parameterized Dependencies

Dependencies can also take parameters, making them more flexible.

```python
def query_filter(min_length: int):
    def dependency(q: str = ""):
        if len(q) < min_length:
            raise HTTPException(
                status_code=400,
                detail=f"Query too short. Minimum length is {min_length}."
            )
        return q
    return dependency

@app.get("/search/")
async def search(q: str = Depends(query_filter(min_length=3))):
    return {"query": q}
```

* `query_filter` is a factory function that produces a dependency with a given minimum length.
* This is useful for **configurable validation logic**.

---

## 4.5 Injecting a Database Session

One of the most common dependency injection patterns is providing a **database session** to routes.

```python
from sqlalchemy.orm import Session
from fastapi import Depends

# Assume we have SessionLocal from SQLAlchemy setup
from database import SessionLocal

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/products/")
async def read_products(db: Session = Depends(get_db)):
    products = db.query(Product).all()
    return products
```

* `get_db` creates and cleans up the database session.
* The `yield` keyword ensures proper resource management.
* Routes can directly use `db` without worrying about session lifecycle.

---

## 4.6 Summary

* **`Depends()`** is the backbone of dependency injection in FastAPI.
* Dependencies can be used for **parameters, authentication, validation, and DB sessions**.
* Parameterized dependencies provide **flexibility**.
* Proper use of DI keeps your FastAPI app **clean, testable, and maintainable**.

---

✅ **Next Chapter Preview**: In **Chapter 5 (Error Handling & Middleware)**, we’ll explore how to handle exceptions gracefully, add custom middleware, and log requests/responses.

---
