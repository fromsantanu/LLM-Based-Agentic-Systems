# Chapter 2 — Core Building Blocks (FastAPI)

In this chapter, you’ll master FastAPI’s essentials: **path parameters**, **query parameters**, **request bodies with Pydantic**, **multiple bodies**, and **response models & validation**. We’ll finish with a compact **CRUD Book API** you can run immediately.

---

## 2.1 Path Parameters

Use **path parameters** to capture values embedded in the URL path.

```python
# main.py
from fastapi import FastAPI, Path

app = FastAPI(title="Chapter 2: Core Building Blocks")

@app.get("/items/{id}")
def get_item(
    id: int = Path(..., ge=1, description="Integer ID, must be ≥ 1")
):
    return {"id": id, "message": "Fetched by path param"}
```

* `Path(..., ge=1)` adds validation (here, “greater or equal to 1”).
* FastAPI auto-docs: open **/docs** after running.

---

## 2.2 Query Parameters

**Query parameters** come after `?` in the URL.

```python
from typing import Optional
from fastapi import Query

@app.get("/items")
def list_items(
    name: Optional[str] = Query(None, min_length=1, max_length=50, description="Filter by name"),
    price: Optional[float] = Query(None, ge=0, description="Filter by max price"),
    limit: int = Query(10, ge=1, le=100, description="Page size")
):
    # Dummy filtered response
    return {"filters": {"name": name, "price": price}, "limit": limit}
```

Example: `GET /items?name=apple&price=10&limit=5`

---

## 2.3 Request Body with Pydantic Models

Define **typed** request bodies with Pydantic (v2).

```python
from pydantic import BaseModel, Field

class Item(BaseModel):
    name: str = Field(..., min_length=1, max_length=50)
    price: float = Field(..., ge=0)
    in_stock: bool = True
    tags: list[str] = Field(default_factory=list)
```

Use it in a route:

```python
from fastapi import Body

@app.post("/items")
def create_item(payload: Item = Body(...)):
    return {"created": payload}
```

* FastAPI reads JSON, validates it against `Item`, and provides the parsed object.

---

## 2.4 Handling Multiple Request Bodies

You can accept multiple bodies by adding multiple parameters that FastAPI marks as **Body**.

```python
class Supplier(BaseModel):
    id: int = Field(..., ge=1)
    name: str = Field(..., min_length=2)

@app.post("/items/with-supplier")
def create_item_with_supplier(
    item: Item = Body(..., description="Item payload"),
    supplier: Supplier = Body(..., description="Supplier payload")
):
    return {"item": item, "supplier": supplier}
```

**Client JSON shape** must include both top-level keys `item` and `supplier`:

```json
{
  "item": { "name": "Pen", "price": 12.5, "in_stock": true, "tags": ["office"] },
  "supplier": { "id": 3, "name": "Acme Ltd" }
}
```

> Tip: If you want a **single** top-level object instead, define a wrapper Pydantic model that contains both `item` and `supplier` fields.

---

## 2.5 Response Models & Data Validation

Use `response_model` to **shape** and **validate** the response. Great for:

* Hiding internal fields
* Enforcing types and constraints
* Auto-generating clean OpenAPI schemas

```python
class ItemPublic(BaseModel):
    name: str
    price: float
    tags: list[str]

@app.get("/items/{id}/public", response_model=ItemPublic)
def get_item_public(id: int = Path(..., ge=1)):
    # Simulate internal record
    record = {"name": "Apple", "price": 10.0, "in_stock": False, "tags": ["fruit"]}
    return record  # Extra fields like `in_stock` are filtered out by response_model
```

You can also refine serialization:

```python
from typing import Annotated
from fastapi import status

@app.post(
    "/items/validated",
    response_model=ItemPublic,
    status_code=status.HTTP_201_CREATED
)
def create_validated_item(item: Item):
    # Imagine DB insert here…
    return item  # Will be coerced to ItemPublic schema in the response
```

---

## 2.6 Example: Simple CRUD for Book API

We’ll implement a minimal in-memory CRUD with:

* Path params for `/books/{book_id}`
* Query params for listing `/books?author=...&q=...&limit=...`
* Request/response models with validation

### 2.6.1 Models

```python
from pydantic import BaseModel, Field
from typing import Optional

class BookBase(BaseModel):
    title: str = Field(..., min_length=1, max_length=120)
    author: str = Field(..., min_length=1, max_length=80)
    price: float = Field(..., ge=0)
    in_stock: bool = True

class BookCreate(BookBase):
    pass

class BookUpdate(BaseModel):
    title: Optional[str] = Field(None, min_length=1, max_length=120)
    author: Optional[str] = Field(None, min_length=1, max_length=80)
    price: Optional[float] = Field(None, ge=0)
    in_stock: Optional[bool] = None

class Book(BookBase):
    id: int = Field(..., ge=1)
```

### 2.6.2 Fake “Database”

```python
from fastapi import HTTPException

BOOKS: dict[int, Book] = {}
_next_id = 1

def _allocate_id() -> int:
    global _next_id
    nid = _next_id
    _next_id += 1
    return nid
```

### 2.6.3 CRUD Endpoints

```python
from fastapi import status, Query, Path

@app.post("/books", response_model=Book, status_code=status.HTTP_201_CREATED)
def create_book(data: BookCreate):
    book_id = _allocate_id()
    book = Book(id=book_id, **data.model_dump())
    BOOKS[book_id] = book
    return book

@app.get("/books", response_model=list[Book])
def list_books(
    author: Optional[str] = Query(None, min_length=1, description="Filter by author"),
    q: Optional[str] = Query(None, min_length=1, description="Search in title"),
    limit: int = Query(10, ge=1, le=100)
):
    items = list(BOOKS.values())
    if author:
        items = [b for b in items if b.author.lower() == author.lower()]
    if q:
        items = [b for b in items if q.lower() in b.title.lower()]
    return items[:limit]

@app.get("/books/{book_id}", response_model=Book)
def get_book(book_id: int = Path(..., ge=1)):
    book = BOOKS.get(book_id)
    if not book:
        raise HTTPException(status_code=404, detail="Book not found")
    return book

@app.put("/books/{book_id}", response_model=Book)
def replace_book(book_id: int, data: BookCreate):
    if book_id not in BOOKS:
        raise HTTPException(status_code=404, detail="Book not found")
    updated = Book(id=book_id, **data.model_dump())
    BOOKS[book_id] = updated
    return updated

@app.patch("/books/{book_id}", response_model=Book)
def update_book(book_id: int, data: BookUpdate):
    existing = BOOKS.get(book_id)
    if not existing:
        raise HTTPException(status_code=404, detail="Book not found")
    updates = data.model_dump(exclude_unset=True)
    updated = existing.model_copy(update=updates)
    BOOKS[book_id] = updated
    return updated

@app.delete("/books/{book_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_book(book_id: int):
    if book_id not in BOOKS:
        raise HTTPException(status_code=404, detail="Book not found")
    del BOOKS[book_id]
    return None
```

### 2.6.4 Run & Try

Start the app:

```bash
uvicorn main:app --reload
```

Open interactive docs at **[http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs)**.

#### cURL quick checks

```bash
# Create
curl -X POST http://127.0.0.1:8000/books \
  -H "Content-Type: application/json" \
  -d '{"title":"Clean Code","author":"Robert C. Martin","price":499.0,"in_stock":true}'

# List
curl "http://127.0.0.1:8000/books?author=Robert%20C.%20Martin&limit=5"

# Get one
curl http://127.0.0.1:8000/books/1

# Update (PUT)
curl -X PUT http://127.0.0.1:8000/books/1 \
  -H "Content-Type: application/json" \
  -d '{"title":"Clean Code (2nd Ed)","author":"Robert C. Martin","price":549.0,"in_stock":true}'

# Partial update (PATCH)
curl -X PATCH http://127.0.0.1:8000/books/1 \
  -H "Content-Type: application/json" \
  -d '{"price": 525.0, "in_stock": false}'

# Delete
curl -X DELETE http://127.0.0.1:8000/books/1
```

---

## 2.7 Practical Tips

* Use **`Path`**, **`Query`**, and **`Body`** (often via `Annotated`) to make intent explicit:

  ```python
  from typing import Annotated
  from fastapi import Path, Query, Body

  @app.get("/users/{user_id}")
  def show_user(
      user_id: Annotated[int, Path(ge=1)],
      verbose: Annotated[bool | None, Query()] = None
  ):
      ...
  ```
* Prefer **response models** to keep external contracts stable even if internals change.
* For large apps, split routers into modules (e.g., `routers/books.py`) and include with `app.include_router(...)`.

---

