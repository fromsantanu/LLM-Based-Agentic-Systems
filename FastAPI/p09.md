# Chapter 9: Background Tasks & Scheduling

Modern web applications often need to perform **time-consuming tasks** (like sending emails, generating reports, or logging activity) without making the user wait for a response. FastAPI provides tools to run background jobs, and we can also integrate external task queues and schedulers for more complex scenarios.

---

## 1. Using `BackgroundTasks` in FastAPI

FastAPIâ€™s `BackgroundTasks` class lets you run functions in the background **after sending the response** to the client.

### Example: Sending Emails in the Background

```python
from fastapi import FastAPI, BackgroundTasks

app = FastAPI()

def send_welcome_email(email: str):
    # Imagine this is an expensive email sending function
    print(f"ðŸ“§ Sending welcome email to {email}")

@app.post("/register/")
async def register_user(email: str, background_tasks: BackgroundTasks):
    # Add background job
    background_tasks.add_task(send_welcome_email, email)
    return {"message": f"User registered with {email}. Email will be sent in background."}
```

ðŸ”Ž **Explanation**

* `background_tasks.add_task(func, *args)` schedules a function after returning a response.
* The client gets a **fast response**, while the task runs asynchronously in the background.

---

## 2. Async Tasks with Celery & Redis

For **heavy workloads** (like data processing, video rendering, or ML inference), FastAPI apps often use **Celery** with **Redis** or **RabbitMQ** as a broker.

### Install

```bash
pip install celery[redis]
```

### `celery_app.py`

```python
from celery import Celery

celery = Celery(
    "worker",
    broker="redis://localhost:6379/0",   # Redis as broker
    backend="redis://localhost:6379/0"   # Store results in Redis
)

@celery.task
def send_email_task(email: str):
    print(f"ðŸ“§ [Celery] Sending email to {email}")
    return f"Email sent to {email}"
```

### `main.py` (FastAPI)

```python
from fastapi import FastAPI
from celery_app import send_email_task

app = FastAPI()

@app.post("/celery-register/")
async def celery_register(email: str):
    task = send_email_task.delay(email)  # Runs asynchronously
    return {"task_id": task.id, "status": "queued"}
```

### Run Workers

```bash
celery -A celery_app.celery worker --loglevel=info
```

ðŸ”Ž **Why Celery?**

* Handles **distributed task queues**.
* Retries failed tasks.
* Stores results (using Redis, RabbitMQ, etc.).
* Good for **scalable microservices**.

---

## 3. Scheduled Jobs with APScheduler

If you need to **run tasks on a schedule** (like cron jobs), you can use **APScheduler**.

### Install

```bash
pip install apscheduler
```

### Example: Scheduled Task

```python
from fastapi import FastAPI
from apscheduler.schedulers.background import BackgroundScheduler
import time

app = FastAPI()
scheduler = BackgroundScheduler()

def log_heartbeat():
    print(f"ðŸ’“ Heartbeat at {time.strftime('%Y-%m-%d %H:%M:%S')}")

# Add job every 10 seconds
scheduler.add_job(log_heartbeat, "interval", seconds=10)
scheduler.start()

@app.get("/")
def root():
    return {"message": "APScheduler is running in background"}
```

ðŸ”Ž **Use Cases**

* Sending daily reports.
* Cleaning old database entries.
* Health checks.
* Automated notifications.

---

## 4. End-to-End Example

**User registration triggers a welcome email in the background**.

```python
from fastapi import FastAPI, BackgroundTasks
from pydantic import BaseModel

app = FastAPI()

class User(BaseModel):
    name: str
    email: str

def send_welcome_email(email: str):
    print(f"âœ… Welcome email sent to {email}")

@app.post("/register/")
async def register(user: User, background_tasks: BackgroundTasks):
    # Save user to database (dummy here)
    print(f"ðŸ‘¤ Registered user: {user.name} - {user.email}")

    # Send email in background
    background_tasks.add_task(send_welcome_email, user.email)

    return {"message": f"User {user.name} registered successfully."}
```

âœ… Response is **instant**, while the email is handled in the background.

---

## Summary

* **`BackgroundTasks`**: Lightweight, built-in for simple async jobs.
* **Celery + Redis**: Best for heavy, distributed, retryable tasks.
* **APScheduler**: Best for scheduled jobs (cron-like tasks).

ðŸš€ With these tools, FastAPI apps can handle **asynchronous processing, background jobs, and scheduled automation** seamlessly.

---

