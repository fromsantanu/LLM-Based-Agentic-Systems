# Chapter 21: Advanced Features

FastAPI provides a lot of flexibility to extend beyond basic REST APIs. In this chapter, we’ll cover **custom decorators**, **event-driven design with Kafka/RabbitMQ**, and **GraphQL integration**. These advanced features make FastAPI powerful enough for complex, production-grade systems.

---

## 1. Custom Decorators in FastAPI

Python decorators are functions that wrap around other functions. In FastAPI, they’re useful for adding reusable logic to endpoints, such as logging, timing, or custom authentication.

### Example: Custom logging decorator

```python
from fastapi import FastAPI
import time
from functools import wraps

app = FastAPI()

def log_execution_time(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start = time.time()
        response = await func(*args, **kwargs)
        duration = time.time() - start
        print(f"Executed {func.__name__} in {duration:.4f}s")
        return response
    return wrapper

@app.get("/items/{item_id}")
@log_execution_time
async def read_item(item_id: int):
    return {"item_id": item_id, "status": "ok"}
```

✅ Here, every time `/items/{item_id}` is called, the decorator logs how long the request took.

---

## 2. Event-Driven Design with Kafka / RabbitMQ

Event-driven architectures decouple services by sending messages (events) through brokers like **Kafka** or **RabbitMQ**. FastAPI can act as both a **producer** (sending events) and a **consumer** (processing events).

### Kafka Example with aiokafka

```python
from fastapi import FastAPI
from aiokafka import AIOKafkaProducer, AIOKafkaConsumer
import asyncio

app = FastAPI()
loop = asyncio.get_event_loop()

producer: AIOKafkaProducer = None

@app.on_event("startup")
async def startup_event():
    global producer
    producer = AIOKafkaProducer(
        loop=loop, bootstrap_servers="localhost:9092"
    )
    await producer.start()

@app.on_event("shutdown")
async def shutdown_event():
    await producer.stop()

@app.post("/send/{message}")
async def send_message(message: str):
    await producer.send_and_wait("fastapi-topic", message.encode("utf-8"))
    return {"status": "Message sent!"}
```

* `startup_event`: Initializes the Kafka producer.
* `send_message`: Sends messages to Kafka topic `fastapi-topic`.
* Similar setup applies for RabbitMQ using `aio_pika`.

✅ This allows you to build **real-time pipelines** or **microservice communication**.

---

## 3. GraphQL with FastAPI

FastAPI supports **GraphQL** via libraries like **Strawberry**, **Ariadne**, or **Graphene**.
GraphQL lets clients query only the data they need, unlike REST which sends fixed responses.

### Install Strawberry

```bash
pip install strawberry-graphql
```

### Example: Strawberry + FastAPI

```python
import strawberry
from fastapi import FastAPI
from strawberry.fastapi import GraphQLRouter

# Define GraphQL schema
@strawberry.type
class Book:
    id: int
    title: str
    author: str

books = [
    Book(id=1, title="1984", author="George Orwell"),
    Book(id=2, title="The Hobbit", author="J.R.R. Tolkien"),
]

@strawberry.type
class Query:
    all_books: list[Book] = strawberry.field(resolver=lambda: books)
    book_by_id: Book | None = strawberry.field(
        resolver=lambda id: next((b for b in books if b.id == id), None)
    )

schema = strawberry.Schema(query=Query)

# Integrate with FastAPI
app = FastAPI()
graphql_app = GraphQLRouter(schema)
app.include_router(graphql_app, prefix="/graphql")
```

Now visit:

* **[http://127.0.0.1:8000/graphql](http://127.0.0.1:8000/graphql)** → Interactive GraphQL Playground.

### Example Query

```graphql
query {
  allBooks {
    id
    title
  }
  bookById(id: 2) {
    title
    author
  }
}
```

✅ Clients get **exact data** they request, nothing more.

---

## 4. Example: GraphQL API with Strawberry + FastAPI

Let’s expand our books example with a **mutation** to add new books.

```python
@strawberry.type
class Mutation:
    @strawberry.mutation
    def add_book(self, title: str, author: str) -> Book:
        new_id = len(books) + 1
        book = Book(id=new_id, title=title, author=author)
        books.append(book)
        return book

schema = strawberry.Schema(query=Query, mutation=Mutation)
```

Now in the playground:

```graphql
mutation {
  addBook(title: "Dune", author: "Frank Herbert") {
    id
    title
    author
  }
}
```

Result:

```json
{
  "data": {
    "addBook": {
      "id": 3,
      "title": "Dune",
      "author": "Frank Herbert"
    }
  }
}
```

---

## ✅ Key Takeaways

* **Custom decorators** allow adding reusable logic like logging, authentication, or metrics.
* **Kafka / RabbitMQ** enable **event-driven** and **microservice-based** architectures with FastAPI.
* **GraphQL** provides **flexible querying** compared to REST and integrates smoothly with FastAPI using **Strawberry**.

---

