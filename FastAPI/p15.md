# Chapter 15: Event Handling

In real-world applications, you often need to perform setup or cleanup tasks when your FastAPI app **starts** or **shuts down**.
This includes tasks like:

* Connecting to databases.
* Initializing caches (Redis, Memcached).
* Loading ML models into memory.
* Closing database sessions or releasing resources at shutdown.

FastAPI provides **startup** and **shutdown events** for this purpose.

---

## 1. Startup & Shutdown Events

FastAPI allows you to define **event handlers** using decorators:

```python
from fastapi import FastAPI

app = FastAPI()

@app.on_event("startup")
async def startup_event():
    print("ðŸš€ App is starting up...")

@app.on_event("shutdown")
async def shutdown_event():
    print("ðŸ›‘ App is shutting down...")
```

* `startup` â†’ runs **before the first request** is processed.
* `shutdown` â†’ runs **when the app stops gracefully** (e.g., `CTRL+C`, container stop).

---

## 2. Database Connection Pooling

Database connections are expensive. Instead of creating and closing connections for every request, you should use a **connection pool**.
A connection pool keeps a set of open connections and reuses them across requests.

### Example: SQLAlchemy (synchronous engine)

```python
from fastapi import FastAPI, Depends
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session

DATABASE_URL = "sqlite:///./test.db"

# Create engine with connection pooling
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False}, pool_pre_ping=True)

# Session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

app = FastAPI()

# Dependency for DB session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.on_event("startup")
def on_startup():
    print("âœ… Database connected!")

@app.on_event("shutdown")
def on_shutdown():
    engine.dispose()
    print("ðŸ”’ Database connections closed!")

@app.get("/items/")
def read_items(db: Session = Depends(get_db)):
    result = db.execute("SELECT 'Hello from DB!'").fetchall()
    return {"result": result}
```

* `engine.dispose()` closes all pooled connections on shutdown.
* `pool_pre_ping=True` checks stale connections before use.

---

### Example: Async Database (Databases library)

If youâ€™re using `databases` package with async engines:

```python
from fastapi import FastAPI
import databases

DATABASE_URL = "sqlite+aiosqlite:///./test.db"
database = databases.Database(DATABASE_URL)

app = FastAPI()

@app.on_event("startup")
async def connect_to_db():
    await database.connect()
    print("âœ… Async DB connected!")

@app.on_event("shutdown")
async def disconnect_from_db():
    await database.disconnect()
    print("ðŸ”’ Async DB disconnected!")

@app.get("/items/")
async def get_items():
    query = "SELECT 'Hello from Async DB!'"
    result = await database.fetch_all(query)
    return {"result": result}
```

* `database.connect()` â†’ creates and manages the connection pool at startup.
* `database.disconnect()` â†’ closes all active connections on shutdown.

---

## 3. Example: Initialize DB on Startup, Close Session on Shutdown

Hereâ€™s a minimal **working example**:

```python
from fastapi import FastAPI, Depends
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker, Session

DATABASE_URL = "sqlite:///./app.db"

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

app = FastAPI()

# Dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.on_event("startup")
def startup():
    print("ðŸš€ App started, initializing DB...")
    with engine.begin() as conn:
        conn.execute(text("CREATE TABLE IF NOT EXISTS messages (id INTEGER PRIMARY KEY, text TEXT)"))

@app.on_event("shutdown")
def shutdown():
    engine.dispose()
    print("ðŸ›‘ DB connections closed!")

@app.post("/add/{msg}")
def add_message(msg: str, db: Session = Depends(get_db)):
    db.execute(text("INSERT INTO messages (text) VALUES (:msg)"), {"msg": msg})
    db.commit()
    return {"status": "Message added!"}

@app.get("/messages/")
def get_messages(db: Session = Depends(get_db)):
    result = db.execute(text("SELECT * FROM messages")).fetchall()
    return {"messages": [dict(row) for row in result]}
```

* On startup, the `messages` table is initialized.
* On shutdown, the DB connections are properly disposed.

---

âœ… **Best Practices**:

* Always manage DB connections with pooling.
* Use `@app.on_event` for setup/cleanup tasks.
* Prefer async connections for high-concurrency apps.
* Always close/dispose connections to prevent leaks.

---

