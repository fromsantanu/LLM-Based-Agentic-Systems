# 1. Introduction to Pydantic in Agentic Workflows

## Why Structured Validation is Critical in Multi-Agent Systems

Agentic workflows rely on multiple autonomous components (agents) that pass messages, decisions, or actions between each other. For example, in a hospital triage system, one agent might collect patient symptoms, another might decide which tests are needed, and a third might book appointments.

In such multi-agent systems, **data integrity and consistency** are non-negotiable:

* **Error propagation risk**: A small data error (e.g., a missing field or wrong data type) can cascade across agents, leading to incorrect decisions.
* **Interoperability**: Agents may be built by different teams or use different libraries; enforcing a standard schema ensures they communicate correctly.
* **Trust in automation**: Healthcare, finance, and logistics domains require regulatory compliance. Strong validation reduces the chance of critical mistakes.

This is where **Pydantic** comes in. It ensures that every input and output conforms to strict rules, catching issues early and guaranteeing consistency across agent boundaries.

---

## Pydantic Models vs Plain Python Dataclasses

At first glance, Python `dataclasses` and Pydantic `BaseModel` look similar: both provide a structured way to define objects with attributes. However, they differ in **validation, type enforcement, and serialization**.

| Feature                       | Python Dataclasses               | Pydantic Models                                  |
| ----------------------------- | -------------------------------- | ------------------------------------------------ |
| **Type validation**           | Only annotations, no enforcement | Validates at runtime                             |
| **Automatic parsing**         | ❌                                | ✅ Converts strings, numbers, JSON → proper types |
| **Error handling**            | ❌ Must be custom coded           | ✅ Built-in validation errors                     |
| **Serialization (dict/JSON)** | Manual handling                  | `.dict()`, `.json()` out of the box              |
| **Nested models**             | ❌ Limited support                | ✅ Fully supported                                |
| **Performance**               | Lightweight                      | Slight overhead due to validation                |

In short:

* Use **dataclasses** for lightweight, internal-only structures where you fully control the data.
* Use **Pydantic models** for **agent communication**, **API inputs/outputs**, or **anything that crosses system boundaries**.

---

## Example: Defining a `PatientRequest` Model for a Triage Agent

Let’s see how a triage agent might validate incoming patient requests.

### Using a Python `dataclass`:

```python
from dataclasses import dataclass

@dataclass
class PatientRequest:
    name: str
    age: int
    symptoms: list[str]
```

This works, but offers **no validation**:

```python
request = PatientRequest(name="John", age="thirty", symptoms="fever")
# No error, but 'age' is a string and 'symptoms' is not a list!
```

---

### Using a Pydantic `BaseModel`:

```python
from pydantic import BaseModel, Field
from typing import List

class PatientRequest(BaseModel):
    name: str = Field(..., min_length=1, description="Patient's full name")
    age: int = Field(..., ge=0, le=120, description="Age in years")
    symptoms: List[str] = Field(..., description="List of reported symptoms")
```

Now, Pydantic enforces rules:

```python
valid_request = PatientRequest(
    name="John Doe",
    age=35,
    symptoms=["fever", "cough"]
)
print(valid_request.dict())
```

✅ Output:

```python
{'name': 'John Doe', 'age': 35, 'symptoms': ['fever', 'cough']}
```

---

```python
invalid_request = PatientRequest(
    name="",
    age="thirty",
    symptoms="fever"
)
```

❌ Raises validation errors:

```
3 validation errors for PatientRequest
name
  String should have at least 1 character
age
  Input should be a valid integer
symptoms
  Input should be a valid list
```

---

## Key Takeaways

* Pydantic ensures **structured, validated data** in workflows where multiple agents communicate.
* Compared to plain dataclasses, Pydantic adds **runtime type enforcement, error reporting, and serialization**.
* In a triage agent scenario, a `PatientRequest` model prevents invalid patient data from propagating across the workflow.

---
