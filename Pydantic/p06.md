# 6. Custom Validation with `field_validator` & `model_validator`

When agents pass objects between steps, **domain rules** must be enforced right where the data is defined. Pydantic v2 gives you two precise tools:

* `field_validator` — validate/transform a **single field** (optionally with context).
* `model_validator` — validate **the whole model** (great for cross-field rules).

We’ll build a tiny imaging-order schema and enforce a key clinical rule:

> **Rule**: If `test_type == "ContrastCT"`, then `eGFR ≥ 30` (to reduce contrast-induced kidney injury risk).

---

## 6.1 Example Schema (Agent I/O)

```python
from enum import Enum
from typing import Optional, Literal
from datetime import datetime

from pydantic import BaseModel, field_validator, model_validator
from pydantic_core import PydanticCustomError


class TestType(str, Enum):
    ContrastCT = "ContrastCT"
    NonContrastCT = "NonContrastCT"
    MRI = "MRI"
    XRay = "XRay"
    Ultrasound = "Ultrasound"


class ImagingOrder(BaseModel):
    patient_id: str
    age_years: int
    test_type: TestType
    eGFR: Optional[float] = None               # Estimated Glomerular Filtration Rate (mL/min/1.73m²)
    pregnancy: Optional[Literal["yes", "no"]] = None
    created_at: datetime = datetime.utcnow()

    # --- Field-level rules ----------------------------------------------------

    @field_validator("age_years")
    @classmethod
    def non_negative_age(cls, v: int) -> int:
        if v < 0:
            raise ValueError("age_years must be ≥ 0")
        return v

    @field_validator("eGFR", mode="before")
    @classmethod
    def coerce_egfr(cls, v):
        """
        Accept strings like '55', '55.0', '  60  ' and coerce to float.
        Accept None if not provided.
        """
        if v is None:
            return v
        if isinstance(v, (int, float)):
            return float(v)
        try:
            return float(str(v).strip())
        except Exception:
            raise ValueError("eGFR must be a number (or omitted)")

    # --- Model-level (cross-field) rules -------------------------------------

    @model_validator(mode="after")
    def contrast_requires_egfr_ok(self):
        """
        Domain rule:
        - If Contrast CT is requested, eGFR must be present and ≥ 30.
        """
        if self.test_type == TestType.ContrastCT:
            if self.eGFR is None:
                raise PydanticCustomError(
                    "egfr.required_for_contrast",
                    "eGFR is required when test_type is ContrastCT."
                )
            if self.eGFR < 30:
                raise PydanticCustomError(
                    "egfr.below_threshold",
                    "eGFR {egfr} is below 30; ContrastCT not allowed.",
                    {"egfr": self.eGFR},
                )
        return self
```

**Why both levels?**

* Field validators keep each field sane (e.g., type coercion, ranges).
* Model validator checks interactions (e.g., *“if A then B must satisfy …”*).

---

## 6.2 Usage & Errors (What agents will see)

```python
# ✅ Allowed
ok = ImagingOrder(
    patient_id="P-102",
    age_years=61,
    test_type="NonContrastCT",
    eGFR=None,
)

# ✅ Allowed (Contrast with eGFR ≥ 30)
ok2 = ImagingOrder(
    patient_id="P-103",
    age_years=44,
    test_type="ContrastCT",
    eGFR="45.0",  # string coerced to float
)

# ❌ Fails: Missing eGFR for ContrastCT
bad1 = ImagingOrder(
    patient_id="P-104",
    age_years=28,
    test_type="ContrastCT",
)
# -> egfr.required_for_contrast: eGFR is required when test_type is ContrastCT.

# ❌ Fails: eGFR too low
bad2 = ImagingOrder(
    patient_id="P-105",
    age_years=70,
    test_type="ContrastCT",
    eGFR=25,
)
# -> egfr.below_threshold: eGFR 25 is below 30; ContrastCT not allowed.
```

In multi-agent pipelines, surfacing **clear, machine-parsable error codes** (e.g., `egfr.below_threshold`) lets an upstream agent **auto-remediate** (e.g., suggest *NonContrastCT* or *MRI*).

---

## 6.3 Bonus: More Domain Rules You’ll Commonly Add

Add these as additional `model_validator`s (or fold into one validator if you prefer):

```python
    @model_validator(mode="after")
    def pregnancy_radiation_guard(self):
        # Example guard: avoid ionizing radiation in pregnancy (unless emergent).
        if (self.pregnancy == "yes") and self.test_type in {TestType.ContrastCT, TestType.NonContrastCT, TestType.XRay}:
            raise PydanticCustomError(
                "pregnancy.ionizing_guard",
                "Ionizing imaging requested while pregnancy=yes. Consider MRI/Ultrasound unless life-threatening."
            )
        return self
```

---

## 6.4 Transform vs Validate (when to use `mode="before"` vs default)

* `mode="before"`: normalize **inputs** into a canonical form (e.g., trim strings, parse numbers).
* Default (after): validate the **normalized** values.

This keeps domain checks stable and reduces “branchy” code.

---

## 6.5 Testing Your Validators (quick & minimal)

```python
import pytest
from pydantic_core import ValidationError

def test_contrast_requires_egfr():
    with pytest.raises(ValidationError) as e:
        ImagingOrder(patient_id="P", age_years=40, test_type="ContrastCT")
    assert "egfr.required_for_contrast" in str(e.value)

def test_egfr_threshold():
    with pytest.raises(ValidationError) as e:
        ImagingOrder(patient_id="P", age_years=40, test_type="ContrastCT", eGFR=29.9)
    assert "egfr.below_threshold" in str(e.value)

def test_coercion():
    m = ImagingOrder(patient_id="P", age_years=40, test_type="ContrastCT", eGFR=" 30 ")
    assert m.eGFR == 30.0
```

---

## 6.6 FastAPI Tip (auto-return friendly errors)

FastAPI reads Pydantic errors and returns structured 422s by default:

```python
from fastapi import FastAPI
app = FastAPI()

@app.post("/orders")
def create_order(order: ImagingOrder):
    # If we reach here, validation passed
    return {"ok": True, "test_type": order.test_type, "eGFR": order.eGFR}
```

Clients will get precise error locations and codes (your `PydanticCustomError` codes are preserved in the response detail), enabling automated fallbacks in an agentic workflow.

---

## 6.7 Pattern Recap (copy-paste checklist)

* Use **`field_validator`** to:

  * Coerce inputs (strings → numbers, trimming).
  * Enforce basic ranges (`age ≥ 0`, `0 ≤ probability ≤ 1`).

* Use **`model_validator`** to:

  * Enforce **conditional** rules (e.g., *if `test_type == ContrastCT` then `eGFR ≥ 30`*).
  * Enforce **mutual exclusivity** (e.g., exactly one of `mrn` or `passport_id`).
  * Enforce **temporal consistency** (e.g., `start_time < end_time`).

* Prefer **custom error codes** via `PydanticCustomError` for downstream agent handling.

---

## 6.8 Mini Exercise (for the reader)

Extend `ImagingOrder`:

1. Add `metformin_active: bool` and forbid `ContrastCT` if `metformin_active=True` **and** `eGFR < 45`, with code `metformin.contrast_guard`.

2. Add `repeat_window_hours: Optional[int]` and reject a **repeat** CT within 24h unless an extra flag `override_repeat: bool=True` is set.

> This mirrors real-world **safety guards** your triage/ordering agents must honor.

---

That’s it! With `field_validator` and `model_validator`, you can **centralize domain logic** inside your data contracts so every agent—no matter how it’s implemented—plays by the same clinical rules.

