# 12. Integrating Pydantic with FastAPI (Backend Layer for Agents)

When building **agentic systems**, FastAPI often serves as the **backend layer**. It acts as the entry point for incoming requests, validates payloads, and triggers workflows (e.g., via LangGraph or LangChain).
**Pydantic** plays a critical role in this integration because FastAPI relies on Pydantic models for automatic request validation and documentation.

---

## 12.1 Why Use Pydantic with FastAPI?

* **Seamless Validation**: FastAPI automatically validates request bodies using Pydantic models.
* **OpenAPI Auto-docs**: Endpoints are documented automatically at `/docs` (Swagger UI) and `/redoc`.
* **Consistency Across Agents**: Enforces structured input/output contracts for agent workflows.
* **Error Handling**: Invalid inputs raise `ValidationError` responses automatically.

---

## 12.2 Basic Example

Suppose we want an endpoint `/diagnosis` that accepts patient data and invokes a diagnostic agent.

```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List

# Step 1: Define input model with Pydantic
class DiagnosticInputModel(BaseModel):
    patient_id: str
    age: int
    symptoms: List[str]

# Step 2: Define output model
class DiagnosticOutputModel(BaseModel):
    patient_id: str
    probable_diagnosis: str
    confidence: float

# Step 3: Create FastAPI app
app = FastAPI(title="Agentic Diagnostic API")

# Step 4: Define endpoint using Pydantic models
@app.post("/diagnosis", response_model=DiagnosticOutputModel)
async def run_diagnosis(input_data: DiagnosticInputModel):
    # Here you would invoke a LangGraph or agent workflow
    # Example: result = diagnostic_agent.run(input_data.dict())
    result = {
        "patient_id": input_data.patient_id,
        "probable_diagnosis": "Influenza",
        "confidence": 0.87
    }
    return result
```

---

## 12.3 What Happens Automatically?

1. **Validation**

   * If `age` is negative or `symptoms` is not a list, FastAPI rejects the request with a 422 error.

2. **Documentation**

   * OpenAPI schema is auto-generated at `/openapi.json`.
   * Interactive Swagger docs are available at `/docs`.

3. **Serialization**

   * The output is validated and serialized according to `DiagnosticOutputModel`.

---

## 12.4 Example Workflow Integration

Imagine we connect this API to a **LangGraph pipeline**:

* Incoming request validated via `DiagnosticInputModel`.
* Queue Manager Agent receives the structured payload.
* Diagnostic Agent runs a reasoning pipeline.
* Output mapped into `DiagnosticOutputModel`.

This ensures **end-to-end type safety** and eliminates errors from malformed inputs.

```python
@app.post("/diagnosis", response_model=DiagnosticOutputModel)
async def run_diagnosis(input_data: DiagnosticInputModel):
    # Hypothetical LangGraph call
    workflow_result = await diagnosis_workflow.invoke(input_data.dict())
    
    return DiagnosticOutputModel(
        patient_id=input_data.patient_id,
        probable_diagnosis=workflow_result["diagnosis"],
        confidence=workflow_result["confidence"]
    )
```

---

## 12.5 Benefits for Agentic Systems

* **Reliable inter-agent communication** – consistent schemas validated at entry.
* **Scalable documentation** – auto-docs let developers and clinicians explore APIs quickly.
* **Reduced errors** – early validation avoids wasted compute cycles in expensive workflows.
* **Compliance-ready** – structured request/response logs useful for audits and healthcare regulations.

---

✅ **Example Recap**:
A hospital integrates a `/diagnosis` endpoint. When a patient check-in is submitted, the API ensures the input matches `DiagnosticInputModel`. Only after validation does it pass the request to the **LangGraph diagnostic workflow**. The output is guaranteed to follow the `DiagnosticOutputModel` schema before being returned.

---
