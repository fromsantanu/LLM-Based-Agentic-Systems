# 14. Advanced: Dynamic Models for Adaptive Agents

In large-scale agentic systems, data schemas are not always known at design time. An agent may need to **adapt its expected inputs and outputs dynamically** depending on the context.
For example, a diagnostic workflow might receive different sets of inputs depending on whether the patient presents with **chest pain, fever, or shortness of breath**. Instead of building hundreds of static models, Pydantic provides a way to **create models at runtime**.

This is possible using **`pydantic.create_model`**.

---

## 14.1 Why Dynamic Models?

* **Adaptive schemas**: Different agents (e.g., radiology vs. pathology) may require different fields.
* **Rule-driven validation**: A rule engine can enforce different constraints per complaint.
* **Interoperability**: Dynamic schemas can be exported as JSON Schema for external services (like LIS/HIS).

---

## 14.2 Creating Models at Runtime

Pydantic’s `create_model` lets you define a model programmatically.

```python
from pydantic import BaseModel, create_model, Field

# Example: dynamic model depending on complaint
def build_test_request_model(complaint: str):
    if complaint == "chest_pain":
        return create_model(
            "ChestPainTestRequestModel",
            ecg=(bool, Field(..., description="Is ECG required?")),
            troponin=(bool, Field(..., description="Is Troponin blood test required?")),
            age=(int, Field(..., ge=0, description="Patient age")),
        )
    elif complaint == "fever":
        return create_model(
            "FeverTestRequestModel",
            cbc=(bool, Field(..., description="Complete Blood Count required?")),
            blood_culture=(bool, Field(..., description="Blood culture required?")),
            temperature=(float, Field(..., description="Recorded body temperature")),
        )
    else:
        return create_model(
            "GenericTestRequestModel",
            notes=(str, Field(..., description="Free-text request notes")),
        )
```

---

## 14.3 Using the Dynamic Model

```python
# Complaint received from upstream agent
complaint = "chest_pain"

# Dynamically create model
TestRequestModel = build_test_request_model(complaint)

# Validate input using the generated schema
input_data = {
    "ecg": True,
    "troponin": False,
    "age": 55
}

validated = TestRequestModel(**input_data)
print(validated.dict())
```

**Output:**

```python
{'ecg': True, 'troponin': False, 'age': 55}
```

---

## 14.4 Integration in Adaptive Agents

Imagine an **AI-driven rule engine agent**:

1. The agent receives **chief complaint**: `"fever"`.
2. It calls `build_test_request_model("fever")`.
3. The agent then validates the incoming structured request from a nurse or triage agent.
4. Downstream agents (e.g., **LabOrderPlacer**) use the same dynamically built schema.

This ensures **flexibility** while still enforcing **structured validation**.

---

## 14.5 JSON Schema Export for Dynamic Models

You can export schema dynamically to share with other agents:

```python
FeverModel = build_test_request_model("fever")
print(FeverModel.model_json_schema())
```

This outputs a **JSON Schema** that external services (like HIS/LIS) can validate against.

---

## 14.6 Best Practices

* Use dynamic models **only when variability is high**. Otherwise, prefer static models for readability.
* Keep a **registry** of dynamic models to avoid accidental duplication.
* Document all possible variations, so external teams know which schemas may appear.
* Consider caching generated models for performance in high-throughput environments.

---

✅ **Key Takeaway**:
Dynamic models (`create_model`) allow **adaptive agents** to construct validation schemas at runtime. This makes it possible to design AI-driven rule engines that respond to changing clinical or operational contexts without losing the benefits of structured validation.

---
