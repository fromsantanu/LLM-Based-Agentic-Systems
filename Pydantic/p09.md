# 9. Data Serialization & Deserialization

In multi-agent systems, agents frequently need to **exchange data**—either with each other or with external systems like **APIs, databases, or electronic medical records (EMRs)**. For this reason, Pydantic provides powerful tools to **serialize** (convert Python objects into JSON or dictionaries) and **deserialize** (parse JSON or dictionaries into structured Python objects).

This chapter covers how to use `.dict()`, `.json()`, and parsing methods to ensure agents can seamlessly communicate in interoperable formats.

---

## 9.1 Serialization Basics

Serialization means **converting a Pydantic model into a transportable format**.

* `.dict()` → Produces a Python dictionary.
* `.json()` → Produces a JSON string.

```python
from pydantic import BaseModel

class PatientResult(BaseModel):
    patient_id: str
    test_type: str
    result_value: float
    unit: str

result = PatientResult(
    patient_id="P123",
    test_type="Blood Glucose",
    result_value=95.4,
    unit="mg/dL"
)

# Convert to dict
print(result.dict())

# Convert to JSON
print(result.json(indent=2))
```

**Output:**

```python
{'patient_id': 'P123', 'test_type': 'Blood Glucose', 'result_value': 95.4, 'unit': 'mg/dL'}

{
  "patient_id": "P123",
  "test_type": "Blood Glucose",
  "result_value": 95.4,
  "unit": "mg/dL"
}
```

---

## 9.2 Deserialization (Parsing Incoming Data)

Deserialization means **loading external data** (often from an API or EMR system) into a Pydantic model.

```python
# JSON received from external API
incoming_json = """
{
  "patient_id": "P123",
  "test_type": "Blood Glucose",
  "result_value": 95.4,
  "unit": "mg/dL"
}
"""

# Parse JSON into model
parsed_result = PatientResult.model_validate_json(incoming_json)
print(parsed_result)
print(type(parsed_result))   # <class '__main__.PatientResult'>
```

---

## 9.3 Pushing Results into an EMR (Practical Example)

Imagine we have a **ResultIngestionModel** that captures results from lab agents. We need to serialize it into JSON and push it into an EMR system via API.

```python
import requests
from pydantic import BaseModel

class ResultIngestionModel(BaseModel):
    patient_id: str
    order_id: str
    test_name: str
    result_value: str
    unit: str
    status: str

# Create result instance
result_data = ResultIngestionModel(
    patient_id="P123",
    order_id="O456",
    test_name="Creatinine",
    result_value="1.2",
    unit="mg/dL",
    status="final"
)

# Convert to JSON for EMR
json_payload = result_data.json()

# Push to EMR API
response = requests.post(
    "https://hospital-emr.example.com/api/results",
    data=json_payload,
    headers={"Content-Type": "application/json"}
)

print("Status Code:", response.status_code)
```

---

## 9.4 Handling Partial / Nested Data

External APIs often send **nested structures** or **extra fields**. Pydantic automatically validates and ignores unknown fields if configured.

```python
class PatientInfo(BaseModel):
    patient_id: str
    name: str

class ResultIngestionModel(BaseModel):
    patient: PatientInfo
    test_name: str
    value: float

# Incoming API JSON
incoming = {
    "patient": {"patient_id": "P123", "name": "John Doe"},
    "test_name": "HbA1c",
    "value": 6.2,
    "extra_field": "ignored"
}

parsed = ResultIngestionModel.model_validate(incoming)
print(parsed.dict())
```

---

## 9.5 Key Takeaways

* Use `.dict()` when sending data to Python-native systems (like databases, logging).
* Use `.json()` for **transport over APIs** or agent-to-agent communication.
* Use `model_validate()` or `model_validate_json()` to parse incoming dictionaries or JSON strings into Pydantic models.
* Nested models allow seamless parsing of **hierarchical API data**.

---

✅ **Example in Practice**: A **ResultIngestionModel** can be serialized into JSON and pushed to the **EMR** API, while parsing API responses back into models ensures safe, structured ingestion of clinical data.

---
