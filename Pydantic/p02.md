# 2. Defining Models for Agent Inputs and Outputs

In multi-agent systems, different agents communicate by passing structured information between them. To ensure reliability, consistency, and error-free communication, we need to strictly define the schema for both **inputs** (what an agent expects) and **outputs** (what it produces).

Pydantic’s `BaseModel` provides a robust way to enforce this structure, validate types, and make development predictable in complex workflows.

---

## 2.1 Using `BaseModel` to Enforce Structure

At the core of Pydantic lies the `BaseModel`. By subclassing it, we can define exactly what fields are required, what types they must have, and how defaults should be handled.

When an agent receives or produces data, it can be wrapped inside a `BaseModel` to guarantee it follows the schema before being passed along in the workflow.

**Example:**

```python
from pydantic import BaseModel
from typing import List

class DiagnosticAgentInput(BaseModel):
    symptoms: List[str]
    age: int
    priority: str
```

Here, any object created from `DiagnosticAgentInput` must contain:

* `symptoms`: a list of strings
* `age`: an integer
* `priority`: a string (e.g., "high", "medium", "low")

If invalid data is passed (e.g., `age="twenty"`), Pydantic will raise a validation error.

---

## 2.2 Required vs Optional Fields

Not all fields need to be required. Sometimes, agents can work with partial data, or some fields may only be filled in later.

We can use:

* **Optional** (from `typing`) → allows `None` values.
* **default_factory** → ensures a sensible default is generated at runtime (e.g., empty lists, timestamps).

**Example with optional and default values:**

```python
from typing import Optional
from datetime import datetime
from pydantic import BaseModel, Field

class DiagnosticAgentInput(BaseModel):
    symptoms: List[str]
    age: int
    priority: str
    notes: Optional[str] = None  # optional field
    created_at: datetime = Field(default_factory=datetime.utcnow)  # auto timestamp
```

* `notes` can be missing (`None` by default).
* `created_at` will automatically set the current time when the object is created.

This flexibility allows us to build robust models that adapt to evolving agent workflows.

---

## 2.3 Example: Input Schema for a Diagnostic Agent

Imagine we’re building a **Diagnostic Agent** in a hospital triage workflow.

The **input** model should capture patient symptoms and basic metadata:

```python
class DiagnosticAgentInput(BaseModel):
    symptoms: List[str]
    age: int
    priority: str
    notes: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
```

The **output** model might capture a preliminary assessment:

```python
class DiagnosticAgentOutput(BaseModel):
    probable_conditions: List[str]
    recommended_tests: List[str]
    urgency: str
```

### Usage Example:

```python
# Valid input
data = {
    "symptoms": ["fever", "cough"],
    "age": 45,
    "priority": "high"
}

input_model = DiagnosticAgentInput(**data)
print(input_model)

# Example output
output_model = DiagnosticAgentOutput(
    probable_conditions=["Flu", "COVID-19"],
    recommended_tests=["RT-PCR", "Chest X-ray"],
    urgency="high"
)
print(output_model)
```

This way, every step of the workflow has **clear contracts** for what data is being passed, making agentic systems easier to debug, scale, and maintain.

---

✅ **Key Takeaways**

* Use `BaseModel` to define strict input/output schemas.
* Use `Optional` for fields that may be missing.
* Use `default_factory` to generate defaults dynamically.
* Agent inputs and outputs should always be modeled for reliable communication.

---

