# 7. Handling Dynamic Data with Field, Alias, and Computed Fields

In agentic systems, data often flows in from multiple external sources—APIs, hospital databases, IoT devices, etc. These sources may not follow the same naming conventions or may omit derived attributes that are essential for downstream agents. Pydantic provides tools to handle these challenges gracefully:

* **`Field`** → Allows default values, descriptions, constraints, and aliases.
* **Aliases** → Enable models to accept data from external systems with different field names.
* **Computed fields** → Automatically derive attributes based on other data, ensuring consistency and reducing duplication.

---

## 7.1 Using `Field` for Metadata and Aliases

The `Field` function in Pydantic is used to add extra metadata to model attributes.
A common use case in agentic systems is aligning **external API field names** with your internal schema.

```python
from pydantic import BaseModel, Field

class ExternalPatient(BaseModel):
    patient_id: str = Field(alias="id")
    full_name: str = Field(alias="name")
    age: int

# Incoming API data
external_data = {
    "id": "P123",
    "name": "Alice Brown",
    "age": 45
}

patient = ExternalPatient(**external_data)
print(patient)  
# patient_id='P123' full_name='Alice Brown' age=45
```

Here, the API provides `id` and `name`, but internally we store them as `patient_id` and `full_name`.
This avoids rewriting external connectors whenever the naming is different.

---

## 7.2 Automatic Attribute Computation with `@computed_field`

Sometimes, external data contains **raw inputs**, and the system must **compute derived values**.
For example, a patient record may include **date of birth (dob)**, but downstream agents need **age** for triage.

Pydantic v2 introduces `@computed_field` for such scenarios.

```python
from datetime import date
from pydantic import BaseModel, computed_field

class PatientWithDOB(BaseModel):
    full_name: str
    dob: date

    @computed_field
    @property
    def age(self) -> int:
        today = date.today()
        return today.year - self.dob.year - (
            (today.month, today.day) < (self.dob.month, self.dob.day)
        )

patient = PatientWithDOB(full_name="John Doe", dob=date(1985, 9, 12))
print(patient.age)  # e.g., 40 (depending on current date)
```

This way, agents don’t need to redundantly calculate `age` each time—it’s automatically available whenever a `PatientWithDOB` object is created.

---

## 7.3 Combining Aliases and Computed Fields in Agent Workflows

Imagine a **triage agent** receiving data from a hospital’s Electronic Health Record (EHR) API:

* API provides fields: `"id"`, `"dob"`, `"symptoms"`
* Internally, your system expects: `patient_id`, `age`, `symptoms`

You can map and compute everything in one model:

```python
from typing import List

class TriageInput(BaseModel):
    patient_id: str = Field(alias="id")
    dob: date
    symptoms: List[str]

    @computed_field
    @property
    def age(self) -> int:
        today = date.today()
        return today.year - self.dob.year - (
            (today.month, today.day) < (self.dob.month, self.dob.day)
        )

# External API input
api_payload = {
    "id": "P456",
    "dob": "1990-02-15",
    "symptoms": ["fever", "cough"]
}

triage_case = TriageInput(**api_payload)
print(triage_case)
# patient_id='P456' dob=datetime.date(1990, 2, 15) symptoms=['fever', 'cough'] age=35
```

Now your **Triage Agent** can directly use `age` for urgency classification, even though the external system never sent it.

---

## 7.4 Why This Matters for Agentic Systems

* **Seamless integration** → Agents can accept raw data from various APIs without rewriting logic.
* **Consistency** → Derived attributes (like `age`) are computed once, avoiding repeated calculation errors.
* **Flexibility** → Internal models can evolve independently from external data formats.

This pattern is especially useful in healthcare agent systems, where external EHRs, lab systems, or insurance APIs all use slightly different schemas. With `Field`, `alias`, and `computed_field`, your agents can standardize and enrich incoming data automatically.

---

✅ **Key Takeaway**: Use **aliases** for smooth API integration and **computed fields** for derived values. This makes your agent pipeline more robust, future-proof, and domain-aware.

---
