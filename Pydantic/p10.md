# 10. Error Handling & Custom Exceptions

In multi-agent workflows, **error handling is critical**. When multiple agents exchange structured data, one faulty input or rule violation can break the entire pipeline. Pydantic helps us **catch and communicate validation errors early**, ensuring that agents downstream can handle them gracefully.

---

## 10.1 ValidationError in Agent Pipelines

Whenever data fails to meet the defined schema, Pydantic raises a `ValidationError`.
Instead of crashing the pipeline, these errors can be intercepted and converted into **structured responses** for the next agent.

### Example: Validation Failure

```python
from pydantic import BaseModel, ValidationError, Field

class InsuranceRequest(BaseModel):
    patient_id: str
    insurance_id: str
    amount: float = Field(gt=0, description="Amount must be positive")

# Simulate invalid input
try:
    request = InsuranceRequest(patient_id="P123", insurance_id="INS456", amount=-500)
except ValidationError as e:
    print("Validation failed:", e.json())
```

**Output (structured error in JSON):**

```json
[
  {
    "loc": ["amount"],
    "msg": "ensure this value is greater than 0",
    "type": "value_error.number.not_gt",
    "ctx": {"limit_value": 0}
  }
]
```

This ensures **traceable, machine-readable errors** that agents can act upon.

---

## 10.2 Using Custom Exceptions for Domain Rules

Not all errors are just schema issues. Many are **business logic violations** that require **custom exceptions**.

### Example: Compliance Agent Rejecting Requests

```python
from pydantic import BaseModel, ValidationError

class TreatmentRequest(BaseModel):
    patient_id: str
    insurance_covered: bool
    procedure_code: str

class ComplianceError(Exception):
    def __init__(self, message: str, code: str):
        self.message = message
        self.code = code
        super().__init__(message)

def compliance_check(request: TreatmentRequest):
    if not request.insurance_covered:
        raise ComplianceError(
            message="Insurance rules not met. Procedure not covered.",
            code="INSURANCE_DENIED"
        )
    return {"status": "approved"}

# Example usage
try:
    req = TreatmentRequest(patient_id="P101", insurance_covered=False, procedure_code="CT123")
    result = compliance_check(req)
except ComplianceError as ce:
    error_response = {"error": ce.message, "code": ce.code}
    print(error_response)
```

**Output (structured response):**

```json
{
  "error": "Insurance rules not met. Procedure not covered.",
  "code": "INSURANCE_DENIED"
}
```

This allows the **Queue Manager** or **Orchestration Layer** to send a clear rejection message back to the requester.

---

## 10.3 Best Practices in Error Handling

1. **Catch early** → Validate at each agent boundary before forwarding data.
2. **Structured responses** → Always format errors as JSON/dicts, never raw strings.
3. **Custom codes** → Define domain-specific error codes (`INSURANCE_DENIED`, `INVALID_AGE`, etc.) to help downstream agents.
4. **Graceful degradation** → If one step fails, the pipeline should either retry, skip, or provide fallback logic.
5. **Audit logging** → Store error details for compliance and debugging.

---

## 10.4 Example in an Agent Pipeline

Imagine a **ComplianceAgent** in a healthcare triage system:

* Patient request → QueueManager → ComplianceAgent
* If insurance doesn’t cover the requested procedure:

  * Raise `ComplianceError`
  * Return structured error response to orchestrator
  * Orchestrator informs patient/doctor UI about rejection

```python
def pipeline_handler(request_data: dict):
    try:
        request = TreatmentRequest(**request_data)
        return compliance_check(request)
    except (ValidationError, ComplianceError) as e:
        if isinstance(e, ValidationError):
            return {"error": "Validation failed", "details": e.errors()}
        elif isinstance(e, ComplianceError):
            return {"error": e.message, "code": e.code}
```

**Output on failure:**

```json
{
  "error": "Validation failed",
  "details": [
    {
      "loc": ["insurance_covered"],
      "msg": "field required",
      "type": "value_error.missing"
    }
  ]
}
```

---

✅ **Takeaway**:
Pydantic’s built-in `ValidationError` plus custom domain exceptions let you build **resilient, transparent agent pipelines**. Instead of silent failures or messy logs, each agent can return **clear, structured errors**, improving traceability, compliance, and user experience.

---

