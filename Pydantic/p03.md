# 3. Validation in Multi-Agent Communication

When agents communicate with each other, **data integrity** is critical. A single malformed field—say, a negative age or a string where an integer is expected—can cause downstream failures. Pydantic provides robust validation features that help ensure safe and predictable communication between agents.

---

## Automatic Type Conversion

Pydantic models automatically convert compatible types.
For example, if an agent receives a request with `"age": "42"` (a string), Pydantic will convert it into an integer before passing it along.

```python
from pydantic import BaseModel

class PatientInfo(BaseModel):
    name: str
    age: int   # Will auto-convert "42" → 42

# Example incoming agent message
data = {"name": "Alice", "age": "42"}
patient = PatientInfo(**data)

print(patient)  
# name='Alice' age=42
print(type(patient.age))  
# <class 'int'>
```

This ensures smoother agent-to-agent communication, even when data types are loosely defined at the source.

---

## Custom Validators for Domain Logic

Sometimes, automatic type conversion is not enough. We need **domain-specific validation rules**.
For example, no patient should have a negative age.

Pydantic supports this via **validators** (in v1) or the new `field_validator` (in v2).

### Example: Enforcing Age Constraint

```python
from pydantic import BaseModel, field_validator

class TreatmentRequest(BaseModel):
    symptoms: list[str]
    age: int
    priority: str

    # Custom validator for age
    @field_validator("age")
    def age_must_be_non_negative(cls, v):
        if v < 0:
            raise ValueError("Age must be >= 0")
        return v
```

Now, if a malformed request enters the pipeline:

```python
# Valid request
req = TreatmentRequest(symptoms=["cough"], age=30, priority="high")
print(req)

# Invalid request
bad_req = TreatmentRequest(symptoms=["fever"], age=-5, priority="low")
# Raises: ValidationError: Age must be >= 0
```

---

## Example: Validation Before Passing to TreatmentAgent

Consider a workflow where the **DiagnosticAgent** forwards validated requests to the **TreatmentAgent**:

```python
class DiagnosticAgent:
    def process(self, data: dict):
        try:
            request = TreatmentRequest(**data)
            return self.forward_to_treatment_agent(request)
        except Exception as e:
            return {"error": str(e)}

    def forward_to_treatment_agent(self, request: TreatmentRequest):
        # Only valid requests reach here
        return {
            "agent": "TreatmentAgent",
            "action": "process_request",
            "data": request.dict()
        }

# Example usage
diagnostic = DiagnosticAgent()

# Valid input
print(diagnostic.process({"symptoms": ["cough"], "age": "25", "priority": "high"}))

# Invalid input
print(diagnostic.process({"symptoms": ["fever"], "age": -2, "priority": "low"}))
```

---

## Why This Matters in Multi-Agent Systems

* **Fault Isolation**: Invalid inputs are caught early, preventing system-wide errors.
* **Agent Reliability**: Each agent can trust the data it receives.
* **Domain Safety**: Rules like “age ≥ 0” or “priority ∈ {low, medium, high}” enforce consistency across the workflow.

---

✅ **Key Takeaway**: Pydantic’s automatic type conversions handle the easy cases, while custom validators safeguard domain rules. Together, they create a **trustworthy communication channel between agents** in complex workflows.

---
