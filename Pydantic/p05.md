# 5. Enums for Controlled Agent Decisions

Enums give your agents *tight*, auditable control over choices (routing, urgency, tool selection, policy outcomes). Instead of passing loose strings, you pass **typed** values with a small, explicit domain—making your pipeline more robust, explainable, and easy to test.

---

## Why Enums in agent workflows?

* **Safety & clarity:** Only allowed values pass through (no `"hgh"` instead of `"high"`).
* **Stable contracts:** Agents and services agree on the same vocabulary.
* **Explainability:** Easy to attach rationales and map to UI labels.
* **Schema & docs:** Clean JSON Schema/OpenAPI for FastAPI endpoints.

---

## Choosing the right Enum kind

* `enum.Enum` – canonical enum; members can be any constant type.
* `enum.StrEnum` (Python 3.11+) – string enums that *are* `str` (great for JSON, FastAPI).
* `enum.IntEnum` – for rank/ordering semantics.
* `typing.Literal` – simplest when you don’t need methods or reuse.

**Guideline:** Prefer `StrEnum` for API-facing choices; `IntEnum` for sortable severity; `Literal` for quick one-offs.

---

## Core example: Triage urgency

```python
from enum import StrEnum, auto
from pydantic import BaseModel, Field

class TriageLevel(StrEnum):
    LOW = auto()     # "LOW"
    MEDIUM = auto()  # "MEDIUM"
    HIGH = auto()    # "HIGH"

class TriageDecision(BaseModel):
    level: TriageLevel = Field(..., description="Urgency classification")
    rationale: str

# Usage
payload = {"level": "HIGH", "rationale": "Chest pain with hypotension"}
decision = TriageDecision(**payload)
assert decision.level is TriageLevel.HIGH
```

### Prefer human-friendly values

`auto()` with `StrEnum` yields member names; if you want lowercase wire values:

```python
from enum import Enum

class TriageLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
```

This keeps JSON compact and pretty.

---

## Validating external inputs (case/alias tolerant)

Agents ingest messy strings. Normalize once at the boundary:

```python
from pydantic import BaseModel, field_validator

class TriageDecision(BaseModel):
    level: TriageLevel
    rationale: str

    @field_validator("level", mode="before")
    @classmethod
    def normalize_level(cls, v):
        if isinstance(v, TriageLevel):
            return v
        s = str(v).strip().lower()
        mapping = {
            "l": "low", "low": "low",
            "m": "medium", "med": "medium", "medium": "medium",
            "h": "high", "hi": "high", "high": "high"
        }
        if s in mapping:
            return TriageLevel(mapping[s])
        raise ValueError(f"Unknown triage level: {v!r}")
```

---

## Example: Agent routing with Enum

```python
from enum import StrEnum
from pydantic import BaseModel

class Route(StrEnum):
    DIAGNOSTICS = "diagnostics"
    IMAGING = "imaging"
    CRITICAL_CARE = "critical_care"

class QueueItem(BaseModel):
    triage: TriageLevel
    next_route: Route

def route_policy(triage: TriageLevel) -> Route:
    match triage:
        case TriageLevel.HIGH:
            return Route.CRITICAL_CARE
        case TriageLevel.MEDIUM:
            return Route.DIAGNOSTICS
        case _:
            return Route.IMAGING

item = QueueItem(triage=TriageLevel.HIGH, next_route=route_policy(TriageLevel.HIGH))
```

---

## Example: Compliance decisions with IntEnum (sortable)

```python
from enum import IntEnum
from pydantic import BaseModel

class ComplianceScore(IntEnum):
    FAIL = 0
    WARN = 1
    PASS = 2

class ComplianceResult(BaseModel):
    score: ComplianceScore
    details: list[str] = []

def gatekeep(score: ComplianceScore) -> bool:
    return score >= ComplianceScore.PASS

assert gatekeep(ComplianceScore.PASS) is True
```

---

## Bundling decisions in nested models (hierarchical agents)

```python
from pydantic import BaseModel

class PatientInfo(BaseModel):
    age: int
    chief_complaint: str

class QueueManagerOutput(BaseModel):
    patient: PatientInfo
    triage: TriageLevel
    route: Route
```

Enums make these outputs **contracted** and **machine-checkable** across agent boundaries.

---

## FastAPI integration (clean docs & validation)

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class TriageRequest(BaseModel):
    patient_id: str
    symptoms: list[str]

class TriageResponse(BaseModel):
    level: TriageLevel
    rationale: str

@app.post("/triage", response_model=TriageResponse)
def triage(req: TriageRequest) -> TriageResponse:
    level = TriageLevel.HIGH if "chest pain" in " ".join(req.symptoms).lower() else TriageLevel.LOW
    return TriageResponse(level=level, rationale="Rule-based preliminary triage")
```

OpenAPI will show the enum values automatically—great for client generation and QA.

---

## Literals vs Enums (quick check)

```python
from typing import Literal
from pydantic import BaseModel

Urgency = Literal["low", "medium", "high"]

class LiteDecision(BaseModel):
    level: Urgency
```

Use `Literal` for lightweight, single-use constraints. Use `Enum` when:

* you need methods/attributes,
* values are reused across models/services,
* you want richer semantics (ordering, mapping, display names).

---

## UX labels, telemetry keys, and persistence

Keep wire values stable, add display text separately:

```python
DISPLAY = {
    TriageLevel.LOW: "Low (Green)",
    TriageLevel.MEDIUM: "Medium (Amber)",
    TriageLevel.HIGH: "High (Red)",
}

def to_display(level: TriageLevel) -> str:
    return DISPLAY[level]
```

Log with enum `.value` to keep analytics tidy:

```python
log_event("triage_assigned", {"level": decision.level.value})
```

---

## Anti-patterns to avoid

* ❌ Free-form strings in contracts (`"urgent"`, `"hgh"`).
* ❌ Changing enum **values** after release (breaks stored data & clients). If you must rename, change the **member name** but keep the **value**.
* ❌ Overloading a single enum for unrelated concepts (split into smaller enums).

---

## Testing enums (quick patterns)

```python
def test_triage_accepts_aliases():
    d = TriageDecision(level="HI", rationale="test")
    assert d.level is TriageLevel.HIGH

def test_openapi_includes_enum_values():
    from fastapi.testclient import TestClient
    client = TestClient(app)
    schema = client.get("/openapi.json").json()
    # Assert enum values appear under TriageResponse
```

---

## Migration tips (Pydantic v2)

* Validators → use `@field_validator(..., mode="before")` to normalize inbound text.
* JSON Schema: Pydantic emits enum values automatically; prefer `StrEnum` for clean schemas.
* For backward compatibility, accept legacy strings in the validator and map to the new enum.

---

## Quick reference: patterns you’ll reuse

* **Urgency**: `TriageLevel = Enum("TriageLevel", {"LOW":"low", "MEDIUM":"medium", "HIGH":"high"})`
* **Routing**: `Route(StrEnum)` for service names (`"diagnostics" | "imaging" | "critical_care"`).
* **Decision gates**: `IntEnum` for sortable thresholds (`FAIL < WARN < PASS`).
* **Temporary constants**: `Literal[...]` inside one model.

---

## Mini end-to-end snippet

```python
from enum import StrEnum
from pydantic import BaseModel, field_validator

class TriageLevel(StrEnum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"

class TriageDecision(BaseModel):
    level: TriageLevel
    rationale: str

    @field_validator("level", mode="before")
    @classmethod
    def norm(cls, v):
        return str(v).strip().lower()

def triage_agent(symptoms: list[str]) -> TriageDecision:
    text = " ".join(symptoms).lower()
    if "chest pain" in text or "shortness of breath" in text:
        return TriageDecision(level="HIGH", rationale="Cardio red flags")
    if "fever" in text and "rash" in text:
        return TriageDecision(level="MEDIUM", rationale="Possible dengue; needs labs")
    return TriageDecision(level="LOW", rationale="No red flags detected")

# >>> triage_agent(["Fever", "Rash"]).level -> TriageLevel.MEDIUM
```

With Enums, your agents stop “guessing” strings and start exchanging **precise**, **typed** decisions—exactly what you want in production-grade, multi-agent systems.

