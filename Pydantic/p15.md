# 15. Case Study: Agentic Hospital Workflow

So far, we have explored Pydantic in isolation and in modular agentic settings. In this chapter, we combine everything into a **full hospital workflow pipeline**, showing how structured models can enforce consistency and reliability from the moment a patient arrives at the hospital queue until a validated treatment plan is produced.

This example mimics a **triage-to-treatment pipeline** in a busy hospital, where multiple agents communicate via validated contracts.

---

## 15.1 Workflow Overview

1. **Queue Manager Agent**

   * Accepts patient registration.
   * Ensures demographic and insurance details are correct.
   * Uses `QueueManagerModel` for validation.

2. **Translator Agent**

   * Parses free-text complaints into structured fields (symptoms, duration, severity).
   * Uses `TranslatorModel` to enforce schema.

3. **Diagnostic Agent**

   * Validates clinical logic: symptoms + test requests.
   * Uses `DiagnosticModel` with domain-specific validators.

4. **Treatment Planner Agent**

   * Generates plan only if constraints are met (drug/test rules, safety checks).
   * Uses `TreatmentPlanModel` to enforce medical guidelines.

---

## 15.2 Models in Action

### QueueManagerModel

```python
from pydantic import BaseModel, Field, field_validator
from typing import Optional

class QueueManagerModel(BaseModel):
    patient_id: str = Field(..., description="Unique hospital ID")
    name: str
    age: int
    insurance_id: Optional[str]

    @field_validator("age")
    def check_age(cls, v):
        if v < 0:
            raise ValueError("Age cannot be negative")
        return v
```

---

### TranslatorModel

```python
from pydantic import BaseModel, Field
from typing import List

class TranslatorModel(BaseModel):
    chief_complaint: str
    symptoms: List[str]
    duration_days: int = Field(..., ge=0)
    severity: str = Field(..., description="mild | moderate | severe")
```

---

### DiagnosticModel

```python
from pydantic import BaseModel, field_validator
from typing import List

class DiagnosticModel(BaseModel):
    symptoms: List[str]
    tests_requested: List[str]

    @field_validator("tests_requested")
    def ensure_relevant_tests(cls, v, values):
        if "chest_pain" in values.get("symptoms", []) and "ECG" not in v:
            raise ValueError("Chest pain requires ECG")
        return v
```

---

### TreatmentPlanModel

```python
from pydantic import BaseModel, Field, model_validator
from typing import List

class TreatmentPlanModel(BaseModel):
    diagnosis: str
    medications: List[str]
    follow_up_days: int = Field(..., gt=0)

    @model_validator(mode="after")
    def check_rules(self):
        if "ibuprofen" in self.medications and self.diagnosis == "gastric_ulcer":
            raise ValueError("NSAIDs contraindicated in gastric ulcer")
        return self
```

---

## 15.3 Example Workflow Execution

```python
# Step 1: Registration
patient = QueueManagerModel(
    patient_id="H123",
    name="Alice Johnson",
    age=45,
    insurance_id="INS-999"
)

# Step 2: Translate raw text into structured schema
translated = TranslatorModel(
    chief_complaint="Severe chest pain for 2 days",
    symptoms=["chest_pain", "shortness_of_breath"],
    duration_days=2,
    severity="severe"
)

# Step 3: Diagnostic validation
diagnostic = DiagnosticModel(
    symptoms=translated.symptoms,
    tests_requested=["ECG", "Troponin"]
)

# Step 4: Treatment planning
treatment = TreatmentPlanModel(
    diagnosis="acute_coronary_syndrome",
    medications=["aspirin", "atorvastatin"],
    follow_up_days=7
)

print(patient)
print(translated)
print(diagnostic)
print(treatment)
```

---

## 15.4 How This Reflects an Agentic System

* **QueueManagerAgent** ensures every patient entering the system has valid structured data.
* **TranslatorAgent** enforces semantic consistency between raw clinical notes and structured schema.
* **DiagnosticAgent** validates that medical reasoning holds before costly or dangerous tests are ordered.
* **TreatmentPlannerAgent** acts as a rule engine to enforce clinical guidelines and safety constraints.

This setup demonstrates how **Pydantic-powered contracts** prevent errors, enforce compliance, and guarantee predictable interactions in multi-agent healthcare workflows.

---

✅ With this case study, we have connected all building blocks—from basic validation to advanced domain-specific logic—into one end-to-end agentic workflow.

---
