# 4. Nested Models for Hierarchical Agents

In agentic systems, data often flows through multiple layers of agents, each refining or enriching the request. To keep this flow manageable, **nested models** are crucial. Instead of keeping everything flat, we can compose models inside other models, mirroring the hierarchy of agents in the system.

This approach makes data pipelines easier to maintain, validates each layer independently, and allows us to represent complex agent workflows in a structured way.

---

## 4.1 Composing Models Inside Models

Pydantic models can contain other Pydantic models as fields. This allows us to represent **hierarchical data structures** naturally.

For example, suppose we want to represent a patient along with the compliance results of their request:

```python
from pydantic import BaseModel
from typing import List

class PatientInfo(BaseModel):
    name: str
    age: int
    symptoms: List[str]

class ComplianceResult(BaseModel):
    passed: bool
    issues: List[str]

class QueueManagerOutput(BaseModel):
    patient: PatientInfo
    compliance: ComplianceResult
```

Here:

* `PatientInfo` is responsible for patient-related data.
* `ComplianceResult` represents validation or compliance checks.
* `QueueManagerOutput` composes both, giving us a nested representation.

---

## 4.2 Handling Complex Agent Pipelines

Agent workflows are rarely linear. They often involve **multiple stages**, where outputs from one agent become inputs for another. Nested models help ensure each stage **encapsulates only its responsibility** while still being interoperable with the larger pipeline.

Example pipeline:

1. **IntakeAgent** → Collects `PatientInfo`.
2. **ComplianceChecker** → Produces `ComplianceResult`.
3. **QueueManager** → Outputs a combined `QueueManagerOutput`.

```python
# IntakeAgent produces PatientInfo
patient = PatientInfo(name="Alice", age=42, symptoms=["fever", "cough"])

# ComplianceChecker validates PatientInfo
compliance = ComplianceResult(passed=True, issues=[])

# QueueManager composes both
output = QueueManagerOutput(patient=patient, compliance=compliance)

print(output.model_dump())
```

Output:

```json
{
  "patient": {
    "name": "Alice",
    "age": 42,
    "symptoms": ["fever", "cough"]
  },
  "compliance": {
    "passed": true,
    "issues": []
  }
}
```

This mirrors a real-world hospital triage flow, where multiple agents contribute structured data that is passed downstream.

---

## 4.3 Benefits of Nested Models

* **Clarity**: Each model represents a distinct concept (patient vs compliance vs system output).
* **Validation at Each Layer**: Errors can be caught where they originate.
* **Scalability**: Easy to extend with more fields or nested layers (e.g., adding insurance info or lab test results).
* **Serialization**: Nested models serialize naturally to JSON or dicts, ideal for APIs.

---

## 4.4 Extended Example: Hierarchical Agent Workflow

Let’s extend the example to include an additional layer: a **DiagnosticAgent** that takes the `QueueManagerOutput` and adds preliminary analysis.

```python
class DiagnosticResult(BaseModel):
    probable_conditions: List[str]
    recommendation: str

class DiagnosticAgentOutput(BaseModel):
    queue_output: QueueManagerOutput
    diagnosis: DiagnosticResult
```

Now, the pipeline looks like this:

```python
diagnosis = DiagnosticResult(
    probable_conditions=["Influenza", "Viral Infection"],
    recommendation="Perform lab tests to confirm diagnosis"
)

diag_output = DiagnosticAgentOutput(
    queue_output=output,
    diagnosis=diagnosis
)

print(diag_output.model_dump(indent=2))
```

Output:

```json
{
  "queue_output": {
    "patient": {
      "name": "Alice",
      "age": 42,
      "symptoms": ["fever", "cough"]
    },
    "compliance": {
      "passed": true,
      "issues": []
    }
  },
  "diagnosis": {
    "probable_conditions": ["Influenza", "Viral Infection"],
    "recommendation": "Perform lab tests to confirm diagnosis"
  }
}
```

---

## 4.5 Summary

* Nested models are essential for **hierarchical agent design**.
* They allow complex pipelines to be expressed cleanly and validated at each stage.
* Composing models mirrors real-world agent workflows in domains like healthcare, logistics, or finance.

In the next chapter, we’ll explore **validation logic across multiple agents** to ensure data integrity and domain-specific correctness in hierarchical systems.

---
