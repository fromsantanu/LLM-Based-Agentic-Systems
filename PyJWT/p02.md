# **Lesson 2 — Encoding Tokens with PyJWT**

## What does “encode a token” mean?

“Encoding” a JWT means **creating** a signed string that safely carries some data (called *claims*), like *who the user is* and *when the token expires*. The signature lets the server verify the token wasn’t tampered with.

---

## 1) The one-line API

```python
jwt.encode(payload, key, algorithm="HS256")
```

* **payload**: a Python dict — the data/claims you want to put inside the token.
* **key**: what you sign with (a secret or a private key).
* **algorithm**: how you sign (e.g., `"HS256"` or `"RS256"`).

> In PyJWT v2+, `encode(...)` returns a **string** (the JWT).

---

## 2) Secrets & algorithms (HS256 vs RS256)

* **HS256 (HMAC + SHA-256)**:

  * Uses **one shared secret** (same key to sign and later verify).
  * Simple, fast. Keep the secret safe on the server.
* **RS256 (RSA + SHA-256)**:

  * Uses a **private key** to sign and a **public key** to verify.
  * Good when multiple services need to verify but should not be able to sign.

**Where to keep keys?**

* Put secrets/keys in environment variables or files not committed to Git.
* Example:

  * `.env` → `JWT_SECRET=super-long-random-string`
  * For RS256, store `private.pem` and `public.pem` securely.

---

## 3) Common claims you’ll add

* **`sub`** (subject): *who* the token is about (often a user id or email).
* **`iat`** (issued at): when the token was created (seconds since epoch).
* **`exp`** (expiration): when the token should stop working (seconds since epoch).

> Tip: Use **UTC** and integer timestamps for `iat`/`exp`.

---

## 4) A tiny helper to create tokens

```python
from datetime import datetime, timedelta, timezone
import os
import jwt  # pip install PyJWT

SECRET_KEY = os.getenv("JWT_SECRET", "dev-only-secret")  # replace in prod
ALGORITHM = "HS256"

def create_access_token(
    subject: str,
    expires_minutes: int = 30,
    extra_claims: dict | None = None
) -> str:
    now = datetime.now(timezone.utc)
    payload = {
        "sub": subject,                         # who the token is about
        "iat": int(now.timestamp()),            # issued at
        "exp": int((now + timedelta(minutes=expires_minutes)).timestamp()),
    }
    if extra_claims:
        payload.update(extra_claims)
    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
    return token
```

---

## 5) FastAPI: generate a token after login (demo)

Paste this into a file like `main.py` and run `uvicorn main:app --reload`.

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from datetime import datetime, timedelta, timezone
import os
import jwt

# ====== config ======
SECRET_KEY = os.getenv("JWT_SECRET", "dev-only-secret")
ALGORITHM = "HS256"

# ====== helpers ======
def create_access_token(subject: str, minutes: int = 60, extra: dict | None = None) -> str:
    now = datetime.now(timezone.utc)
    payload = {
        "sub": subject,
        "iat": int(now.timestamp()),
        "exp": int((now + timedelta(minutes=minutes)).timestamp()),
    }
    if extra:
        payload.update(extra)
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

# ====== demo app ======
app = FastAPI()

# pretend DB
FAKE_USERS = {
    "alice@example.com": {"id": "u1", "password": "secret123", "role": "doctor"},
}

class LoginIn(BaseModel):
    email: str
    password: str

class TokenOut(BaseModel):
    access_token: str
    token_type: str = "bearer"

@app.post("/login", response_model=TokenOut)
def login(body: LoginIn):
    user = FAKE_USERS.get(body.email)
    if not user or user["password"] != body.password:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    token = create_access_token(
        subject=user["id"],
        minutes=60,
        extra={"role": user["role"]}  # put any extra claims you like
    )
    return {"access_token": token, "token_type": "bearer"}
```

Try it in **Swagger UI** at `http://127.0.0.1:8000/docs` → `POST /login` with:

```json
{ "email": "alice@example.com", "password": "secret123" }
```

You’ll get a JWT string back.

---

## 6) RS256 version (optional)

If you want RS256, load keys like this:

```python
with open("private.pem", "rb") as f:
    PRIVATE_KEY = f.read()
with open("public.pem", "rb") as f:
    PUBLIC_KEY = f.read()

token = jwt.encode(payload, PRIVATE_KEY, algorithm="RS256")
# Later for verification (in another service), use PUBLIC_KEY.
```

---

## 7) Quick checklist

* [ ] Use **UTC** timestamps.
* [ ] Keep secrets/keys **out of code** (use env or secret manager).
* [ ] Set a **short exp** for access tokens (e.g., 15–60 min).
* [ ] Put only non-sensitive data in payload (JWT is readable by anyone).

---

# 8) Mini exercise

1. Change the expiry to 15 minutes.
2. Add an extra claim: `"plan": "standard"`.
3. Return both the token and a `"expires_in": 900` field from `/login`.



