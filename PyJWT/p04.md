# Lesson 4: Integrating JWT Authentication in FastAPI 

In this lesson, you’ll connect all the pieces so your FastAPI app can **read a JWT from the request**, **check it**, and **allow or block** access to routes.

---

## 1) What comes in the request?

When a user is logged in, the browser/app sends a header like:

```
Authorization: Bearer <your-JWT-token-here>
```

* **Authorization** is the header name.
* **Bearer** just means “I’m sending a token”.
* The text after **Bearer** is the actual JWT.

---

## 2) Plan: the “current user” dependency

We’ll create a small function called `get_current_user()`:

* It **reads** the header.
* It **pulls out** the token.
* It **decodes** the token using PyJWT and your secret key.
* It **loads** the user info (e.g., from the token’s `sub` or a tiny in-memory “database”).
* If anything is wrong (missing header, bad token, expired token), it raises **401 Unauthorized**.

Then, any route that needs login can simply do:

```py
@app.get("/me")
def read_me(current_user: dict = Depends(get_current_user)):
    return current_user
```

If the token is valid, `current_user` will contain the user’s info. If not, FastAPI returns 401 for you.

---

## 3) Drop-in example (copy/paste friendly)

> **Files used:** a single `main.py` is enough for this lesson.

```python
# main.py
from fastapi import FastAPI, Depends, Header, HTTPException, status
from fastapi.responses import JSONResponse
import jwt
from jwt import ExpiredSignatureError, InvalidTokenError

app = FastAPI()

# ===== Settings (match these with what you used when encoding) =====
SECRET_KEY = "CHANGE_ME_TO_A_LONG_RANDOM_SECRET"
ALGORITHM = "HS256"

# A tiny fake user store for demo
fake_users_db = {
    "alice": {"username": "alice", "full_name": "Alice Johnson", "role": "doctor"},
    "bob":   {"username": "bob",   "full_name": "Bob Singh",     "role": "staff"},
}

def get_current_user(authorization: str | None = Header(default=None)):
    """
    1) Read 'Authorization' header.
    2) Extract token after 'Bearer '.
    3) Decode & verify the token.
    4) Return user info.
    """
    auth_error = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Not authenticated",
        headers={"WWW-Authenticate": "Bearer"},
    )

    # 1) Must have the header
    if not authorization:
        raise auth_error

    # 2) Must start with "Bearer "
    prefix = "Bearer "
    if not authorization.startswith(prefix):
        raise auth_error

    token = authorization[len(prefix):].strip()
    if not token:
        raise auth_error

    # 3) Decode & verify
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        # Commonly we store username/user_id in 'sub'
        username: str | None = payload.get("sub")
        if not username:
            raise auth_error
    except ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token expired",
            headers={"WWW-Authenticate": "Bearer"},
        )
    except InvalidTokenError:
        raise auth_error

    # 4) Fetch user info (from DB or cache). Here, a demo dict.
    user = fake_users_db.get(username)
    if not user:
        # Token was valid but user no longer exists
        raise auth_error

    return user


# ===== Protected routes =====

@app.get("/me")
def read_me(current_user: dict = Depends(get_current_user)):
    """Return the logged-in user's profile."""
    return {"message": "You are authenticated", "user": current_user}


@app.get("/items")
def list_items(current_user: dict = Depends(get_current_user)):
    """Only logged-in users can see this."""
    demo_items = [
        {"id": 1, "name": "Stethoscope"},
        {"id": 2, "name": "BP Monitor"},
    ]
    return {"user": current_user["username"], "items": demo_items}


# ===== (Optional) Simple role guard example =====
def require_role(role: str):
    def checker(user: dict = Depends(get_current_user)):
        if user.get("role") != role:
            raise HTTPException(status_code=403, detail="Forbidden: insufficient role")
        return user
    return checker

@app.get("/admin/secret")
def admin_only(user: dict = Depends(require_role("doctor"))):
    return {"note": "Only doctors can see this.", "user": user}
```

---

## 4) How do I test this?

1. **Start the app**

   ```bash
   uvicorn main:app --reload
   ```

2. **Use a valid token** (from Lesson 2/3). Suppose it contains `{"sub": "alice", "exp": ...}` and was signed with the same `SECRET_KEY` and `ALGORITHM`.

3. **Call a protected route** with the header:

   ```bash
   curl -H "Authorization: Bearer <PASTE_YOUR_TOKEN>" http://127.0.0.1:8000/me
   ```

   * If the token is good → you’ll get your user info.
   * If it’s missing/invalid/expired → you’ll get **401**.

> Tip: You can also try it in the built-in docs at `/docs`. Click the lock icon, paste `Bearer <token>` into the **Authorize** modal.

---

## 5) What did we achieve?

* A **simple, reusable dependency** (`get_current_user`) that every secure route can use.
* Clean **401** errors when the token is missing/expired/invalid.
* An easy path to **role-based access** if you need it later.



