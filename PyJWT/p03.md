# **Lesson 3: Decoding and Verifying Tokens**

When a user logs in, your FastAPI app creates a **JWT token** using PyJWT.
Now, when that user makes another request (like visiting a protected page),
you must **decode and verify** the token to make sure it’s still valid and trusted.
That’s what we’ll learn here.

---

### **1. Decoding a Token**

To read what’s inside a JWT token, we use:

```python
jwt.decode(token, secret, algorithms=["HS256"])
```

* **token** → the JWT string you received from the user (usually in the header).
* **secret** → the same key used when the token was created.
* **algorithms** → a list of accepted algorithms (like `"HS256"`).

If everything is fine, this returns the **payload** (the data inside the token).

Example:

```python
import jwt

secret = "my_secret_key"
token = "eyJhbGciOi..."  # an example token

decoded_data = jwt.decode(token, secret, algorithms=["HS256"])
print(decoded_data)
```

This will print something like:

```python
{
  "sub": "user123",
  "iat": 1730012345,
  "exp": 1730015945
}
```

---

### **2. Handling Common Errors**

Sometimes the token may be **expired** or **invalid**.
We should handle these cases properly.

Here’s how:

```python
import jwt

try:
    decoded = jwt.decode(token, secret, algorithms=["HS256"])
    print("Token is valid:", decoded)

except jwt.ExpiredSignatureError:
    print("Token has expired! Please log in again.")

except jwt.InvalidTokenError:
    print("Invalid token! You are not authorized.")
```

#### Main Error Types:

* **ExpiredSignatureError** → The token is too old and no longer valid.
* **InvalidTokenError** → The token is fake, changed, or corrupted.

---

### **3. Verifying Tokens in FastAPI**

In FastAPI, you usually check tokens in a **dependency**.
This way, protected routes automatically verify tokens before running.

Example:

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt

security = HTTPBearer()
SECRET_KEY = "my_secret_key"

def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    token = credentials.credentials
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        return payload  # valid token → return user info
    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has expired. Please log in again."
        )
    except jwt.InvalidTokenError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token."
        )
```

Then use this dependency in your routes:

```python
from fastapi import FastAPI, Depends

app = FastAPI()

@app.get("/protected")
def protected_route(user_data=Depends(verify_token)):
    return {"message": "You are authorized!", "user": user_data}
```

---

### **4. What’s Happening Behind the Scenes**

1. The client sends the JWT token with the request (in headers).
2. The FastAPI dependency reads it.
3. PyJWT checks:

   * If the **signature** is valid (token not tampered).
   * If the **token is not expired**.
4. If all checks pass → access is granted.
   Otherwise → a 401 Unauthorized error is returned.

---

### ✅ **Summary**

| Step | What Happens                           | Function Used                                                    |
| ---- | -------------------------------------- | ---------------------------------------------------------------- |
| 1    | Read the token                         | `jwt.decode()`                                                   |
| 2    | Verify the token is real and unexpired | `jwt.decode()` + secret key                                      |
| 3    | Handle invalid/expired tokens          | `try...except` with `ExpiredSignatureError`, `InvalidTokenError` |
| 4    | Use in FastAPI routes                  | Dependency function                                              |

---

**Key takeaway:**
Decoding verifies that the token is genuine and still valid.
This is the most important step for protecting private endpoints in FastAPI.

---
