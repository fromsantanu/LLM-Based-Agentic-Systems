# âš™ï¸ 9. **Asynchronous Operations (Advanced)**

In n8n, **asynchronous operations** are essential when your JavaScript code interacts with **APIs, databases, or delays**.
Because these tasks take time, you donâ€™t want to block the workflow â€” thatâ€™s where **`async` / `await`** and **Promises** come in.

---

## ðŸ§© **1. Understanding Async and Await**

When you mark a function as `async`, it automatically returns a **Promise**.
You can then use `await` to **pause** execution until that Promise resolves.

ðŸ’¡ Example:

```javascript
async function getData() {
  const res = await fetch("https://api.example.com/data");
  const data = await res.json();
  return data;
}

const result = await getData();
return [{ json: result }];
```

ðŸ‘‰ `await` can **only** be used inside an `async` function.
In n8n **Function nodes**, this is allowed by default, so you can safely use `await`.

---

## ðŸ§© **2. Using Promises (.then() and .catch())**

If you donâ€™t use `async/await`, you can handle results with **Promise chaining**.

ðŸ’¡ Example:

```javascript
return fetch("https://api.example.com/info")
  .then(res => res.json())
  .then(data => {
    return [{ json: data }];
  })
  .catch(err => {
    console.error("Error fetching data:", err);
    throw new Error("Fetch failed");
  });
```

This is equivalent to using `await`, but sometimes useful when mixing multiple async calls.

---

## ðŸ§© **3. Sleep or Wait Logic**

You can pause your script for a few seconds using a Promise-based delay.

ðŸ’¡ Example (wait 1 second):

```javascript
await new Promise(resolve => setTimeout(resolve, 1000));
console.log("Waited 1 second");

return [{ json: { status: "done" } }];
```

ðŸ’¡ Example (simulate step delays):

```javascript
console.log("Step 1 done");
await new Promise(r => setTimeout(r, 2000));

console.log("Step 2 done after 2 seconds");
await new Promise(r => setTimeout(r, 3000));

console.log("Step 3 done after another 3 seconds");

return [{ json: { message: "All steps complete" } }];
```

---

## ðŸ§© **4. Combining Multiple Async Tasks**

You can run **several API calls in parallel** using `Promise.all()`:

```javascript
const urls = [
  "https://api.example.com/user/1",
  "https://api.example.com/user/2"
];

const results = await Promise.all(
  urls.map(u => fetch(u).then(r => r.json()))
);

return results.map(r => ({ json: r }));
```

âœ… Useful for reducing total wait time
âœ… Each result becomes a separate item in the workflow

---

## ðŸ§© **5. Handling Errors Gracefully**

Use try...catch blocks to manage failed async calls.

```javascript
try {
  const res = await fetch("https://api.fakeurl.com/test");
  if (!res.ok) throw new Error("Bad response");
  const data = await res.json();
  return [{ json: data }];
} catch (err) {
  console.error("Error:", err.message);
  return [{ json: { error: err.message } }];
}
```

---

## âœ… **Summary**

| Concept                | Description                    | Example                                       |
| ---------------------- | ------------------------------ | --------------------------------------------- |
| `async` / `await`      | Handle async code sequentially | `const data = await fetch(url)`               |
| `.then()` / `.catch()` | Handle async code via chaining | `fetch(url).then(r => r.json())`              |
| `Promise.all()`        | Run async tasks in parallel    | `await Promise.all([...])`                    |
| Sleep / Wait           | Pause execution                | `await new Promise(r => setTimeout(r, 1000))` |
| try...catch            | Error handling for async ops   | `try { await ... } catch (e) { ... }`         |

---

ðŸ’¡ **Practical Tip:**
In n8n, async operations are most useful in:

* Function or Function Item nodes calling APIs
* Custom delay logic between steps
* Waiting for external services to respond
* Fetching multiple URLs at once before continuing

---
