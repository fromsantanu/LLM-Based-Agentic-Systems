# **Chapter 6. Querying in Depth**

Once your vectors are stored in Qdrant, the real power comes from how you query them. Querying in Qdrant isn’t just about retrieving the nearest neighbors in vector space—it also allows combining semantic similarity with structured filtering, scoring, and ranking.

---

## 6.1 Similarity Search with `query()`

At the core of Qdrant is similarity search. You provide a query vector, and Qdrant retrieves the closest points from the collection according to the chosen distance metric (cosine, Euclidean, or dot product).

**Example (Python client):**

```python
from qdrant_client import QdrantClient
from qdrant_client.models import PointStruct

# Connect to Qdrant
client = QdrantClient(":memory:")

# Query with a vector
search_result = client.search(
    collection_name="documents",
    query_vector=[0.1, 0.2, 0.3, 0.4],
    limit=5  # return top-5 results
)

for hit in search_result:
    print(f"ID: {hit.id}, Score: {hit.score}, Payload: {hit.payload}")
```

**Key parameters:**

* `query_vector`: The embedding you want to search for.
* `limit`: Number of nearest neighbors to return.
* `score`: Indicates similarity (higher is better for cosine/dot, lower is better for Euclidean).

---

## 6.2 Filtering with Metadata Conditions

Every point in Qdrant can carry structured **payloads** (metadata). You can filter results using conditions on payload fields, similar to SQL `WHERE` clauses.

**Example: Filter documents by category:**

```python
from qdrant_client.models import Filter, FieldCondition, MatchValue

# Search only within category = "healthcare"
search_result = client.search(
    collection_name="documents",
    query_vector=[0.1, 0.2, 0.3, 0.4],
    query_filter=Filter(
        must=[FieldCondition(key="category", match=MatchValue(value="healthcare"))]
    ),
    limit=5
)
```

**Filter operators available:**

* `must` → AND conditions
* `should` → OR conditions
* `must_not` → NOT conditions

---

## 6.3 Combining Vector + Metadata Filters

One of Qdrant’s strongest features is the ability to **combine vector similarity with structured filters**. This allows you to constrain the search space (e.g., semantic similarity among only “English” documents or only items published after 2020).

**Example: Search for “finance” vectors but only in 2022+ documents:**

```python
from qdrant_client.models import Range

search_result = client.search(
    collection_name="documents",
    query_vector=[0.1, 0.2, 0.3, 0.4],
    query_filter=Filter(
        must=[
            FieldCondition(key="language", match=MatchValue(value="en")),
            FieldCondition(key="year", range=Range(gte=2022))
        ]
    ),
    limit=5
)
```

This type of hybrid filtering is crucial for **real-world applications** like recommendation engines, personalized search, and knowledge retrieval.

---

## 6.4 Understanding Scoring and Ranking

Each query result includes a **score**, which is computed based on the collection’s distance metric. The score determines how close a point is to the query vector.

* **Cosine similarity** → Score ∈ \[-1, 1], higher means more similar.
* **Dot product** → Unbounded, higher means more similar.
* **Euclidean (L2)** → Distance ≥ 0, lower means more similar.

Qdrant automatically ranks results by score, but you can add **reranking logic** on the application side, such as:

* Boosting items with higher popularity.
* Demoting results outside a desired metadata range.
* Combining multiple vector fields (e.g., text + image embeddings).

**Tip:** Always interpret scores in the context of the metric used. For example, in cosine similarity, `0.9` is extremely close, while in Euclidean, you want the score closer to `0`.

---

## ✅ Key Takeaways

* Use `query()` for pure similarity search.
* Add `query_filter` for precise control with metadata.
* Combine vector + metadata filters for hybrid, production-ready queries.
* Understand how scoring works depending on your distance metric for correct ranking.

---

