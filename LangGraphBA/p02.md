# Chapter 2: Core Concepts in LangGraph

Before diving into advanced workflows, itâ€™s essential to understand the **fundamental building blocks** of LangGraph. These are the concepts that make it different from simple sequential chains in LangChain.

---

## 2.1 Nodes

* **Definition:** A node is the basic unit of computation in LangGraph.
* **Role:** Each node encapsulates a function, agent, or tool that performs a task.
* **Examples of nodes:**

  * A **text generator** node (LLM call).
  * A **summarizer** node.
  * A **retrieval** node (querying a vector store).

---

## 2.2 Edges

* **Definition:** Edges are the connections between nodes. They define the **flow of data**.
* **Types of edges:**

  * **Directed edges:** Data flows from one node to another.
  * **Conditional edges:** The next node depends on logic or outcome.
* **Analogy:** Think of edges as **pipes** that transfer information between machines (nodes).

---

## 2.3 State

* **Definition:** State is the **shared memory** that persists across node executions.
* **Why it matters:** Unlike LangChain (which is mostly stateless), LangGraph can maintain evolving **conversation state** or **workflow context**.
* **Example:**

  * A patientâ€™s record in a medical workflow.
  * A userâ€™s conversation history in a chatbot.

---

## 2.4 Channels

* **Definition:** Channels represent **different slices of state** or **paths of communication**.
* **Use case:** They allow you to isolate and manage multiple flows of data (like separating **chat history**, **metadata**, and **user profile**).
* **Benefit:** Helps avoid collisions and ensures modular design.

---

## 2.5 Graph Execution Model

* LangGraph executes workflows using a **graph-based model** rather than a linear chain.
* **Process:**

  1. A graph is initialized with nodes and edges.
  2. State is passed into the graph.
  3. The graph executes nodes according to defined edges, updating the state at each step.
  4. Execution stops when a terminal condition is reached.

This model allows for **branching, looping, conditional logic, and long-running agents**â€”things that are hard to manage with LangChain alone.

---

## 2.6 Example: Text Generation + Summarization Graph

Letâ€™s create a simple graph with **two nodes**:

1. **Text Generator Node** â†’ generates a paragraph of text.
2. **Summarizer Node** â†’ takes the generated text and produces a concise summary.

### Code Example

```python
from langgraph.graph import StateGraph, END

# Define the shared state
class GraphState(dict):
    text: str
    summary: str

# Node 1: Generate text
def generate_text(state: GraphState):
    state["text"] = "LangGraph enables stateful agent orchestration for complex workflows."
    return state

# Node 2: Summarize text
def summarize_text(state: GraphState):
    state["summary"] = "LangGraph helps orchestrate stateful agents."
    return state

# Build the graph
graph = StateGraph(GraphState)

graph.add_node("generator", generate_text)
graph.add_node("summarizer", summarize_text)

graph.add_edge("generator", "summarizer")
graph.set_entry_point("generator")
graph.set_finish_point("summarizer")

# Compile and run
app = graph.compile()
result = app.invoke({})
print(result)
```

### Output

```text
{'text': 'LangGraph enables stateful agent orchestration for complex workflows.',
 'summary': 'LangGraph helps orchestrate stateful agents.'}
```

---

âœ… In this example:

* **Nodes:** `generate_text`, `summarize_text`.
* **Edges:** Connect generator â†’ summarizer.
* **State:** Stores `text` and `summary`.
* **Execution model:** Starts at generator, flows to summarizer, stops at END.

---

ðŸ”¹ **Takeaway:**
LangGraphâ€™s **graph-based execution** with **nodes, edges, state, and channels** allows building structured, maintainable, and stateful workflowsâ€”far more powerful than linear chains.

---

