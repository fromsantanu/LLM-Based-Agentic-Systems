# Chapter 14: Memory & Persistence

In the earlier chapters, we explored **state management** within a single workflow run. But in real-world applications, we often want the system to **remember across sessions** â€” whether itâ€™s a chatbot recalling a userâ€™s preferences, or an agent preserving context over multiple conversations.

This chapter focuses on **memory and persistence** in LangGraph:

* Why persistence matters
* Options for storing state
* Using Redis, SQL, or file-based memory
* Example: Chatbot with persistent user preferences

---

## 14.1 Why Persistence Matters

Without persistence, every new run of your graph starts from scratch. This limits usefulness in applications like:

* **Chatbots** â†’ remembering names, preferences, or past interactions.
* **Healthcare systems** â†’ storing patient records across visits.
* **Recommendation engines** â†’ personalizing results based on prior choices.

By adding persistence, we can build **stateful applications** where context is carried forward.

---

## 14.2 Approaches to Persistence

LangGraph lets you choose how to **store and reload state** depending on scale and reliability needs:

1. **File-based memory**

   * Easiest to start with.
   * Serialize state into JSON, YAML, or Pickle files.
   * Good for small projects or prototyping.

2. **SQL Databases (SQLite, PostgreSQL, MySQL)**

   * Store structured session data.
   * Ideal for applications needing **transactions, queries, or reports**.
   * Easy integration with ORM libraries like `SQLAlchemy`.

3. **Redis (in-memory key-value store)**

   * Very fast, scalable, supports **expiring sessions**.
   * Common in production chatbots and web apps.
   * Works well in distributed systems.

---

## 14.3 Persistence in LangGraph

LangGraph graphs are **pure functions of state**. To persist:

1. **Serialize the graph state** at checkpoints.
2. **Reload** that state in the next session.

This means you can wrap your graph with middleware that automatically stores the state into Redis, SQL, or files.

---

## 14.4 Example â€“ Chatbot with User Preferences

Letâ€™s implement a chatbot that **remembers favorite color** across sessions.

```python
from langgraph.graph import StateGraph, START, END
from langchain_openai import ChatOpenAI
import redis
import json

# Redis connection
r = redis.Redis(host='localhost', port=6379, db=0)

# Define state schema
class State(dict):
    pass

# Nodes
def greet(state: State):
    if "color" in state:
        return {"response": f"Welcome back! Last time you said your favorite color was {state['color']}."}
    else:
        return {"response": "Hello! What's your favorite color?"}

def remember_color(state: State):
    user_input = state.get("user_input", "").strip()
    state["color"] = user_input
    return {"response": f"Got it! I'll remember your favorite color is {user_input}."}

# Build graph
graph = StateGraph(State)
graph.add_node("greet", greet)
graph.add_node("remember_color", remember_color)
graph.add_edge(START, "greet")
graph.add_edge("greet", "remember_color")
graph.add_edge("remember_color", END)
app = graph.compile()

# Helper: save/load state in Redis
def save_state(user_id, state):
    r.set(user_id, json.dumps(state))

def load_state(user_id):
    raw = r.get(user_id)
    return json.loads(raw) if raw else {}

# Usage
user_id = "user123"
state = load_state(user_id)

# User interacts
state["user_input"] = "blue"
state = app.invoke(state)

print(state["response"])   # Got it! I'll remember your favorite color is blue.

# Persist state
save_state(user_id, state)
```

âœ… Next time the same user runs the bot, the system retrieves their color preference and personalizes the greeting.

---

## 14.5 Alternatives

* **SQLite Example**: Save state as JSON in a `sessions` table.
* **File-based Example**: Dump `state` into `user123.json` file and reload later.

Each option has trade-offs:

* File â†’ simple, but not scalable.
* SQL â†’ reliable, queryable, moderate complexity.
* Redis â†’ scalable, fast, but requires external service.

---

## 14.6 Best Practices

* **Use unique session keys** (e.g., user ID + timestamp).
* **Expire old sessions** in Redis to prevent bloat.
* **Encrypt sensitive state** before saving (e.g., medical data).
* **Keep schema consistent** to avoid reload errors.

---

## âœ… Recap

* Persistence extends LangGraphâ€™s stateful model across sessions.
* File, SQL, and Redis are common options for storing state.
* Example: A chatbot that remembers user preferences.
* Best practices ensure scalable and secure memory handling.

ðŸ”¹ Next, weâ€™ll explore **Chapter 15: Monitoring & Debugging** â€” tools and techniques to inspect graphs in action.

---

