# Chapter 9: Branching Graphs

In real-world workflows, not all tasks follow a single linear path. Depending on the **input** or **state**, you may want your graph to take **different routes**. This is where **branching graphs** come in.

Branching allows you to:

* Route execution to **different nodes** based on conditions.
* Support **multi-path workflows** (e.g., query classification, decision trees).
* Enable **flexible, adaptive systems** instead of rigid pipelines.

---

## 9.1 What Are Branching Graphs?

A **branching graph** executes **different paths** depending on runtime conditions.

* Think of it like an **if/else** inside a workflow.
* Conditions can be based on **input type, state values, or external checks**.

For example:

```
Input → Classifier → (If Math → Math Solver, If Text → Summarizer)
```

---

## 9.2 When to Use Branching

Branching is useful when:

1. The **task type** is not fixed (e.g., query classification).
2. **Different tools** or models are required depending on the input.
3. You want to **optimize resources**, avoiding unnecessary execution.
4. You need **error-handling paths** (e.g., fallback to default answer).

---

## 9.3 How Branching Works in LangGraph

LangGraph uses **conditional edges** to define multiple possible next steps.

### Example: Query Type Classification

```python
from langgraph.graph import StateGraph

def classify_query(state):
    query = state["query"]
    if query.isdigit():
        return "math"
    return "text"

def solve_math(state):
    return {"answer": eval(state["query"])}

def summarize_text(state):
    return {"answer": f"Summary: {state['query']}"}

# Build graph
graph = StateGraph(dict)

graph.add_node("classifier", classify_query)
graph.add_node("math_solver", solve_math)
graph.add_node("summarizer", summarize_text)

graph.set_entry_point("classifier")

# Add branching edges
graph.add_conditional_edges(
    "classifier",
    lambda state: "math" if state["query"].isdigit() else "text",
    {
        "math": "math_solver",
        "text": "summarizer",
    },
)
```

Here:

* **classifier** decides which path to take.
* If input is numeric → goes to `math_solver`.
* Otherwise → goes to `summarizer`.

---

## 9.4 Example Run

```python
app = graph.compile()

print(app.invoke({"query": "5+5"}))
# Output: {'answer': 10}

print(app.invoke({"query": "Explain LangGraph"}))
# Output: {'answer': 'Summary: Explain LangGraph'}
```

---

## 9.5 Advanced Branching Scenarios

* **Multi-class routing**: More than two options (e.g., Math, Text, Code, Image).
* **Fallback branching**: If primary path fails → send to backup.
* **Nested branching**: Branch inside another branch (decision tree style).
* **Dynamic branching**: Conditions based on external API checks or state updates.

---

## 9.6 Visualization

```
          ┌─────────────┐
Input →   │ Classifier  │
          └──────┬──────┘
                 │
        ┌────────┴─────────┐
        ▼                  ▼
   ┌───────────┐      ┌────────────┐
   │ MathSolver│      │ Summarizer │
   └───────────┘      └────────────┘
```

---

✅ **Key Takeaway**:
Branching graphs make workflows **adaptive** and **intelligent**, allowing different execution paths based on conditions — much like a decision-making process in real life.

---
