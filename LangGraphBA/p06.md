# Chapter 6: State Management

One of the most powerful aspects of **LangGraph** is its ability to manage **state** across nodes. Unlike simple sequential chains where each node only passes inputs and outputs, LangGraph lets you design workflows where nodes share information, update it incrementally, and persist it for long-running processes.

---

## 6.1 What is State?

* **State** is the evolving "memory" of the graph.
* It captures all relevant data as it moves between nodes.
* State allows different nodes to work together while maintaining context.

Think of it as a **central workspace** that every node can read from and write to.

---

## 6.2 Shared State

Shared state enables multiple nodes to access and update the same context.

* Every node can **read** parts of the state.
* Nodes can also **write** new values, extending or modifying the state.
* This makes workflows **context-aware**.

ðŸ‘‰ Example: If you track `user_query` and `conversation_history`, any node can enrich these fields.

---

## 6.3 Channels

**Channels** are like compartments within the state that control **how data flows**.

* Each channel stores a specific piece of data.
* Channels enforce **typed communication**, ensuring nodes know what kind of data to expect.
* You can define separate channels for:

  * Text (`string`)
  * Numbers (`int`, `float`)
  * Lists (e.g., conversation history)
  * Complex objects (e.g., parsed JSON from an API)

This prevents nodes from mixing up unrelated data.

---

## 6.4 Reducers

A **reducer** defines **how updates to state are applied**.

* Without reducers, new values overwrite old ones.
* With reducers, you can **accumulate or merge** updates.

ðŸ”¹ Common reducer patterns:

* **Append**: Add new messages to conversation history.
* **Merge**: Combine dictionaries from different nodes.
* **Sum/Aggregate**: Useful in numeric computations.

This gives you fine-grained control over how state evolves.

---

## 6.5 Persistence

Persistence allows the state to survive **beyond one execution** of the graph.

* Store state in a **database**, **file system**, or **external cache**.
* Useful for **long-running workflows**, **chatbots**, or **multi-session tasks**.
* Ensures that context is not lost if the process stops and restarts.

ðŸ‘‰ Example: In a conversational assistant, persistence lets the bot "remember" earlier sessions.

---

## 6.6 Example: Tracking Conversation History

Letâ€™s build a simple example where we track conversation history across nodes.

```python
from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages
from typing import TypedDict, Annotated

# 1. Define State
class State(TypedDict):
    history: Annotated[list, add_messages]
    user_input: str
    bot_response: str

# 2. Define Nodes
def user_node(state: State):
    return {"history": state["user_input"]}

def bot_node(state: State):
    response = f"Echo: {state['user_input']}"
    return {"bot_response": response, "history": response}

# 3. Create Graph
graph = StateGraph(State)
graph.add_node("user", user_node)
graph.add_node("bot", bot_node)

graph.add_edge(START, "user")
graph.add_edge("user", "bot")
graph.add_edge("bot", END)

# 4. Compile
app = graph.compile()

# 5. Run with persistent history
state = {"history": [], "user_input": "Hello!"}
result = app.invoke(state)
print(result["history"])
```

### How it works:

* `history` channel is defined with a **reducer** (`add_messages`) to append messages.
* Each node adds to the history instead of overwriting it.
* You get a running log of the entire conversation.

---

âœ… **Key Takeaways**

* State is the shared memory across nodes.
* Channels structure state into manageable parts.
* Reducers control how state updates are merged.
* Persistence ensures workflows survive beyond a single run.

With state management, LangGraph lets you design **complex, context-aware, and resilient workflows**.

---

