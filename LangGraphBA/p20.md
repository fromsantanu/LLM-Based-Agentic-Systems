# Chapter 20: Hierarchical Graphs

In real-world workflows, graphs often grow very large and complex. To keep them manageable, **hierarchical graphs** allow you to break down a big workflow into **smaller subgraphs**. Each subgraph solves a specific problem and can be reused across multiple projects.

This modular design makes your workflow:

* Easier to understand
* Easier to test
* Easier to extend and reuse

---

## üîπ Why Hierarchical Graphs?

Think of hierarchical graphs like **functions in programming**.

* Instead of writing one giant workflow, you group related steps into a subgraph.
* Each subgraph has **defined inputs and outputs**.
* The top-level graph can call these subgraphs just like nodes.

---

## üîπ How Subgraphs Work

1. Define a subgraph (a smaller LangGraph graph).
2. Plug it into your main graph as a **single node**.
3. When executed, the subgraph runs internally and passes results back.

This creates a **hierarchy of workflows** ‚Äî the main workflow delegates tasks to specialized mini-workflows.

---

## üîπ Example: Research Assistant Graph

Imagine you are building a **Research Assistant Graph**.
It has to:

1. **Search** for information
2. **Summarize** results
3. **Draft** a report

Instead of cramming everything in one graph, we design three **subgraphs**:

* **Search Graph** ‚Üí Queries web or docs and returns results.
* **Summarize Graph** ‚Üí Condenses results into bullet points.
* **Draft Graph** ‚Üí Turns summaries into a polished draft.

Then we connect them into a **top-level Research Assistant Graph**.

---

### üß© Code Example

```python
from langgraph.graph import StateGraph, END

# --- Subgraph 1: Search ---
def search_node(state):
    query = state["query"]
    return {"search_results": f"Results for {query}"}

search_graph = StateGraph(dict)
search_graph.add_node("search", search_node)
search_graph.set_entry_point("search")
search_graph.set_finish_point("search")
search_app = search_graph.compile()


# --- Subgraph 2: Summarize ---
def summarize_node(state):
    results = state["search_results"]
    return {"summary": f"Summary of {results}"}

summarize_graph = StateGraph(dict)
summarize_graph.add_node("summarize", summarize_node)
summarize_graph.set_entry_point("summarize")
summarize_graph.set_finish_point("summarize")
summarize_app = summarize_graph.compile()


# --- Subgraph 3: Draft ---
def draft_node(state):
    summary = state["summary"]
    return {"draft": f"Draft report: {summary}"}

draft_graph = StateGraph(dict)
draft_graph.add_node("draft", draft_node)
draft_graph.set_entry_point("draft")
draft_graph.set_finish_point("draft")
draft_app = draft_graph.compile()


# --- Main Graph: Research Assistant ---
main_graph = StateGraph(dict)

# Use subgraphs as nodes
main_graph.add_node("search_graph", search_app)
main_graph.add_node("summarize_graph", summarize_app)
main_graph.add_node("draft_graph", draft_app)

# Flow
main_graph.add_edge("search_graph", "summarize_graph")
main_graph.add_edge("summarize_graph", "draft_graph")

main_graph.set_entry_point("search_graph")
main_graph.set_finish_point("draft_graph")

research_assistant = main_graph.compile()

# Run the hierarchical graph
output = research_assistant.invoke({"query": "LangGraph tutorials"})
print(output["draft"])
```

---

### üîπ Output

```
Draft report: Summary of Results for LangGraph tutorials
```

---

## üîπ Benefits of Hierarchical Graphs

* **Reusability**: Each subgraph can be reused in other projects.
* **Scalability**: Makes it easier to manage complex workflows.
* **Maintainability**: You can update one subgraph without touching the whole system.
* **Testing**: Subgraphs can be tested independently.

---

## ‚úÖ Key Takeaways

* Hierarchical graphs = modular design for workflows.
* Subgraphs behave like reusable ‚Äúfunctions‚Äù inside your main graph.
* Perfect for large projects (e.g., assistants, pipelines, healthcare systems).

---

