# Chapter 21: Running Locally

So far, we’ve been building graphs conceptually and with small examples. But in practice, you’ll often want to **run LangGraph locally** for development and debugging before deploying to production.

Running locally lets you:

* Use the **CLI (Command-Line Interface)** to interact with your graph.
* Inspect and debug the workflow step by step.
* Enable **logging** to monitor state transitions and catch issues early.

---

## 21.1 CLI Usage

LangGraph ships with a CLI tool that makes it simple to run graphs locally.

### Steps:

1. Save your graph definition into a file, e.g., `chat_graph.py`.
2. Run the CLI:

```bash
langgraph run chat_graph.py
```

3. You’ll be prompted for inputs (if required), and the CLI will display outputs.

---

## 21.2 Debugging Graphs

During development, you’ll want visibility into:

* Which **nodes** are being executed.
* The **state** before and after each transition.
* Any **errors** or exceptions that occur.

LangGraph provides a `--debug` flag for this:

```bash
langgraph run chat_graph.py --debug
```

This will print detailed execution traces:

* Node entry/exit logs.
* State snapshots.
* Error messages with stack traces.

---

## 21.3 Logging

You can configure Python’s logging system inside your graph for structured logging.

```python
import logging
from langgraph.graph import StateGraph

logging.basicConfig(level=logging.INFO)

def chatbot_node(state):
    logging.info(f"Received state: {state}")
    return {"response": f"Echo: {state['message']}"}

graph = StateGraph(dict)
graph.add_node("chatbot", chatbot_node)
graph.set_entry_point("chatbot")

app = graph.compile()
```

Now when you run locally, you’ll see log messages for each state transition.

---

## 21.4 Example: Local Chatbot Graph

Let’s put it together.

```python
from langgraph.graph import StateGraph

# Define the state schema
class ChatState(dict):
    message: str
    response: str

# Define a simple chatbot node
def chatbot_node(state: ChatState):
    print(f"[DEBUG] Processing: {state['message']}")
    return {"response": f"Bot says: {state['message'].upper()}"}

# Create the graph
graph = StateGraph(ChatState)
graph.add_node("chatbot", chatbot_node)
graph.set_entry_point("chatbot")

app = graph.compile()

if __name__ == "__main__":
    # Run locally with simple loop
    while True:
        msg = input("You: ")
        if msg.lower() in ["exit", "quit"]:
            break
        state = {"message": msg}
        result = app.invoke(state)
        print("Bot:", result["response"])
```

### Run It:

```bash
python chat_graph.py
```

### Sample Interaction:

```
You: hello
[DEBUG] Processing: hello
Bot: Bot says: HELLO
```

---

## 21.5 Key Takeaways

* Use `langgraph run file.py` to quickly test a graph via CLI.
* Add `--debug` for step-by-step state inspection.
* Use Python’s `logging` for structured monitoring.
* Running locally helps ensure your graph is correct before scaling or deploying.

---

✅ In the next chapter, we’ll move from **local execution** to **deployment options** (server, containers, cloud functions).

---
