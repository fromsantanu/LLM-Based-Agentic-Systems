# Chapter 4: Defining Nodes

In LangGraph, **nodes** are the building blocks of your workflow.
Each node represents a **unit of work**â€”a function, an LLM call, a tool invocation, or some custom logic. Together, nodes form the flow of data across the graph.

---

## 4.1 What is a Node?

* A **node** is simply a function that takes an input and produces an output.
* Nodes operate on **state**â€”they consume specific keys of the state and add or update keys with new values.
* You can think of nodes as **functions connected by edges**.

**Example analogy:**

* In programming, functions are combined using function calls.
* In LangGraph, nodes are connected using edges to form a workflow.

---

## 4.2 Types of Nodes

LangGraph supports different kinds of nodes depending on your workflow needs:

### 1. **LLM Nodes**

* Nodes that call a large language model (LLM).
* Useful for generating text, answering questions, summarization, reasoning, etc.

**Example:**

```python
from langgraph.prebuilt import ToolNode

llm_node = ToolNode(tool=chat_model)
```

---

### 2. **Tool Nodes**

* Nodes that call an **external tool or API**.
* Example: a calculator, a web search tool, or a database query.

**Example:**

```python
def multiply_tool(state):
    return {"result": state["number"] * 2}
```

---

### 3. **Custom Logic Nodes**

* Pure Python functions that define custom rules or logic.
* Flexible and best suited for preprocessing, filtering, or specialized workflows.

**Example:**

```python
def add_one(state):
    return {"number": state["number"] + 1}
```

---

## 4.3 Defining a Node Function

A node in LangGraph is typically written as a **Python function**.

**Example: Simple two-node workflow**

```python
from langgraph.graph import StateGraph

# Node 1: Take a number
def node1(state):
    return {"number": state["input"]}

# Node 2: Multiply by 2
def node2(state):
    return {"result": state["number"] * 2}

# Create graph
graph = StateGraph(dict)

# Add nodes
graph.add_node("Node1", node1)
graph.add_node("Node2", node2)

# Define edges
graph.add_edge("Node1", "Node2")

# Set entry point
graph.set_entry_point("Node1")

# Compile
app = graph.compile()

# Run the graph
output = app.invoke({"input": 5})
print(output)  # {'number': 5, 'result': 10}
```

---

## 4.4 Key Takeaways

* **Nodes = Functions** in LangGraph.
* They can be **LLM calls, tools, or custom logic**.
* Nodes pass data forward by updating the **graph state**.
* By connecting nodes, you create **complex workflows** from simple building blocks.

---

ðŸ”¹ **Next Chapter Preview:**
Weâ€™ll explore **Edges & State Management**â€”how data flows between nodes and how to control branching logic.

---
