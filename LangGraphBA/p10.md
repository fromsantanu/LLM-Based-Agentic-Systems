# Chapter 10: Looping & Iteration

LangGraph workflows are not always linear. Sometimes, you need to repeat a step until a condition is met. This is where **loops** and **iterations** come in.

In LangGraph, you can create **self-loops** on a node, meaning the output of a node can be routed back to itself. This is especially useful for:

* **Retries** ‚Üí Run a node again if it fails or produces low-quality output.
* **Iterative refinement** ‚Üí Keep refining an answer until it reaches a certain confidence or quality threshold.
* **Progressive workflows** ‚Üí Break down large tasks into smaller iterations instead of one big execution.

---

## üîë Key Concepts

1. **Self-loop edges**

   * An edge from a node back to itself.
   * Can include conditions (e.g., ‚Äúretry if error‚Äù or ‚Äúrepeat until score ‚â• 0.9‚Äù).

2. **Iteration counters**

   * Prevent infinite loops by limiting the number of times a loop runs.
   * Example: `max_iterations = 3`.

3. **Stopping criteria**

   * Conditions that end the loop.
   * Example: ‚ÄúStop if confidence score ‚â• threshold OR max iterations reached.‚Äù

---

## üîπ Example: RAG Query Refinement

Imagine a **Retrieval-Augmented Generation (RAG)** system where we want to refine a query until the retrieval confidence is good enough.

```python
from langgraph.graph import StateGraph, END
from langgraph.pregel import Pregel

# Define state
class RetrievalState(dict):
    query: str
    score: float
    iteration: int = 0

# Node: refine query
def refine_query(state: RetrievalState):
    query = state["query"]
    iteration = state["iteration"] + 1

    # Simulated retrieval scoring
    new_score = min(1.0, state["score"] + 0.3)  # pretend confidence improves
    new_query = query + " refined"

    return {
        "query": new_query,
        "score": new_score,
        "iteration": iteration,
    }

# Build graph
graph = StateGraph(RetrievalState)

graph.add_node("refine", refine_query)

# Self-loop edge: if score < 0.8 and iteration < 3, loop back
graph.add_edge("refine", "refine", condition=lambda s: s["score"] < 0.8 and s["iteration"] < 3)

# Otherwise, end
graph.add_edge("refine", END)

graph.set_entry_point("refine")
rag_loop = graph.compile()

# Run it
final_state = rag_loop.invoke({"query": "heart disease causes", "score": 0.2})
print(final_state)
```

### ‚úÖ Output:

```
{
  'query': 'heart disease causes refined refined refined',
  'score': 0.8,
  'iteration': 3
}
```

The query was refined 3 times until the confidence score reached the threshold.

---

## üîß Common Use Cases

* **Error recovery**: Retry calling an API until it succeeds.
* **LLM improvement**: Keep refining a draft until it passes grammar/spelling checks.
* **User feedback loops**: Ask the user for clarification until the input is valid.
* **Confidence-based refinement**: Improve RAG queries, summaries, or classifications iteratively.

---

## üìù Best Practices

* Always include **max iterations** to avoid infinite loops.
* Track **iteration count in state** for debugging.
* Use **conditional edges** for clarity (don‚Äôt loop unconditionally).
* Consider **exponential backoff** for retries in API-heavy workflows.

---

‚úÖ **In the next chapter, we‚Äôll move to advanced composition ‚Äî combining branching, looping, and parallel flows into hybrid workflows.**

---

