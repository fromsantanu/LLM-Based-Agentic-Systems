# Chapter 5: Edges & Flow Control

In LangGraph, **edges** define how data and state move between nodes. They form the backbone of your workflow logic, determining **execution order**, **branching**, and **parallel processing**.

Edges are not just arrows between nodes; they carry **state transitions** and control the flow of execution.

---

## ðŸ”¹ Types of Edges

### 1. Direct Edges

* The simplest edge type.
* Always passes control and state from one node to the next.
* Use when the flow is **linear**.

**Example:**

```
Node A â†’ Node B â†’ Node C
```

Here, Node Aâ€™s output is directly fed into Node B, and then Node C.

---

### 2. Conditional Edges

* Enable **branching logic** based on the state or node output.
* Each edge can have a condition (like an `if-else`).
* Useful when you want to **route inputs differently** depending on a decision.

**Example Use Case:**

* A text classification node routes content to different summarizers:

  * Positive â†’ Positive Summarizer
  * Negative â†’ Negative Summarizer

```
Classifier Node
 â”œâ”€â”€ Positive â†’ Positive Summarizer
 â””â”€â”€ Negative â†’ Negative Summarizer
```

---

### 3. Parallel Edges

* Allow multiple downstream nodes to run **concurrently**.
* Each node receives the same input state and processes it in parallel.
* Useful for **multi-perspective processing** (e.g., summarization + sentiment + keyword extraction in parallel).

**Example:**

```
Input Text Node â†’ { Summarizer, Sentiment Analyzer, Keyword Extractor }
```

All three run simultaneously and later their results can be joined.

---

## ðŸ”¹ Example: Sentiment Branching Workflow

Letâ€™s implement a small example where text is branched into different summarizers depending on sentiment.

### Step 1: Define Nodes

* **Input Node** â†’ Receives text
* **Sentiment Classifier** â†’ Classifies text as Positive or Negative
* **Positive Summarizer** â†’ Summarizes positive text
* **Negative Summarizer** â†’ Summarizes negative text

### Step 2: Define Edges

1. Input Node â†’ Sentiment Classifier (direct edge)
2. Sentiment Classifier â†’ Positive Summarizer (conditional: if `sentiment == "positive"`)
3. Sentiment Classifier â†’ Negative Summarizer (conditional: if `sentiment == "negative"`)

---

### Python-like Pseudocode Example

```python
from langgraph.graph import StateGraph, END

# Define state
class State(dict):
    text: str
    sentiment: str
    summary: str

graph = StateGraph(State)

# Nodes
def classify_sentiment(state: State):
    if "good" in state["text"].lower():
        state["sentiment"] = "positive"
    else:
        state["sentiment"] = "negative"
    return state

def positive_summary(state: State):
    state["summary"] = f"Positive Summary: {state['text'][:50]}"
    return state

def negative_summary(state: State):
    state["summary"] = f"Negative Summary: {state['text'][:50]}"
    return state

# Add nodes
graph.add_node("classifier", classify_sentiment)
graph.add_node("pos_sum", positive_summary)
graph.add_node("neg_sum", negative_summary)

# Edges
graph.set_entry_point("classifier")
graph.add_conditional_edges(
    "classifier",
    {
        "positive": "pos_sum",
        "negative": "neg_sum"
    }
)
graph.add_edge("pos_sum", END)
graph.add_edge("neg_sum", END)

workflow = graph.compile()

# Run
result = workflow.invoke({"text": "This product is really good and useful!"})
print(result["summary"])
```

---

âœ… **Key Takeaways**

* **Direct edges**: linear flows.
* **Conditional edges**: decision-making & branching.
* **Parallel edges**: concurrent execution.

Together, these allow **flexible, intelligent control flow** in LangGraph.

---
