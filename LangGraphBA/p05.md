# Chapter 5: Edges & Flow Control

In LangGraph, **edges** define how data and state move between nodes. They form the backbone of your workflow logic, determining **execution order**, **branching**, and **parallel processing**.

Edges are not just arrows between nodes; they carry **state transitions** and control the flow of execution.

---

## ðŸ”¹ Types of Edges

### 1. Direct Edges

* The simplest edge type.
* Always passes control and state from one node to the next.
* Use when the flow is **linear**.

**Example:**

```
Node A â†’ Node B â†’ Node C
```

Here, Node Aâ€™s output is directly fed into Node B, and then Node C.

---

### 2. Conditional Edges

* Enable **branching logic** based on the state or node output.
* Each edge can have a condition (like an `if-else`).
* Useful when you want to **route inputs differently** depending on a decision.

**Example Use Case:**

* A text classification node routes content to different summarizers:

  * Positive â†’ Positive Summarizer
  * Negative â†’ Negative Summarizer

```
Classifier Node
 â”œâ”€â”€ Positive â†’ Positive Summarizer
 â””â”€â”€ Negative â†’ Negative Summarizer
```

---

### 3. Parallel Edges

* Allow multiple downstream nodes to run **concurrently**.
* Each node receives the same input state and processes it in parallel.
* Useful for **multi-perspective processing** (e.g., summarization + sentiment + keyword extraction in parallel).

**Example:**

```
Input Text Node â†’ { Summarizer, Sentiment Analyzer, Keyword Extractor }
```

All three run simultaneously and later their results can be joined.

---

## ðŸ”¹ Example: Sentiment Branching Workflow

Letâ€™s implement a small example where text is branched into different summarizers depending on sentiment.

### Step 1: Define Nodes

* **Input Node** â†’ Receives text
* **Sentiment Classifier** â†’ Classifies text as Positive or Negative
* **Positive Summarizer** â†’ Summarizes positive text
* **Negative Summarizer** â†’ Summarizes negative text

### Step 2: Define Edges

1. Input Node â†’ Sentiment Classifier (direct edge)
2. Sentiment Classifier â†’ Positive Summarizer (conditional: if `sentiment == "positive"`)
3. Sentiment Classifier â†’ Negative Summarizer (conditional: if `sentiment == "negative"`)

---

### Python-like Pseudocode Example

```python
from typing import TypedDict
from langgraph.graph import StateGraph, END


# 1) Define the state your graph will pass around
class State(TypedDict):
    text: str
    sentiment: str
    summary: str


# 2) Create the graph
graph = StateGraph(State)


# 3) Define node functions
def classify_sentiment(state: State) -> State:
    """Look at the text and mark sentiment as 'positive' or 'negative'."""
    text = state["text"].lower()
    if "good" in text or "great" in text or "excellent" in text:
        state["sentiment"] = "positive"
    else:
        state["sentiment"] = "negative"
    return state


def positive_summary(state: State) -> State:
    """Create a short positive summary."""
    state["summary"] = f"Positive Summary: {state['text'][:50]}"
    return state


def negative_summary(state: State) -> State:
    """Create a short negative summary."""
    state["summary"] = f"Negative Summary: {state['text'][:50]}"
    return state


# 4) Add nodes to the graph
graph.add_node("classifier", classify_sentiment)
graph.add_node("pos_sum", positive_summary)
graph.add_node("neg_sum", negative_summary)


# 5) Define the conditional routing function
def route_by_sentiment(state: State) -> str:
    """
    This is the 'traffic rule'.

    It reads state['sentiment'] and returns a label string.
    The label must match keys in the mapping we provide below
    ('positive' or 'negative').
    """
    return state["sentiment"]


# 6) Wire the edges
# Entry point: where the graph starts
graph.set_entry_point("classifier")

# Conditional edges from 'classifier'
graph.add_conditional_edges(
    "classifier",          # source node
    route_by_sentiment,    # function returning 'positive' or 'negative'
    {                      # mapping from label -> next node name
        "positive": "pos_sum",
        "negative": "neg_sum",
    },
)

# After pos_sum or neg_sum, finish the graph
graph.add_edge("pos_sum", END)
graph.add_edge("neg_sum", END)


# 7) Compile the workflow
workflow = graph.compile()


# 8) Run examples
if __name__ == "__main__":
    # Example 1: Positive text
    result1 = workflow.invoke({"text": "This product is really good and useful!"})
    print("Input 1:", result1["text"])
    print("Sentiment 1:", result1["sentiment"])
    print("Summary 1:", result1["summary"])
    print("-" * 60)

    # Example 2: Negative text
    result2 = workflow.invoke({"text": "This product is terrible and not helpful at all."})
    print("Input 2:", result2["text"])
    print("Sentiment 2:", result2["sentiment"])
    print("Summary 2:", result2["summary"])

```

---

âœ… **Key Takeaways**

* **Direct edges**: linear flows.
* **Conditional edges**: decision-making & branching.
* **Parallel edges**: concurrent execution.

Together, these allow **flexible, intelligent control flow** in LangGraph.

---
