# **Chapter 2. Core Concepts of MCP**

### Context in AI Models (Definition and Importance)

At the heart of the Model Context Protocol (MCP) lies the idea of **context**. In the world of AI, context refers to the information available to a model at the time of processing a task. This can include:

* The user’s request or prompt.
* External knowledge (documents, databases, APIs).
* The history of prior interactions.
* Environmental conditions (e.g., user device, session metadata).

Why is context so important?

* **Accuracy**: Models produce more relevant and precise responses when they have the right background information.
* **Personalization**: Context allows tailoring answers to specific users, domains, or workflows.
* **Efficiency**: With context readily accessible, there’s no need to overload models with irrelevant data.
* **Safety and compliance**: By defining what information a model can and cannot access, context provides a layer of control and governance.

In MCP, context is **standardized and structured**, enabling AI systems to go beyond ad-hoc prompts and evolve into interoperable, reliable components of larger ecosystems.

---

### Roles of Clients, Servers, and Models in MCP

MCP organizes interaction between three main actors, each with a well-defined role:

1. **Clients**

   * Interface that users interact with (e.g., chat applications, notebooks, IDEs).
   * Responsible for capturing user input and rendering model outputs.
   * Manage sessions and orchestrate communication between models and servers.

2. **Servers**

   * Providers of tools, knowledge, or functions external to the model.
   * Can expose databases, APIs, file systems, or specialized computation engines.
   * Act as context providers, offering structured data to the model when needed.

3. **Models**

   * Large Language Models (LLMs) or other AI systems that process context and generate outputs.
   * They don’t directly integrate with external systems but instead rely on **MCP servers** to supply the right context.
   * This separation keeps models lightweight and adaptable while allowing servers to handle domain-specific complexity.

The clear separation of roles ensures **modularity**, so systems can evolve independently and integrate flexibly.

---

### How MCP Differs from APIs and SDKs

Traditional software systems rely heavily on **APIs** (Application Programming Interfaces) and **SDKs** (Software Development Kits) to connect components. MCP introduces a shift in philosophy:

* **APIs**:

  * Typically expose a fixed set of methods.
  * Require developers to know the exact endpoints, payloads, and response structures.
  * Tight coupling between the client and service.

* **SDKs**:

  * Libraries that simplify API usage.
  * Often language- or platform-specific.
  * Require updates and maintenance to stay in sync with the service.

* **MCP**:

  * Defines a **universal protocol** where clients and servers negotiate capabilities at runtime.
  * Clients don’t need hardcoded knowledge of APIs—servers announce what they can do.
  * Promotes **interoperability**: one client can interact with multiple servers without bespoke integrations.
  * Encourages **extensibility**: new tools or resources can be plugged into the ecosystem without rewriting clients or models.

In essence, MCP reduces integration friction by standardizing the way context is exchanged, where traditional APIs/SDKs require custom engineering effort for each integration.

---

