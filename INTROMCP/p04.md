# **Chapter 4. MCP Data Structures**

The Model Context Protocol (MCP) relies on well-defined data structures to ensure consistency, portability, and interoperability across diverse client and server implementations. By standardizing how **context objects**, **metadata**, and **schemas** are represented, MCP provides a foundation for reliable context exchange between models and their external sources.

---

## 4.1 Context Objects and Metadata

At the core of MCP are **context objects**—structured data units that represent relevant external information (such as a file, database entry, or sensor reading) in a standardized form. Each context object typically contains:

* **Identifier**
  A unique reference (e.g., URI, hash, or composite key) that allows systems to retrieve or update the object.

* **Type**
  The semantic category of the object (e.g., `file`, `database_row`, `api_response`, `sensor_measurement`). This helps models interpret the object’s role.

* **Payload**
  The raw or transformed content, such as text, JSON, or binary data.

* **Metadata**
  Supplementary information about the object, such as:

  * Source (system, server, or API endpoint)
  * Timestamps (creation, modification, expiration)
  * Provenance (lineage, transformation history)
  * Access control (permissions, visibility)
  * Reliability indicators (confidence scores, validation flags)

By packaging metadata with content, MCP enables models not only to consume data but also to **reason about its trustworthiness, origin, and intended use.**

---

## 4.2 Schema Definitions and Validation

To guarantee consistency across implementations, MCP specifies schemas that describe the **shape and constraints** of context objects.

* **Schema Languages**
  JSON Schema or similar specification languages are commonly used to define object formats.

* **Validation**
  Clients and servers are expected to validate objects against schemas before transmission, ensuring that:

  * Required fields are present.
  * Data types (string, number, object, array) are correct.
  * Constraints (e.g., `minLength`, `enum`, `pattern`) are respected.

* **Extensibility**
  Schemas allow custom extensions while maintaining backward compatibility. For instance, a `file` context may be extended with domain-specific metadata (`language`, `encoding`, `project_id`) without breaking existing systems.

Validation enforces **predictability**, reducing errors and ambiguities in context exchange.

---

## 4.3 Examples of Standard Context Types

MCP defines a set of **standard context types** to cover common use cases. Below are illustrative categories:

### (a) Files

* **Type:** `file`
* **Payload:** raw file content or reference (path/URI)
* **Metadata:** filename, filetype (MIME), size, last modified timestamp

*Example:*

```json
{
  "id": "file://project/data.csv",
  "type": "file",
  "payload": "col1,col2\n1,2\n3,4",
  "metadata": {
    "filename": "data.csv",
    "filetype": "text/csv",
    "size": 24,
    "last_modified": "2025-09-19T09:45:00Z"
  }
}
```

---

### (b) Databases

* **Type:** `database_row` or `query_result`
* **Payload:** structured data (rows, JSON)
* **Metadata:** database type, query string, schema version, timestamp

*Example:*

```json
{
  "id": "db://patients/row/123",
  "type": "database_row",
  "payload": {
    "patient_id": 123,
    "name": "Alice",
    "diagnosis": "Hypertension"
  },
  "metadata": {
    "database": "patients_db",
    "schema_version": "v2.1",
    "retrieved_at": "2025-09-19T10:00:00Z"
  }
}
```

---

### (c) Web APIs

* **Type:** `api_response`
* **Payload:** JSON or XML returned from a web API
* **Metadata:** API endpoint, request parameters, response status, rate-limit headers

*Example:*

```json
{
  "id": "api://weather/london",
  "type": "api_response",
  "payload": {
    "temperature": 18,
    "condition": "Cloudy"
  },
  "metadata": {
    "endpoint": "https://api.weather.com/v1/london",
    "method": "GET",
    "status": 200,
    "retrieved_at": "2025-09-19T09:55:00Z"
  }
}
```

---

### (d) Sensors

* **Type:** `sensor_measurement`
* **Payload:** numeric readings (temperature, heart rate, motion, etc.)
* **Metadata:** sensor type, units, calibration reference, timestamp, device ID

*Example:*

```json
{
  "id": "sensor://device123/temp",
  "type": "sensor_measurement",
  "payload": 36.7,
  "metadata": {
    "sensor_type": "temperature",
    "unit": "Celsius",
    "device_id": "device123",
    "timestamp": "2025-09-19T09:50:00Z"
  }
}
```

---

## 4.4 Summary

MCP data structures provide a **uniform language** for representing external information in a way that is structured, validated, and extensible. By embedding both **content and metadata**, they enable AI models to interact with files, databases, APIs, and sensors while preserving context about **origin, reliability, and semantics**.

This foundation is essential for ensuring **trustworthy and portable context exchange** across heterogeneous AI ecosystems.

---

