# Chapter 4: Quantifiers and Repetitions

Quantifiers allow you to specify **how many times a pattern should occur** in a string. They make regular expressions powerful for handling repetitions.

---

## 5.1 Common Quantifiers

| Quantifier | Meaning                         | Example Pattern | Matches                     |
| ---------- | ------------------------------- | --------------- | --------------------------- |
| `*`        | 0 or more repetitions           | `a*`            | `""`, `"a"`, `"aaa"`        |
| `+`        | 1 or more repetitions           | `a+`            | `"a"`, `"aaa"` but not `""` |
| `?`        | 0 or 1 repetition (optional)    | `a?`            | `""`, `"a"`                 |
| `{n}`      | Exactly *n* repetitions         | `a{3}`          | `"aaa"`                     |
| `{n,}`     | At least *n* repetitions        | `a{2,}`         | `"aa"`, `"aaa"`, `"aaaa"`   |
| `{n,m}`    | Between *n* and *m* repetitions | `a{2,4}`        | `"aa"`, `"aaa"`, `"aaaa"`   |

---

### Example 1: `*` (Zero or More)

```python
import re

pattern = r"ab*"
strings = ["a", "ab", "abb", "abbb", "ac"]

for s in strings:
    match = re.fullmatch(pattern, s)
    print(s, "→", bool(match))
```

**Output:**

```
a → True
ab → True
abb → True
abbb → True
ac → False
```

---

### Example 2: `+` (One or More)

```python
pattern = r"ab+"
strings = ["a", "ab", "abb", "ac"]

for s in strings:
    match = re.fullmatch(pattern, s)
    print(s, "→", bool(match))
```

**Output:**

```
a → False
ab → True
abb → True
ac → False
```

---

### Example 3: `?` (Zero or One)

```python
pattern = r"ab?"
strings = ["a", "ab", "abb"]

for s in strings:
    match = re.fullmatch(pattern, s)
    print(s, "→", bool(match))
```

**Output:**

```
a → True
ab → True
abb → False
```

---

### Example 4: `{n,m}` (Range of Repetitions)

```python
pattern = r"a{2,4}"
strings = ["a", "aa", "aaa", "aaaa", "aaaaa"]

for s in strings:
    match = re.fullmatch(pattern, s)
    print(s, "→", bool(match))
```

**Output:**

```
a → False
aa → True
aaa → True
aaaa → True
aaaaa → False
```

---

## 5.2 Greedy vs Lazy Matching

By default, regex quantifiers are **greedy** — they try to match as many characters as possible.
A **lazy quantifier** (with `?`) tries to match as few as possible.

| Pattern | Behavior                                  |
| ------- | ----------------------------------------- |
| `.*`    | Greedy — matches as much text as possible |
| `.*?`   | Lazy — matches as little text as possible |

---

### Example 5: Greedy vs Lazy

```python
text = "<tag>content</tag><tag>more</tag>"

# Greedy: .* grabs everything until the last </tag>
greedy = re.findall(r"<tag>.*</tag>", text)

# Lazy: .*? stops at the first possible </tag>
lazy = re.findall(r"<tag>.*?</tag>", text)

print("Greedy:", greedy)
print("Lazy:", lazy)
```

**Output:**

```
Greedy: ['<tag>content</tag><tag>more</tag>']
Lazy: ['<tag>content</tag>', '<tag>more</tag>']
```

---

✅ **Key Takeaways**

* Use quantifiers to control repetitions.
* Default is **greedy matching**.
* Add `?` for **lazy (minimal) matching**.
* `{n,m}` gives precise control over the number of repetitions.

---
