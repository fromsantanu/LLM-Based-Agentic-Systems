# Chapter 9: Compiling Regular Expressions

When working with regular expressions in Python, you can use functions like `re.search()`, `re.match()`, and `re.findall()` directly with pattern strings. However, if you need to reuse the same regex pattern multiple times, it’s more efficient to **compile the regex** once and reuse it.

This is done with `re.compile()`.

---

## 1. Why Use `re.compile()`?

* **Performance**: Compiling once avoids recompiling the regex each time it’s used.
* **Reusability**: The compiled object can be applied with multiple methods (`match()`, `search()`, `findall()`, `sub()`).
* **Readability**: Code becomes cleaner when the regex logic is separated from the usage.

---

## 2. Basic Syntax

```python
import re

pattern = re.compile(r"\d+")  # matches one or more digits
```

* `pattern` is now a **compiled regex object**.
* You can reuse it across different operations.

---

## 3. Using a Compiled Regex with `.match()` and `.search()`

```python
import re

# Compile the regex
pattern = re.compile(r"\bcat\b")

# Match at the start
print(pattern.match("cat in the hat"))  
# <re.Match object ...>

print(pattern.match("the cat in the hat"))  
# None (not at start)

# Search anywhere in the string
print(pattern.search("the cat in the hat"))  
# <re.Match object ...>
```

✅ `pattern.match()` checks only the beginning.
✅ `pattern.search()` checks anywhere in the string.

---

## 4. Using `.findall()` and `.sub()` with a Compiled Regex

```python
import re

pattern = re.compile(r"\d+")

# Find all numbers
text = "There are 12 apples, 30 bananas, and 45 oranges."
print(pattern.findall(text))
# ['12', '30', '45']

# Substitute numbers with 'X'
print(pattern.sub("X", text))
# There are X apples, X bananas, and X oranges.
```

---

## 5. Flags with `re.compile()`

You can pass flags like `re.IGNORECASE` when compiling.

```python
import re

pattern = re.compile(r"hello", re.IGNORECASE)

print(pattern.match("Hello world"))  # Match despite capital H
print(pattern.match("HELLO world"))  # Match again
```

---

## 6. Real-Life Example: Email Validator

```python
import re

# Compile regex once
email_pattern = re.compile(r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}")

emails = [
    "user@example.com",
    "contact@my-site.org",
    "not-an-email",
]

for email in emails:
    if email_pattern.fullmatch(email):
        print(f"Valid: {email}")
    else:
        print(f"Invalid: {email}")
```

**Output:**

```
Valid: user@example.com
Valid: contact@my-site.org
Invalid: not-an-email
```

---

## 7. When to Use `re.compile()`

* When applying the same regex multiple times (e.g., validating thousands of emails).
* When readability matters (pattern is defined once, reused everywhere).
* When working with **complex regex patterns** that need to be shared across functions.

---

✅ **Summary**:
`re.compile()` improves performance, reusability, and readability by creating a regex object that can be reused with `match()`, `search()`, `findall()`, and `sub()` methods.

---
