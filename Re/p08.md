# Chapter 8 — Splitting Strings with Regex

**Topic:** `re.split()` with complex delimiters

Python’s built-in `str.split()` handles only one simple delimiter (or whitespace). `re.split()` lets you break text on **patterns**: multiple delimiters, variable spacing, punctuation, lookarounds, Unicode classes, etc.

---

## 1) Quick start: multiple delimiters

```python
import re

text = "apples, oranges; bananas | grapes"
parts = re.split(r"[;,|]\s*", text)
print(parts)  # ['apples', 'oranges', 'bananas', 'grapes']
```

* Pattern `[;,|]` = any of `; , |`
* `\s*` trims optional spaces after the delimiter

---

## 2) Contrast with `str.split()`

```python
text = "a,b; c|d"
print(text.split(","))             # ['a', 'b; c|d']  (can’t split on ; or |)
print(re.split(r"[;,|]\s*", text)) # ['a', 'b', 'c', 'd']
```

---

## 3) Keeping the delimiters (capturing groups)

If you want to **retain** the separators, put them in a **capturing group**.

```python
text = "A;B,C|D"
parts = re.split(r"([;,|])", text)
print(parts)  # ['A', ';', 'B', ',', 'C', '|', 'D']
```

Tip: If you don’t want them in the result, make the group **non-capturing**: `(?:...)`.

---

## 4) Trimming and keeping: rejoin later

```python
text = "x,  y ; z | w"
tokens = [t.strip() for t in re.split(r"([;,|])", text) if t.strip() != ""]
print(tokens)  # ['x', ',', 'y', ';', 'z', '|', 'w']
```

---

## 5) Limit splits with `maxsplit`

```python
text = "key1=value1; key2=value2; key3=value3"
first, rest = re.split(r"\s*;\s*", text, maxsplit=1)
print(first)  # key1=value1
print(rest)   # key2=value2; key3=value3
```

---

## 6) Case-insensitive & other flags

```python
text = "ID:abc; id:def; Id:ghi"
print(re.split(r"id:", text, flags=re.IGNORECASE))  
# ['', 'abc; ', 'def; ', 'ghi']
```

(Empty leading item appears because the string starts with the delimiter—handle with post-filtering if needed.)

---

## 7) Splitting on **runs** of delimiters (collapse repeats)

```python
text = "a,,,b;;;c||d"
print(re.split(r"[;,|]+", text))  # ['a', 'b', 'c', 'd']
```

---

## 8) Preserve **empty fields** (e.g., CSV-like gaps)

```python
text = "Alice,,Bob, ,Charlie,"
fields = re.split(r",", text)  # keep empties
print(fields)  # ['Alice', '', 'Bob', ' ', 'Charlie', '']
# Optional cleanup:
clean = [f.strip() for f in fields]
print(clean)   # ['Alice', '', 'Bob', '', 'Charlie', '']
```

> Note: For real CSV (quotes, escapes), use the `csv` module.

---

## 9) Split by punctuation **but not inside quotes**

Useful when comma/semicolon appears inside quotes.

```python
text = 'Name="Khan, S.", Age=42; City="Kolkata; India"; Role=Lead'
pattern = r""",(?![^"]*"[^"]*(?:"[^"]*"[^"]*)*$)"""  # commas not inside quotes
print(re.split(pattern, text))
# ['Name="Khan, S."', ' Age=42; City="Kolkata; India"; Role=Lead']
```

Explanation: Negative lookahead ensures the comma isn’t within a balanced set of `"` pairs in the remainder of the string.

---

## 10) Split on word boundaries with **lookarounds**

### a) Split **before** an uppercase word (CamelCase → tokens)

```python
text = "HTTPServerErrorOccurred"
parts = re.split(r"(?=[A-Z][a-z]+)", text)
print(parts)  # ['HTTP', 'Server', 'Error', 'Occurred']
```

### b) Split **after** period that ends a sentence

```python
text = "It rains in July. Often heavily. Roads flood!"
sentences = re.split(r"(?<=[.!?])\s+", text)
print(sentences)  # ['It rains in July.', 'Often heavily.', 'Roads flood!']
```

---

## 11) Split by **positions** instead of characters (pure lookarounds)

```python
text = "key1=value1&key2=value2&key3=value3"
pairs = re.split(r"(?<=\d)&(?=key)", text)  # split only between ...digit & 'key'
print(pairs)  # ['key1=value1', 'key2=value2', 'key3=value3']
```

---

## 12) Unicode-aware splitting (letters vs non-letters)

```python
text = "नमस्ते-India_2025！こんにちは"
# Split on sequences of non-letters (Unicode), keep letters
words = [w for w in re.split(r"[^\p{L}]+", text, flags=re.UNICODE) if w]
print(words)  # Requires regex module for \p{L}; see note below.
```

> **Note:** Python’s built-in `re` doesn’t support `\p{L}`.
> Use the third-party `regex` package (`pip install regex`) or approximate with:

```python
import re
words = [w for w in re.split(r"[^A-Za-z]+", "Hola-India_2025!") if w]
```

---

## 13) Tokenizing on **words** and **non-words** (keep punctuation)

```python
text = "Hello, world! 42 times."
tokens = re.split(r"(\W+)", text)  # capture non-word runs
print(tokens)  # ['Hello', ', ', 'world', '!  ', '42', ' ', 'times', '.', '']
```

---

## 14) Split on **date/phone separators**

```python
date = "2025/09-28.11"
print(re.split(r"[/\-.]", date))  # ['2025', '09', '28', '11']

phone = "+91-98300-12345"
print(re.split(r"[^\d]+", phone)) # ['','91','98300','12345'] → filter empties
```

---

## 15) Handling leading/trailing delimiters & empties

Common post-processing patterns:

```python
parts = re.split(r"[;,|]\s*", ";a;b;")
parts = [p for p in parts if p]       # drop empties
# or
parts = list(filter(None, parts))
```

---

## 16) Performance tips

* Prefer **character classes** and **quantifiers** (`[;,|]+`) to avoid backtracking.
* Use **anchored lookarounds** when splitting at positions rather than matching big chunks.
* Pre-compile for hot paths:

```python
SPLIT = re.compile(r"[;,|]\s*")
def smart_split(s: str) -> list[str]:
    return SPLIT.split(s)
```

---

## 17) When **not** to use `re.split()`

* Fully fledged CSV/TSV with quoting/escaping → `csv` module.
* HTML/XML parsing → proper parsers (`html.parser`, `xml`, `BeautifulSoup`).
* Natural-language sentence segmentation → NLP libraries (e.g., spaCy) handle abbreviations.

---

## Practice snippets

### A) Split a query string into key=value pairs

```python
q = "a=1&&b=2&c=&d=hello%20world"
pairs = [p for p in re.split(r"&+", q) if p]  # collapse && and drop empties
print(pairs)  # ['a=1', 'b=2', 'c=', 'd=hello%20world']
```

### B) Split *on commas* but **not** commas inside parentheses

```python
s = "fn(a,b), x, y, g(h(i,j),k), z"
parts = re.split(r",\s*(?![^()]*\))", s)
print(parts)  # ['fn(a,b)', 'x', 'y', 'g(h(i,j),k)', 'z']
```

### C) Split a log line into timestamp | level | message

```python
log = "2025-09-28 11:05:33, INFO  : Job started"
ts, level, msg = re.split(r"\s*,\s*|\s*:\s*", log, maxsplit=2)
print(ts)    # '2025-09-28 11:05:33'
print(level) # 'INFO'
print(msg)   # 'Job started'
```

---

## Key takeaways

* Use `re.split()` when delimiters are **many**, **variable**, or **contextual**.
* **Capturing group** to keep delimiters; **non-capturing** `(?:...)` to ignore.
* **Lookarounds** let you split **at positions** without consuming any characters.
* Be mindful of **leading/trailing empties** and **quoted/contextual** text—handle with lookarounds or post-filters.

