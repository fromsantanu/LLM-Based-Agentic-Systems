# Chapter 2 — Basic Pattern Matching

## What you’ll learn

* How `re.match()`, `re.search()`, and `re.findall()` differ
* Quick, practical examples on common strings
* A few handy flags and gotchas (so you don’t get tripped up)

---

## Quick contrast

| Function     | Where it looks                      | What it returns                          | Typical use                      |
| ------------ | ----------------------------------- | ---------------------------------------- | -------------------------------- |
| `re.match`   | **Start** of the string only        | `Match` object or `None`                 | Validate a prefix / whole string |
| `re.search`  | **Anywhere** in the string          | `Match` object or `None`                 | Find the **first** occurrence    |
| `re.findall` | **All** non-overlapping occurrences | `list[str]` or `list[tuple]` (if groups) | Get **all** matches at once      |

> Tip: Prefer compiled patterns for reuse: `pat = re.compile(r"...")`, then `pat.search(text)` etc.

---

## `re.match()` — must start at index 0

```python
import re

text = "ID: A12345 issued"
m1 = re.match(r"A\d+", text)           # None (doesn't start with 'A')
m2 = re.match(r"ID:\s*A\d+", text)     # Match at the beginning

print(m1)  # None
print(bool(m2), m2.group())  # True, 'ID: A12345'
```

Common use: quick input validation that must begin with a specific pattern (or matches the whole string with `^...$`).

---

## `re.search()` — first hit anywhere

```python
import re

text = "User john_doe logged in at 10:05"
m = re.search(r"\b[a-z_]+\b", text)   # first word-like token
print(m.group())  # 'User'

m2 = re.search(r"\b\d{2}:\d{2}\b", text)
print(m2.group()) # '10:05'
```

Use this when the location inside the string is unknown.

---

## `re.findall()` — get all the hits

```python
import re

text = "Errors: E101, E404, E500; retried 3 times."
codes = re.findall(r"E\d{3}", text)
print(codes)  # ['E101', 'E404', 'E500']

# With capture groups -> list of tuples
dates = "Due: 2024-09-01, 2025-01-15"
parts = re.findall(r"(\d{4})-(\d{2})-(\d{2})", dates)
print(parts)  # [('2024','09','01'), ('2025','01','15')]
```

---

## Side-by-side example

```python
import re
text = "Order #A12 shipped; Order #B77 pending."

pattern = r"#([A-Z])(\d+)"   # group1: letter, group2: number

print(re.match(pattern, text))         # None (not at start)
print(re.search(pattern, text).groups())   # ('A', '12')
print(re.findall(pattern, text))           # [('A','12'), ('B','77')]
```

---

## Useful anchors & tokens (tiny sampler)

* `^` start of string, `$` end of string
* `.` any char except newline (unless `re.S`)
* `\d` digit, `\w` word char, `\s` whitespace
* `+` one or more, `*` zero or more, `?` zero or one
* `[]` character class, e.g. `[A-F0-9]`
* `\b` word boundary

### Mini-examples

```python
import re

print(bool(re.match(r"^\d{4}-\d{2}-\d{2}$", "2025-09-28")))  # True
print(bool(re.search(r"\bcat\b", "scatter category")))       # False (exact word)
print(re.findall(r"\b\w{4}\b", "Many dogs bark loud"))       # ['Many', 'dogs', 'bark']
```

---

## Flags you’ll use a lot

* `re.I` / `re.IGNORECASE` – case-insensitive
* `re.M` / `re.MULTILINE` – `^`/`$` match at each line boundary
* `re.S` / `re.DOTALL` – `.` matches newline too

```python
import re

text = "Alpha\nbeta\nGAMMA"
print(re.findall(r"^[a-z]+$", text, flags=re.M|re.I))  # ['Alpha', 'beta', 'GAMMA']

para = "Title: Hello\n\nBody line 1.\nBody line 2."
m = re.search(r"Title:.*Body.*2\.", para, flags=re.S)
print(bool(m))  # True ('.' spans newlines)
```

---

## `finditer()` when you want positions (and big texts)

```python
import re

text = "x=12; y=7; z=105"
for m in re.finditer(r"\d+", text):
    print(m.group(), "at", m.start(), "to", m.end())
# 12 at 2 to 4
# 7 at 8 to 9
# 105 at 14 to 17
```

---

## Common gotchas (so you don’t debug for hours)

1. **`match` ≠ “find anywhere”**: it only checks index 0. Use `search` for anywhere.
2. **`findall` with groups** returns **tuples** (use non-capturing groups `(?:...)` if you just want the whole match).
3. By default `.` does **not** match newlines—use `re.S` if needed.
4. Use raw strings `r"..."` for patterns (`"\n"`, `"\t"` vs `r"\n"`, `r"\t"`).

```python
import re

text = "E101 E202"
print(re.findall(r"E(\d+)", text))        # ['101', '202']  (only the group)
print(re.findall(r"E(?:\d+)", text))      # ['E101', 'E202'] (non-capturing)
```

---

## Tiny practice (try mentally or in a REPL)

1. Extract all 10-digit numbers from:
   `"Call me at 9876543210 or 9123456789."`
   *Hint*: `r"\b\d{10}\b"`

2. Check if a string looks like a valid variable name (starts with letter or `_`, then letters/digits/`_`):
   *Hint*: `r"^[A-Za-z_]\w*$"`

3. Grab all hashtags from:
   `"Loving #Python and #regex on #Sunday!"`
   *Hint*: `r"#\w+"`

---

### Takeaways

* Use **`match`** for strict “must start with…”, **`search`** to locate the **first** hit anywhere, and **`findall`** to collect **all** hits.
* Lean on anchors, word boundaries, and flags to make patterns precise and readable.
* Prefer **compiled patterns** when applying the same regex many times.


