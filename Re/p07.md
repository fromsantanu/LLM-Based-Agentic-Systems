# Chapter 7 — Substitution and Replacement

Python’s `re.sub()` lets you **search for a pattern** and **replace** each match with:

* a **string** (with backreferences), or
* a **function** (computed per match).

You’ll use it for cleanup, normalization, redaction, and light-ETL tasks.

---

## 1) `re.sub()` Basics

**Signature**

```python
re.sub(pattern, repl, string, count=0, flags=0)
```

* `pattern`: regex to find.
* `repl`: replacement string **or** a callable `(match) -> str`.
* `count`: max number of replacements (0 = all).
* `flags`: regex flags (e.g., `re.I`, `re.M`).
* Returns the **new string**.

### Example: normalize whitespace

```python
import re

text = "A   tidy   string \t with   odd   spaces."
print(re.sub(r"\s+", " ", text).strip())
# A tidy string with odd spaces.
```

### Limit replacements with `count`

```python
s = "1-2-3-4-5"
print(re.sub(r"-", ":", s, count=2))  # only first two hyphens
# 1:2:3-4-5
```

---

## 2) Backreferences in the Replacement String

You can reuse captured groups in `repl`.

* **Numbered**: `\1`, `\2`, …
* **Named**: `\g<name>` (recommended; also works for numbers: `\g<1>`)

> Prefer `\g<name>` to avoid ambiguity when digits follow.

### Example: swap “Last, First” → “First Last”

```python
s = "Doe, John; Smith, Alice"
print(re.sub(r"\b(\w+),\s+(\w+)\b", r"\2 \1", s))
# John Doe; Alice Smith
```

### Example: use **named groups**

```python
s = "color: #1a2B3c"
pat = r"#(?P<r>[0-9a-fA-F]{2})(?P<g>[0-9a-fA-F]{2})(?P<b>[0-9a-fA-F]{2})"
print(re.sub(pat, r"rgb(\g<r>, \g<g>, \g<b>)", s))
# color: rgb(1a, 2B, 3c)
```

### Escaping backslashes in `repl`

Use **raw strings** or double slashes:

```python
print(re.sub(r"\\", "/", r"path\to\file"))   # raw input example
# path/to/file
```

---

## 3) `re.subn()` — also get the count

`re.subn()` returns `(new_string, number_of_replacements)`.

```python
s = "spam spam eggs spam"
result, n = re.subn(r"\bspam\b", "ham", s)
print(result, n)
# ham ham eggs ham 3
```

---

## 4) Compiled Patterns: `.sub()` / `.subn()`

```python
pat = re.compile(r"\bcat\b", flags=re.I)
print(pat.sub("dog", "Cat scat catalog cat!"))
# dog scat catalog dog!
```

---

## 5) Applying **Functions** inside Substitutions

Pass a function (or lambda) as `repl`. It receives a `re.Match` and returns the replacement string. This is powerful for **conditional** or **computed** replacements.

### Example A: title-case every word after a dash

```python
def title_after_dash(m: re.Match) -> str:
    return m.group(1) + m.group(2).title()

s = "alpha-beta gamma-dELTA omega"
print(re.sub(r"(-)([a-zA-Z]+)", title_after_dash, s))
# alpha-Beta gamma-DELTA omega
```

### Example B: increment all numbers by 1

```python
def inc(m: re.Match) -> str:
    return str(int(m.group(0)) + 1)

print(re.sub(r"\d+", inc, "v1.9 build 041"))
# v2.10 build 42
```

### Example C: redact emails but keep domain

```python
def mask_email(m: re.Match) -> str:
    user, domain = m.group("user"), m.group("domain")
    masked = user[0] + "*"*(max(len(user)-2, 1)) + user[-1]
    return f"{masked}@{domain}"

pat = r"(?P<user>[A-Za-z0-9._%+-]+)@(?P<domain>[A-Za-z0-9.-]+\.[A-Za-z]{2,})"
print(re.sub(pat, mask_email, "Contact: alice.smith@univ.edu, bob@x.io"))
# Contact: a*********h@univ.edu, b*b@x.io
```

### Example D: dictionary-driven normalization

```python
mapping = {"st.": "street", "rd.": "road", "ave.": "avenue"}

def expand(m: re.Match) -> str:
    return mapping[m.group(0).lower()]

s = "12 Main St., 4th Ave., 7 Oak Rd."
print(re.sub(r"\b(?:St\.|Rd\.|Ave\.)\b", expand, s, flags=re.I))
# 12 Main street, 4th avenue, 7 Oak road.
```

### Example E: keep only first character of each word (initials)

```python
def initials(m: re.Match) -> str:
    return m.group(0)[0]

print(re.sub(r"[A-Za-z]+", initials, "John Ronald Reuel Tolkien"))
# J R R T
```

---

## 6) Using Match Data in the Callable

All `re.Match` features are available:

* `m.group()`, `.groups()`, `.groupdict()`
* `m.start()`, `m.end()`, `m.span()`
* `m.re` (pattern), `m.string` (original text)

### Example: add thousands separators for big numbers only

```python
def comma_big(m: re.Match) -> str:
    n = int(m.group(0))
    return f"{n:,}" if n >= 1000 else m.group(0)

print(re.sub(r"\d+", comma_big, "IDs: 7, 42, 1000, 250000"))
# IDs: 7, 42, 1,000, 250,000
```

---

## 7) Flags & Multiline/Case Handling

```python
text = "Item: apple\nitem: Banana"
print(re.sub(r"^item:\s*", "", text, flags=re.I | re.M))
# apple
# Banana
```

---

## 8) Common Pitfalls & Tips

1. **Use raw strings** for patterns and sometimes for replacements:

```python
r"\b\d+\b"   # safer than "\\b\\d+\\b"
```

2. **Ambiguous backrefs**: prefer `\g<1>` or `\g<name>`:

```python
re.sub(r"(a)(b)", r"\g<1>0\g<2>", "ab")  # avoids "\10" confusion
```

3. **Greedy vs lazy** affects how much is replaced:

```python
s = "<b>bold</b><b>more</b>"
print(re.sub(r"<b>.*</b>", "", s))       # greedy → removes everything
print(re.sub(r"<b>.*?</b>", "", s))      # lazy  → removes tags separately
```

4. **Performance**: compile patterns used repeatedly and avoid catastrophic patterns (e.g., nested `.*` with backtracking).

5. **Use `subn` when you need counts** for logging/metrics.

---

## 9) Mini Use-Case Recipes

### Normalize phone numbers

```python
s = "Call: (033) 2414-1234, +91-98765 43210"
digits_only = re.sub(r"\D+", "", s)                 # keep digits
print(re.sub(r"(\d{2})(\d{10})", r"+\1 \2", digits_only))
# +91 03324141234 9876543210   (post-process as needed)
```

### Strip HTML tags (quick-and-dirty)

```python
html = "<p>Hello <b>World</b></p>"
print(re.sub(r"<[^>]+>", "", html))
# Hello World
```

### Collapse repeated punctuation

```python
print(re.sub(r"([!?.,])\1+", r"\1", "Wow!!! Really??.."))
# Wow! Really?.
```

### Tokenize words (replace non-letters with space, then split)

```python
clean = re.sub(r"[^A-Za-z]+", " ", "Life,42—and everything!")
print(clean.lower().split())
# ['life', 'and', 'everything']
```

---

## 10) Exercises

1. **Kebab to snake**: Convert `my-variable-name` → `my_variable_name`.
2. **Mask numbers**: Replace every 16-digit sequence with `****-****-****-****` but keep last 4 visible.
3. **Smart case**: In a sentence, uppercase any word matched by `\b(ai|ml|nlp)\b` (case-insensitive).
4. **Selective commas**: Add commas to numbers ≥ 10,000 only (via callable).
5. **Swap dates**: Convert `DD/MM/YYYY` to `YYYY-MM-DD` using backreferences.

*Try to implement both a backreference-based solution and a callable-based solution where appropriate.*

---

### Quick Reference

* **String replacement**: `re.sub(p, repl, s, count=0, flags=0)`
* **Backrefs**: `\1`, `\2`, … or `\g<name>` / `\g<1>`
* **With function**: `re.sub(p, lambda m: ..., s)`
* **Also get count**: `re.subn(...) -> (new_s, n)`
* **Compile**: `pat = re.compile(p); pat.sub(...)`

You’re now set to **clean, reshape, and enrich text** with precise, programmable replacements.

