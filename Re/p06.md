# Chapter 6 — Grouping & Capturing

Parentheses in regular expressions do two big things:

1. **Group** parts of a pattern, controlling precedence and repetition.
2. **Capture** the text matched by that part so you can retrieve or reuse it.

We’ll cover:

* Plain capturing groups `(...)`
* Named groups `(?P<name>...)`
* Access with `.group()`, `.groups()`, `.groupdict()`
* Numbering rules, nesting, non-capturing `(?:...)`
* Backreferences (`\1`, `(?P=name)`)
* How groups affect `re.findall`, `re.sub`, and `re.split`

---

## 6.1 Basic Capturing Groups `(...)`

```python
import re

m = re.search(r'(\d{4})-(\d{2})-(\d{2})', 'Report: 2025-09-28 ready')
if m:
    print(m.group(0))  # full match
    print(m.group(1))  # '2025'
    print(m.group(2))  # '09'
    print(m.group(3))  # '28'
    print(m.groups())  # ('2025', '09', '28')
```

**Notes**

* `group(0)` is always the **entire** match.
* Groups are numbered left-to-right by their **opening parenthesis**.
* `.groups()` returns a tuple of all captured subgroups (excluding group 0).

---

## 6.2 Named Groups `(?P<name>...)`

Named groups make your code clearer and easier to maintain.

```python
import re

pat = re.compile(r'(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})')
m = pat.search('DOB=1988-07-19; ID=42')
if m:
    print(m.group('year'), m.group('month'), m.group('day'))   # 1988 07 19
    print(m.groupdict())   # {'year': '1988', 'month': '07', 'day': '19'}
```

* Access by name: `m.group('year')`
* Get all named captures: `m.groupdict()`

---

## 6.3 Grouping for Precedence & Repetition

Parentheses also **group** for operators like `|`, `*`, `+`, `?`, `{m,n}`.

```python
import re

# 'Nov 2025' or 'November 2025'
pat = re.compile(r'(Nov|November)\s+\d{4}')
print(bool(pat.search('Starts November 2025')))  # True
print(bool(pat.search('Starts Nov 2025')))       # True

# Repeat the whole grouped token
print(re.findall(r'(ha)+', 'hahaha!'))  # ['ha']  → last captured iteration
```

> Tip: `re.findall(r'(ha)+', ...)` returns the **last** iteration captured by the group. If you want the whole repeated span, use `group(0)` from a `finditer()` match.

---

## 6.4 Non-Capturing Groups `(?:...)`

Use these when you want grouping **without capturing** (cleaner results & faster).

```python
import re

s = 'Nov 2025, Dec 2025'
print(re.findall(r'(Nov|Dec)\s+\d{4}', s))   # ['Nov', 'Dec']  (captures names)
print(re.findall(r'(?:Nov|Dec)\s+\d{4}', s)) # ['Nov 2025', 'Dec 2025'] (no subgroups)
```

* Non-capturing groups don’t create group numbers or entries in `.groups()`.

---

## 6.5 Numbering & Nesting

```python
import re

m = re.search(r'((\d{4})-(\d{2})-(\d{2}))', 'x=2023-12-05')
if m:
    # 0: whole match; 1: outer date; 2: year; 3: month; 4: day
    print(m.group(1), m.group(2), m.group(3), m.group(4))
```

Group numbers are assigned by the order of opening `(`. Nested groups are fine; just mind the numbering.

---

## 6.6 Backreferences: Reusing Captures

### By number: `\1`, `\2`, …

```python
import re

# Match repeated words like "go go" or "time time"
repeated = re.compile(r'\b(\w+)\s+\1\b', re.IGNORECASE)
print(bool(repeated.search('It is what it is')))          # True ("is is")
print(repeated.findall('go Go GO stop'))                  # ['go']
```

### By name: `(?P=name)`

```python
import re

tag = re.compile(r'<(?P<tag>\w+)>(.*?)</(?P=tag)>')
print(bool(tag.search('<b>bold</b>')))       # True
print(bool(tag.search('<b>mismatch</i>')))   # False
```

> Backreferences ensure symmetry, e.g., opening/closing HTML-like tags, paired quotes, duplicate fields, etc.

---

## 6.7 Using Groups in `re.sub`

* **Numbered** backref in replacement: `\1`, `\2`, …
* **Named** backref in replacement: `\g<name>`

```python
import re

# Swap 'Last, First' → 'First Last'
print(re.sub(r'(\w+),\s*(\w+)', r'\2 \1', 'Doe, Jane'))  # 'Jane Doe'

# Reformat date 'YYYY-MM-DD' → 'DD/MM/YYYY' using names
date_pat = re.compile(r'(?P<y>\d{4})-(?P<m>\d{2})-(?P<d>\d{2})')
print(date_pat.sub(r'\g<d>/\g<m>/\g<y>', '2025-09-28'))  # '28/09/2025'
```

> Prefer `\g<name>` or `\g<1>` style when adjacent to digits to avoid ambiguity (e.g., `\10` vs `\1` + literal `0`).

---

## 6.8 `findall` vs `finditer` with Groups

```python
import re

s = "ID=12; ID=77; ID=305;"
print(re.findall(r'ID=(\d+)', s))     # ['12', '77', '305']  (only submatch)
print([m.group(0) for m in re.finditer(r'ID=(\d+)', s)])  # ['ID=12', 'ID=77', 'ID=305']
print([m.groups() for m in re.finditer(r'ID=(\d+)', s)])  # [('12',), ('77',), ('305',)]
```

**Rule of thumb**

* If the pattern has **no** capturing groups, `findall` returns full strings.
* If the pattern **has** capturing groups, `findall` returns tuples (or a single string) of the captured groups.

---

## 6.9 Capturing Groups in `re.split`

Capturing groups are **kept** in the result of `re.split`.

```python
import re

s = "one, two; three|four"
print(re.split(r'([,;|])\s*', s))
# ['one', ',', 'two', ';', 'three', '|', 'four']
```

Use a **non-capturing** group `(?:[,;|])` if you don’t want the delimiters in the output.

---

## 6.10 Optional Groups & Missing Values

If an optional group doesn’t match, `.group(n)` returns `None`.

```python
import re

m = re.search(r'User:(\w+)(?:\s+\((\w+)\))?', 'User:alice')
print(m.groups())  # ('alice', None)
```

This is handy for patterns where a field may or may not be present.

---

## 6.11 Practical Patterns

### A) Parse Flexible Dates (named + alternation)

```python
import re

date_pat = re.compile(
    r'(?P<day>\d{1,2})[-/](?P<month>\d{1,2})[-/](?P<year>\d{2,4})'
)

for s in ["5-9-25", "05/09/2025", "31/12/1999"]:
    m = date_pat.fullmatch(s)
    if m:
        print(m.groupdict())
# {'day': '5', 'month': '9', 'year': '25'}
# {'day': '05', 'month': '09', 'year': '2025'}
# {'day': '31', 'month': '12', 'year': '1999'}
```

### B) Phone Number (capturing parts; optional country code)

```python
import re

phone = re.compile(
    r'(?:(\+?\d{1,3})[- ]?)?'   # optional country code (group 1)
    r'\(?(\\d{3})\)?[- ]?'      # area code (group 2)  ← note: escape backslash if raw not used
    r'(\d{3})[- ]?(\d{4})'      # local parts (groups 3 & 4)
)
```

> In real code prefer **raw strings** to avoid escape headaches:

```python
phone = re.compile(
    r'(?:(\+?\d{1,3})[- ]?)?'   # group 1
    r'\(?(\d{3})\)?[- ]?'       # group 2
    r'(\d{3})[- ]?(\d{4})'      # groups 3 & 4
)

m = phone.search("Call me at +1 (415) 555-2671")
print(m.groups())  # ('+1', '415', '555', '2671')
```

### C) Matching Paired Tags (backreference)

```python
import re

tagged = re.compile(r'<(?P<tag>\w+)>(.*?)</(?P=tag)>')
for s in ["<i>hi</i>", "<b>bold</i>"]:
    print(bool(tagged.fullmatch(s)))
# True, False
```

### D) Log Line Parsing (named groups + `.groupdict()`)

```python
import re

log_pat = re.compile(
    r'^(?P<ip>\d+\.\d+\.\d+\.\d+)\s+-\s+'
    r'\[(?P<ts>[^\]]+)\]\s+'
    r'"(?P<method>GET|POST|PUT|DELETE)\s+(?P<path>\S+)\s+HTTP/(?P<httpver>\d\.\d)"\s+'
    r'(?P<status>\d{3})\s+(?P<size>\d+|-)$'
)

line = '192.168.0.2 - [28/Sep/2025:09:00:01 +0530] "GET /index.html HTTP/1.1" 200 1234'
m = log_pat.search(line)
print(m.groupdict())
```

---

## 6.12 Common Pitfalls & Tips

* **Use raw strings** (`r'...'`) for patterns & replacements to avoid double escaping.
* Prefer **named groups** in large/complex patterns (more readable; safer than juggling numbers).
* Use **non-capturing groups** `(?:...)` for grouping only—this keeps `findall` outputs simple.
* Remember that **capturing inside a quantifier** like `(ha)+` captures only the **last** repeat.
* For replacements, prefer `\g<1>` / `\g<name>` to avoid backref ambiguity next to digits.

---

### Mini-Exercises

1. Write a pattern to capture **username** and optional **domain** from `alice` or `alice@example.com`.
2. Use `re.sub` to convert dates `DD-MM-YYYY` into `YYYY/MM/DD`.
3. Parse `key=value` pairs into a dict using named groups with `finditer()`.

---
