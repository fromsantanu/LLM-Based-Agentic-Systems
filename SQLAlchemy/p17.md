# **Chapter 17: Packaging and Reusability**

## **Overview**

As your application grows, maintaining clean and modular code becomes essential. This chapter focuses on building a **reusable architecture** for data access and persistence using SQLAlchemy. You’ll learn how to create a **Data Access Layer (DAL)**, implement the **Repository Pattern**, and maintain models in a modular way so that they can easily integrate across multiple applications or microservices.

---

## **17.1 Creating a Data Access Layer (DAL)**

### **What is the DAL?**

The **Data Access Layer (DAL)** abstracts the database operations away from the business logic.
It acts as a bridge between the database and the higher-level application modules.

**Purpose:**

* Encapsulates database access logic.
* Keeps ORM logic separate from business rules.
* Improves maintainability and testability.

### **Example Structure**

```
app/
├── dal/
│   ├── __init__.py
│   ├── base.py
│   ├── user_dal.py
│   └── product_dal.py
├── models/
│   ├── __init__.py
│   ├── user.py
│   └── product.py
└── main.py
```

### **Base DAL Example**

```python
# dal/base.py
from sqlalchemy.orm import Session

class BaseDAL:
    def __init__(self, db_session: Session):
        self.db = db_session
```

This `BaseDAL` class provides a foundation for all data access operations, accepting a SQLAlchemy session instance.

### **User DAL Example**

```python
# dal/user_dal.py
from sqlalchemy.orm import Session
from models.user import User
from .base import BaseDAL

class UserDAL(BaseDAL):
    def create_user(self, username: str, email: str):
        user = User(username=username, email=email)
        self.db.add(user)
        self.db.commit()
        self.db.refresh(user)
        return user

    def get_user_by_id(self, user_id: int):
        return self.db.query(User).filter(User.id == user_id).first()

    def delete_user(self, user_id: int):
        user = self.db.query(User).filter(User.id == user_id).first()
        if user:
            self.db.delete(user)
            self.db.commit()
            return True
        return False
```

This keeps all user-related queries in one place, independent of other logic.

---

## **17.2 Repository Pattern with SQLAlchemy**

### **What is the Repository Pattern?**

The **Repository Pattern** provides a **collection-like interface** for accessing domain objects.
It isolates the domain layer from data access logic, promoting **loose coupling** and **testability**.

**Analogy:**
The Repository acts like an **in-memory collection**, but actually retrieves data from the database.

---

### **Generic Repository Example**

```python
# repositories/base_repository.py
from sqlalchemy.orm import Session
from typing import Type, TypeVar, Generic, List

T = TypeVar('T')

class BaseRepository(Generic[T]):
    def __init__(self, db_session: Session, model: Type[T]):
        self.db = db_session
        self.model = model

    def get_all(self) -> List[T]:
        return self.db.query(self.model).all()

    def get_by_id(self, item_id: int) -> T:
        return self.db.query(self.model).filter(self.model.id == item_id).first()

    def add(self, obj: T) -> T:
        self.db.add(obj)
        self.db.commit()
        self.db.refresh(obj)
        return obj

    def delete(self, item_id: int) -> bool:
        obj = self.get_by_id(item_id)
        if obj:
            self.db.delete(obj)
            self.db.commit()
            return True
        return False
```

### **Specific Repository Example**

```python
# repositories/user_repository.py
from .base_repository import BaseRepository
from models.user import User

class UserRepository(BaseRepository[User]):
    def __init__(self, db_session):
        super().__init__(db_session, User)

    def find_by_email(self, email: str):
        return self.db.query(self.model).filter(self.model.email == email).first()
```

This way, `UserRepository` can reuse the CRUD logic from the base repository while providing user-specific queries.

---

### **Usage Example**

```python
# main.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models.base import Base
from repositories.user_repository import UserRepository
from models.user import User

engine = create_engine("sqlite:///app.db")
SessionLocal = sessionmaker(bind=engine)
Base.metadata.create_all(engine)

db = SessionLocal()
user_repo = UserRepository(db)

# Add a user
new_user = User(username="santanu", email="santanu@example.com")
user_repo.add(new_user)

# Query user
user = user_repo.find_by_email("santanu@example.com")
print(user.username)
```

---

## **17.3 Maintaining Models in Modular Architecture**

As projects expand, models are better maintained in **separate modules** for scalability and clarity.

### **Modular Structure Example**

```
app/
├── models/
│   ├── __init__.py
│   ├── user.py
│   ├── product.py
│   └── order.py
└── db/
    ├── base.py
    └── session.py
```

### **Combining All Models**

```python
# db/base.py
from models.user import User
from models.product import Product
from models.order import Order

# Ensures Base.metadata.create_all() knows about all tables
__all__ = ["User", "Product", "Order"]
```

### **Dynamic Model Importing (Optional Advanced Pattern)**

For highly dynamic systems:

```python
# db/auto_import.py
import pkgutil
import importlib
from models import __path__ as models_path

for _, module_name, _ in pkgutil.iter_modules(models_path):
    importlib.import_module(f"models.{module_name}")
```

This automatically loads all models without explicit imports.

---

## **17.4 Benefits of Modular Reusability**

| **Aspect**            | **Benefit**                                                   |
| --------------------- | ------------------------------------------------------------- |
| **Code Organization** | Keeps data, business, and presentation layers separate        |
| **Testing**           | You can easily mock repositories and sessions                 |
| **Scalability**       | Add new repositories and DALs without touching existing logic |
| **Maintainability**   | Clear boundaries between modules                              |
| **Reusability**       | Reuse DAL and Repository layers across multiple microservices |

---

## **17.5 Best Practices**

1. **Separate concerns clearly** – Keep ORM logic separate from business and API layers.
2. **Use Dependency Injection** – Inject `Session` into repositories and DALs instead of creating them internally.
3. **Add Unit Tests** – Mock your DAL/repositories to test higher-level logic.
4. **Use consistent naming** – Example: `user_repository.py`, `order_repository.py`.
5. **Abstract database URLs** – Keep connection URLs in `.env` or configuration files.
6. **Document your repository interfaces** – Helps future developers quickly understand the available operations.

---

## **17.6 Summary**

In this chapter, you learned:

* How to **structure and implement a Data Access Layer (DAL)**.
* How to use the **Repository Pattern** for reusable database logic.
* How to **organize models** within modular architectures for scalability and maintainability.

Next, we’ll move toward **Chapter 18**, which will cover **Packaging SQLAlchemy projects for deployment and reuse as Python packages** — including setup scripts, editable installs, and version management.

---
