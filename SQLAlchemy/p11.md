# **Chapter 11: Eager vs Lazy Loading**

## **Overview**

When working with relationships in SQLAlchemy ORM, one of the key performance considerations is **how related objects are loaded** from the database.
SQLAlchemy provides different loading strategies to balance between **performance** and **query complexity** — these are known as **lazy** and **eager loading** techniques.

---

## **1. Lazy Loading (Default Behavior)**

### **What It Is**

* **Lazy loading** means related objects are **not loaded** from the database until they are **explicitly accessed**.
* SQLAlchemy performs an **additional query** each time you access a relationship attribute.

### **Example**

```python
from sqlalchemy import create_engine, Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship, Session, declarative_base

Base = declarative_base()

class Author(Base):
    __tablename__ = "authors"
    id = Column(Integer, primary_key=True)
    name = Column(String)
    books = relationship("Book", back_populates="author")  # lazy loading by default

class Book(Base):
    __tablename__ = "books"
    id = Column(Integer, primary_key=True)
    title = Column(String)
    author_id = Column(Integer, ForeignKey("authors.id"))
    author = relationship("Author", back_populates="books")

# Setup
engine = create_engine("sqlite:///:memory:", echo=True)
Base.metadata.create_all(engine)
session = Session(engine)

# Example
author = Author(name="J.K. Rowling")
author.books = [Book(title="Harry Potter 1"), Book(title="Harry Potter 2")]
session.add(author)
session.commit()

# Lazy loading example
a = session.query(Author).first()
print(a.books)  # triggers another SELECT query for books
```

### **Behavior**

When you access `a.books`, SQLAlchemy fires a **separate SELECT** query:

```
SELECT * FROM books WHERE books.author_id = ?
```

### **Pros**

* Reduces memory usage if related objects are not always needed.
* Simplifies queries when working with large datasets.

### **Cons**

* Can lead to **N+1 query problem** if you access related objects in a loop.

  * Example: fetching 10 authors results in 1 query for authors + 10 additional queries for their books.

---

## **2. Eager Loading**

### **What It Is**

* **Eager loading** fetches related objects **in the same query** (or in as few queries as possible).
* It helps **avoid the N+1 problem** by preloading relationships.

SQLAlchemy supports multiple eager-loading strategies:

* `joinedload()`
* `subqueryload()`
* `selectinload()`

---

## **3. Using `joinedload()`**

### **Definition**

`joinedload()` performs a **SQL JOIN** to load related objects together.

### **Example**

```python
from sqlalchemy.orm import joinedload

authors = session.query(Author).options(joinedload(Author.books)).all()
```

### **SQL Generated**

```
SELECT authors.id, authors.name, books.id, books.title
FROM authors
LEFT OUTER JOIN books ON authors.id = books.author_id
```

### **Pros**

* Single query → faster when the data is small and joins are not heavy.
* Avoids N+1 problem.

### **Cons**

* Produces large result sets if one-to-many relationships have many rows.
* Can cause redundant data transmission.

---

## **4. Using `subqueryload()`**

### **Definition**

`subqueryload()` loads related objects in a **second query**, but for **all parent objects at once**, not one per parent.

### **Example**

```python
from sqlalchemy.orm import subqueryload

authors = session.query(Author).options(subqueryload(Author.books)).all()
```

### **SQL Generated**

1. First query fetches authors:

   ```
   SELECT authors.id, authors.name FROM authors
   ```
2. Second query fetches books for all fetched authors:

   ```
   SELECT books.id, books.title, books.author_id
   FROM books
   WHERE books.author_id IN (list of author ids)
   ```

### **Pros**

* Avoids join redundancy.
* Works well for large datasets where JOINs would produce duplicates.

### **Cons**

* Requires multiple queries (though still optimized).
* Slightly more overhead than `joinedload()` for small datasets.

---

## **5. Using `selectinload()`**

### **Definition**

`selectinload()` is similar to `subqueryload()`, but uses **IN** instead of a subquery for fetching related objects.
It is often more **efficient** than `subqueryload()`.

### **Example**

```python
from sqlalchemy.orm import selectinload

authors = session.query(Author).options(selectinload(Author.books)).all()
```

### **SQL Generated**

1. Fetch authors:

   ```
   SELECT authors.id, authors.name FROM authors
   ```
2. Fetch books using `IN` clause:

   ```
   SELECT books.id, books.title, books.author_id
   FROM books
   WHERE books.author_id IN (1, 2, 3, ...)
   ```

### **Pros**

* Generally faster than `subqueryload()` for moderate-sized lists.
* Avoids large joins.
* Recommended for modern databases.

### **Cons**

* Still uses multiple queries.
* Slightly more complex query planning.

---

## **6. Performance Trade-offs**

| Loading Type     | Query Count | Pros                        | Cons             | Best For              |
| ---------------- | ----------- | --------------------------- | ---------------- | --------------------- |
| **Lazy**         | Many (N+1)  | Memory efficient, simple    | N+1 problem      | Small, simple access  |
| **Joinedload**   | 1           | Fast for small related data | Data duplication | Small to medium joins |
| **Subqueryload** | 2           | Avoids duplication          | Slight overhead  | Medium datasets       |
| **Selectinload** | 2           | Most efficient eager method | Slightly complex | Large datasets        |

---

## **7. Combining Loading Strategies**

You can combine strategies for different relationships:

```python
query = (
    session.query(Author)
    .options(
        joinedload(Author.books),
        selectinload(Author.books, Book.author)
    )
)
```

You can also define loading strategies **in the relationship** definition:

```python
class Author(Base):
    __tablename__ = "authors"
    id = Column(Integer, primary_key=True)
    name = Column(String)
    books = relationship("Book", back_populates="author", lazy="joined")
```

Valid `lazy` options:

* `"select"` → Lazy loading (default)
* `"joined"` → Eager join
* `"subquery"` → Eager subquery
* `"selectin"` → Eager IN clause
* `"noload"` → No loading
* `"dynamic"` → Query object instead of collection

---

## **8. Best Practices**

✅ Use **`joinedload`** for small, frequently accessed related data.
✅ Use **`selectinload`** for medium-to-large datasets to avoid big JOINs.
✅ Avoid **lazy loading in loops** to prevent N+1 queries.
✅ Profile queries using `echo=True` or SQLAlchemy’s **query profiler** tools.

---

## **9. Summary**

| Strategy         | Mechanism                             | When to Use                |
| ---------------- | ------------------------------------- | -------------------------- |
| **Lazy**         | Loads related data only when accessed | Simple, low memory         |
| **Joinedload**   | Loads via JOIN                        | Small data, frequent joins |
| **Subqueryload** | Loads via subquery                    | When joins are expensive   |
| **Selectinload** | Loads via IN clause                   | Scalable and efficient     |

---

## **Practice Exercise**

1. Create two models — `Customer` and `Order`.
2. Insert multiple customers with several orders each.
3. Run the following:

   * Fetch customers using **lazy loading**.
   * Fetch using **joinedload**.
   * Fetch using **selectinload**.
4. Measure query counts and time using `echo=True` in engine.

---

