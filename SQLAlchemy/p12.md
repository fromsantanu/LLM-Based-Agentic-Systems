# **Chapter 12: Events and Hooks**

## **Overview**

SQLAlchemy provides a powerful event system that allows you to intercept and react to specific points in the ORM and Core’s lifecycle — such as when objects are inserted, updated, deleted, or when connections are created.

This chapter focuses on:

* Using `event.listen()`
* Automating timestamps (`created_at`, `updated_at`)
* Defining triggers and custom validations

---

## **12.1 What are Events and Hooks?**

Events and hooks allow developers to:

* Intercept ORM operations.
* Modify or validate data automatically.
* Implement audit trails or logging.
* Automatically populate metadata (like timestamps).

Think of them as “callbacks” that SQLAlchemy calls at specific lifecycle moments.

---

## **12.2 The `event` API Overview**

SQLAlchemy provides the `sqlalchemy.event` module to register and manage event listeners.

**Import:**

```python
from sqlalchemy import event
```

**Syntax:**

```python
event.listen(target, identifier, fn)
```

* **target** – The object being listened to (e.g., `Mapper`, `Session`, `Engine`, `Table`).
* **identifier** – The name of the event (e.g., `'before_insert'`, `'after_update'`).
* **fn** – The listener function to be executed.

---

## **12.3 Using `event.listen()` with ORM Mappers**

Let’s define a simple ORM model:

```python
from sqlalchemy import Column, Integer, String, DateTime, create_engine
from sqlalchemy.orm import declarative_base, sessionmaker
from sqlalchemy import event
from datetime import datetime

Base = declarative_base()
engine = create_engine("sqlite:///events_demo.db", echo=True)
Session = sessionmaker(bind=engine)

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    name = Column(String)
    created_at = Column(DateTime)
    updated_at = Column(DateTime)
```

---

## **12.4 Automating Timestamps**

We can automatically populate timestamps using events.

### **Example: Auto-set `created_at` and `updated_at`**

```python
@event.listens_for(User, "before_insert")
def before_insert_listener(mapper, connection, target):
    target.created_at = datetime.now()
    target.updated_at = datetime.now()

@event.listens_for(User, "before_update")
def before_update_listener(mapper, connection, target):
    target.updated_at = datetime.now()
```

Now, when you insert or update a user, timestamps are automatically set:

```python
Base.metadata.create_all(engine)
session = Session()

u1 = User(name="Alice")
session.add(u1)
session.commit()

u1.name = "Alice Smith"
session.commit()
```

**Result:**
The `created_at` and `updated_at` fields are automatically populated and maintained.

---

## **12.5 Using `@event.listens_for()` Decorator**

An alternate syntax to `event.listen()` is the decorator form:

```python
@event.listens_for(User, "after_insert")
def after_insert_listener(mapper, connection, target):
    print(f"User {target.name} was inserted at {target.created_at}")
```

This approach is cleaner and commonly used in modern SQLAlchemy codebases.

---

## **12.6 Table-Level Events**

You can attach listeners to a **Table** to intercept Core-level events.

**Example:**

```python
from sqlalchemy import Table, MetaData, Column, Integer, String

metadata = MetaData()
products = Table("products", metadata,
    Column("id", Integer, primary_key=True),
    Column("name", String)
)

def before_insert(mapper, connection, values):
    print("Before inserting:", values)

event.listen(products, "before_insert", before_insert)
```

This approach is useful when working with **Core** instead of ORM.

---

## **12.7 Session-Level Events**

Session events are useful for global hooks — such as logging, auditing, or validation.

**Example:**

```python
from sqlalchemy.orm import Session

@event.listens_for(Session, "before_flush")
def before_flush(session, flush_context, instances):
    print("Session flush started.")
```

You can listen to:

* `before_flush`
* `after_flush`
* `after_commit`
* `after_rollback`
* `after_begin`

---

## **12.8 Engine and Connection Events**

At the **Engine** level, events can capture database connections and executions.

**Example:**

```python
@event.listens_for(engine, "connect")
def connect_listener(dbapi_connection, connection_record):
    print("Database connection established.")

@event.listens_for(engine, "before_cursor_execute")
def before_cursor_execute(conn, cursor, statement, parameters, context, executemany):
    print("Executing:", statement)
```

Useful for debugging and performance tracking.

---

## **12.9 Custom Validations Using Events**

We can enforce business rules or data constraints before insertion or update.

**Example:**

```python
@event.listens_for(User, "before_insert")
def validate_user(mapper, connection, target):
    if not target.name or len(target.name.strip()) == 0:
        raise ValueError("User name cannot be empty")
```

If invalid data is provided:

```python
u2 = User(name="")
session.add(u2)
session.commit()   # ❌ Raises ValueError
```

---

## **12.10 Chaining Multiple Listeners**

Multiple listeners can be registered for the same event.
SQLAlchemy executes them in the order they were registered.

```python
@event.listens_for(User, "before_insert")
def another_listener(mapper, connection, target):
    print(f"Inserting user: {target.name}")
```

---

## **12.11 Triggers and Custom Hooks**

Database-level **triggers** can be created via SQLAlchemy using `DDL` objects.

**Example:**

```python
from sqlalchemy import DDL

trigger = DDL("""
CREATE TRIGGER update_timestamp
AFTER UPDATE ON users
BEGIN
  UPDATE users SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
END;
""")

event.listen(User.__table__, "after_create", trigger)
```

This automatically adds a database trigger when the table is created.

---

## **12.12 Removing Event Listeners**

To remove a listener:

```python
event.remove(User, "before_insert", before_insert_listener)
```

---

## **12.13 Summary**

| Concept                | Description                                | Example                                         |
| ---------------------- | ------------------------------------------ | ----------------------------------------------- |
| `event.listen()`       | Attaches a listener to a target object     | `event.listen(User, 'before_insert', fn)`       |
| `@event.listens_for()` | Decorator form of event registration       | `@event.listens_for(User, 'after_insert')`      |
| Automating timestamps  | Auto-set `created_at` and `updated_at`     | `before_insert`, `before_update`                |
| Custom validation      | Check or restrict data before DB operation | Raise `ValueError`                              |
| Engine events          | Capture DB connect or execute events       | `"connect"`, `"before_cursor_execute"`          |
| Session events         | Global lifecycle hooks                     | `"before_flush"`, `"after_commit"`              |
| Triggers               | Database-level automatic actions           | `event.listen(table, "after_create", DDL(...))` |

---

## **12.14 Practice Exercises**

1. Add an event listener to log all updates made to the `users` table.
2. Create a custom validator that ensures `name` is unique (query DB before insert).
3. Add a `before_flush` listener to print all objects pending for insertion.
4. Define a DDL trigger that logs deleted records in a separate table.

---

## **12.15 Key Takeaways**

* Events and hooks allow **automation**, **validation**, and **monitoring**.
* You can register events at different levels — ORM, Core, Session, or Engine.
* Always be cautious about performance impacts when using frequent event triggers.
* Event-based timestamping is cleaner than handling timestamps manually in your app code.

---
