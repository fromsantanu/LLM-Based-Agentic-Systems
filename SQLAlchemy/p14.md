# **Chapter 14: Integration with FastAPI / Flask**

In this chapter, you’ll learn how to integrate SQLAlchemy with popular web frameworks like **FastAPI** and **Flask**. You’ll also explore how to use **dependency injection** for session management, handle **asynchronous SQLAlchemy** operations, and connect **Pydantic models** with ORM classes for clean API design.

---

## **1. Integration with FastAPI**

### **a. Basic Setup**

FastAPI integrates smoothly with SQLAlchemy.
Here’s a typical project structure:

```
app/
├── main.py
├── database.py
├── models.py
├── schemas.py
└── crud.py
```

### **b. Creating the Engine and Session**

```python
# database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = "sqlite:///./test.db"

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()
```

### **c. Dependency Injection with Sessions**

FastAPI provides `Depends()` to manage database sessions automatically.

```python
# main.py
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
from . import database, models, schemas, crud

models.Base.metadata.create_all(bind=database.engine)
app = FastAPI()

def get_db():
    db = database.SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/users/{user_id}", response_model=schemas.User)
def read_user(user_id: int, db: Session = Depends(get_db)):
    return crud.get_user(db, user_id)
```

This ensures that every request gets its own database session, which is closed automatically.

---

## **2. Integration with Flask**

### **a. Setting up SQLAlchemy with Flask**

You can use Flask’s built-in application context to manage the database.

```python
from flask import Flask, jsonify, request
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///test.db"
db = SQLAlchemy(app)

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String)

@app.route("/users", methods=["POST"])
def add_user():
    data = request.json
    user = User(name=data["name"])
    db.session.add(user)
    db.session.commit()
    return jsonify({"id": user.id, "name": user.name})
```

### **b. Flask Context and Sessions**

Flask manages sessions automatically per request using its context, so manual dependency injection is not needed.
However, in larger apps, you can still implement repository and service layers similar to FastAPI.

---

## **3. Handling Async SQLAlchemy**

SQLAlchemy 1.4+ introduced native **asynchronous support** using `async_engine`.
This is particularly useful when building high-performance APIs with FastAPI.

### **a. Async Engine and Session**

```python
# database.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = "sqlite+aiosqlite:///./test.db"

engine = create_async_engine(DATABASE_URL, echo=True)
AsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
Base = declarative_base()
```

### **b. Dependency Injection (Async)**

```python
# main.py
from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession
from .database import AsyncSessionLocal

async def get_async_db():
    async with AsyncSessionLocal() as session:
        yield session
```

### **c. Example Async CRUD**

```python
# crud.py
from sqlalchemy.future import select
from .models import User

async def get_user(db: AsyncSession, user_id: int):
    result = await db.execute(select(User).where(User.id == user_id))
    return result.scalar_one_or_none()

async def create_user(db: AsyncSession, name: str):
    user = User(name=name)
    db.add(user)
    await db.commit()
    await db.refresh(user)
    return user
```

### **d. Async Route Example**

```python
# main.py
from fastapi import FastAPI, Depends
from . import crud, schemas
from .database import get_async_db

app = FastAPI()

@app.post("/users/", response_model=schemas.User)
async def create_user(user: schemas.UserCreate, db=Depends(get_async_db)):
    return await crud.create_user(db, user.name)
```

---

## **4. Using Pydantic Models with ORM**

Pydantic helps define request/response schemas for FastAPI that can easily integrate with SQLAlchemy ORM models.

### **a. Define ORM and Pydantic Models**

```python
# models.py
from sqlalchemy import Column, Integer, String
from .database import Base

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True)
```

```python
# schemas.py
from pydantic import BaseModel

class UserBase(BaseModel):
    name: str

class UserCreate(UserBase):
    pass

class User(UserBase):
    id: int
    class Config:
        orm_mode = True
```

The `orm_mode = True` setting allows Pydantic to read ORM objects directly and serialize them into JSON.

### **b. Linking ORM and Pydantic in API**

```python
@app.get("/users/{user_id}", response_model=schemas.User)
async def read_user(user_id: int, db=Depends(get_async_db)):
    user = await crud.get_user(db, user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user
```

---

## **5. Summary**

| Concept            | FastAPI                                          | Flask                                     |
| ------------------ | ------------------------------------------------ | ----------------------------------------- |
| Session Management | Dependency Injection via `Depends()`             | Managed via Flask context                 |
| Async Support      | Fully supported (`AsyncSession`, `async_engine`) | Limited (requires async frameworks)       |
| Schema Validation  | Built-in via Pydantic                            | Requires Marshmallow or manual validation |
| Best For           | Modern, async APIs                               | Simpler, synchronous APIs                 |

---

## **6. Practical Tips**

* Use **FastAPI** for new projects requiring async support and validation.
* For legacy synchronous applications, **Flask** remains stable and easy.
* Always manage sessions via **context managers** or **dependency injection**.
* Validate incoming/outgoing data using **Pydantic models**.
* Prefer **`async_engine`** when expecting high concurrency.

---

## ✅ **Exercises**

1. Integrate a `Book` model with both Flask and FastAPI.
2. Create async CRUD endpoints for `Book` with SQLAlchemy ORM.
3. Add request and response schemas using Pydantic.
4. Compare response times between sync and async APIs.

---
