# **Chapter 10: Session Management and Transactions**

---

## **1. Introduction**

In SQLAlchemy, the **Session** acts as the primary interface for interacting with the database when using the ORM. It manages:

* Database connections
* Transactions
* Object states (new, modified, deleted, etc.)
* Communication between Python objects and database records

Understanding **session management** and **transactions** ensures data consistency and helps prevent data corruption in multi-user environments.

---

## **2. Transaction Scopes**

A **transaction** groups a series of database operations that must either all succeed or all fail.
In SQLAlchemy, the **Session** automatically starts a transaction when you perform any operation that modifies the database.

### **Example: Basic Transaction**

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import User  # Assume User is already defined

# Create engine and session
engine = create_engine("sqlite:///example.db")
Session = sessionmaker(bind=engine)
session = Session()

try:
    new_user = User(name="Alice", email="alice@example.com")
    session.add(new_user)
    session.commit()  # Commit the transaction
except:
    session.rollback()  # Rollback in case of error
finally:
    session.close()
```

**Explanation:**

* `session.add()` — marks the object for insertion.
* `session.commit()` — commits the transaction.
* `session.rollback()` — reverts all uncommitted operations.
* `session.close()` — releases the database connection.

---

## **3. Commit and Rollback**

### **3.1 Commit**

The `commit()` method:

* Flushes all pending changes to the database.
* Commits the current transaction.
* Starts a new transaction automatically.

```python
user = User(name="Bob", email="bob@example.com")
session.add(user)
session.commit()  # All changes are now permanent
```

### **3.2 Rollback**

If something goes wrong (like an integrity error), you can roll back to restore the previous state:

```python
try:
    user = User(id=1, name="Duplicate")  # Duplicate primary key
    session.add(user)
    session.commit()
except Exception as e:
    print("Error:", e)
    session.rollback()  # Undo all uncommitted changes
```

**Important:**
After a rollback, any in-memory objects that were modified may become **out-of-sync** with the database. You can use `session.refresh()` to re-sync.

---

## **4. Expiring and Refreshing Objects**

SQLAlchemy maintains an internal cache of objects within the session. However, sometimes you want to ensure that an object’s data reflects the **latest state from the database**.

### **4.1 Expiring Objects**

Use `session.expire(object)` to mark an object as *expired*. The next time you access one of its attributes, SQLAlchemy will automatically reload it from the database.

```python
user = session.query(User).filter_by(id=1).first()
session.expire(user)
print(user.name)  # SQLAlchemy re-fetches from database
```

You can also expire **all** objects at once:

```python
session.expire_all()
```

---

### **4.2 Refreshing Objects**

Use `session.refresh(object)` to explicitly reload an object’s data from the database.

```python
user = session.query(User).filter_by(id=1).first()
# Some external process changes user's data in DB
session.refresh(user)
print(user.name)  # Reflects the latest data from DB
```

---

## **5. Context-Managed Sessions (Recommended)**

A **context-managed session** automatically handles transactions using Python’s `with` statement.
This is the **modern and safer** way to manage sessions.

### **Example: Using `with` Context**

```python
from sqlalchemy.orm import Session

with Session(engine) as session:
    new_user = User(name="Charlie", email="charlie@example.com")
    session.add(new_user)
    session.commit()
```

If an exception occurs inside the `with` block:

* The transaction is automatically **rolled back**.
* The session is properly **closed**.

### **Example: Using Context for Queries**

```python
with Session(engine) as session:
    users = session.query(User).all()
    for user in users:
        print(user.name)
```

### **Advanced Example: Nested Transaction Handling**

```python
with Session(engine) as session:
    try:
        user = User(name="David")
        session.add(user)
        session.flush()  # Write pending changes without committing
        # Perform more operations...
        session.commit()
    except:
        session.rollback()
```

---

## **6. Summary**

| Concept                     | Description                                 | Example                      |
| --------------------------- | ------------------------------------------- | ---------------------------- |
| **Transaction**             | A group of operations that execute together | `session.commit()`           |
| **Commit**                  | Makes all changes permanent                 | `session.commit()`           |
| **Rollback**                | Reverts all uncommitted changes             | `session.rollback()`         |
| **Expire**                  | Marks object data as outdated               | `session.expire(obj)`        |
| **Refresh**                 | Reloads object from database                | `session.refresh(obj)`       |
| **Context-managed session** | Automatically handles commit/rollback       | `with Session(engine) as s:` |

---

## **7. Practice Exercise**

1. Create a new model `Product` with attributes `id`, `name`, and `price`.
2. Write a script that:

   * Inserts 2 new products inside a transaction.
   * Rolls back the transaction if any insert fails.
   * Uses `expire_all()` and `refresh()` to demonstrate reloading.
3. Re-run the script to observe how session scope and rollback affect database persistence.

---

## **8. Key Takeaways**

* A **Session** in SQLAlchemy represents both a *workspace* for Python objects and a *transactional scope* for database operations.
* Always use **context-managed sessions** for cleaner and safer transaction handling.
* Learn to use **commit**, **rollback**, **expire**, and **refresh** effectively to maintain data consistency.

---
