# **Chapter 7 – Advanced Querying**

In this chapter, we’ll dive deeper into **querying techniques** in SQLAlchemy, covering more advanced patterns such as joins, subqueries, grouping, and computed properties.

---

## **1. Using `select()` for Complex Queries**

SQLAlchemy’s `select()` function allows you to construct queries flexibly and combine multiple tables, filters, and clauses.

### **Basic `select()` Example**

```python
from sqlalchemy import select
from models import User

stmt = select(User).where(User.age > 30)
results = session.execute(stmt).scalars().all()

for user in results:
    print(user.name, user.age)
```

✅ **Explanation**

* `select(User)` → selects all columns from the `User` table.
* `.where(User.age > 30)` → adds a filter condition.
* `.scalars()` → extracts ORM-mapped objects instead of raw rows.

---

## **2. Joining Tables**

### **2.1. Implicit Join using Relationships**

If you’ve defined relationships (like `User` → `Address`), you can join easily.

```python
stmt = select(User.name, Address.email_address).join(User.addresses)
results = session.execute(stmt).all()
```

✅ **Explanation**

* `.join(User.addresses)` automatically uses the relationship key.
* `User.name` and `Address.email_address` are both accessible.

### **2.2. Explicit Join**

You can also join tables explicitly when no relationship is defined.

```python
stmt = (
    select(User.name, Address.email_address)
    .join(Address, User.id == Address.user_id)
)
results = session.execute(stmt).all()
```

✅ **Explanation**

* Explicitly provides the condition `User.id == Address.user_id`.

---

## **3. Subqueries**

Subqueries allow you to nest a query inside another — useful for complex filtering or aggregations.

### **Example: Users with Above-Average Age**

```python
from sqlalchemy import func

subq = select(func.avg(User.age)).scalar_subquery()

stmt = select(User.name, User.age).where(User.age > subq)
results = session.execute(stmt).all()
```

✅ **Explanation**

* `scalar_subquery()` creates a subquery that returns a single value (average age).
* Outer query filters users older than that average.

---

## **4. Aggregations and GROUP BY**

### **Example: Counting Users by City**

```python
from sqlalchemy import func

stmt = (
    select(User.city, func.count(User.id).label("user_count"))
    .group_by(User.city)
)
results = session.execute(stmt).all()

for city, count in results:
    print(f"{city}: {count}")
```

✅ **Explanation**

* `func.count(User.id)` → performs a SQL COUNT aggregation.
* `.group_by(User.city)` → groups results by city.

---

## **5. Aliases and Labeling**

Aliases are helpful when joining the same table multiple times, or to make columns more readable.

### **Example: Using Aliases**

```python
from sqlalchemy.orm import aliased

manager = aliased(User)
employee = aliased(User)

stmt = (
    select(manager.name.label("manager"), employee.name.label("employee"))
    .join(manager, manager.id == employee.manager_id)
)
results = session.execute(stmt).all()
```

✅ **Explanation**

* `aliased(User)` → creates independent references to the same table.
* `label()` renames columns in the output.

---

## **6. Hybrid Properties**

Hybrid properties allow you to define **computed attributes** that can work both in Python and SQL expressions.

### **Example: Full Name Property**

```python
from sqlalchemy.ext.hybrid import hybrid_property

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    first_name = Column(String)
    last_name = Column(String)

    @hybrid_property
    def full_name(self):
        return f"{self.first_name} {self.last_name}"
```

✅ **Usage**

```python
user = session.query(User).first()
print(user.full_name)  # Works like a normal attribute
```

### **Hybrid Property with Expression**

```python
from sqlalchemy import func

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    first_name = Column(String)
    last_name = Column(String)

    @hybrid_property
    def full_name(self):
        return f"{self.first_name} {self.last_name}"

    @full_name.expression
    def full_name(cls):
        return func.concat(cls.first_name, " ", cls.last_name)
```

✅ **Now usable in queries:**

```python
stmt = select(User).where(User.full_name.like("%John%"))
results = session.execute(stmt).scalars().all()
```

---

## **7. Summary**

| Concept           | Purpose                    | Example                                      |
| ----------------- | -------------------------- | -------------------------------------------- |
| `select()`        | Core query builder         | `select(User).where(User.age>30)`            |
| `join()`          | Combine tables             | `.join(Address, User.id == Address.user_id)` |
| `subquery()`      | Nested queries             | `select(User).where(User.age > subq)`        |
| `group_by()`      | Aggregate by column        | `.group_by(User.city)`                       |
| `aliased()`       | Duplicate table references | `aliased(User)`                              |
| `hybrid_property` | Computed field             | `User.full_name`                             |

---

## **8. Practice Exercise**

**Q1.** Write a query to find all users whose salary is higher than the average salary.
**Q2.** Count how many users are registered in each department.
**Q3.** Create a hybrid property `User.initials` that returns `'A.B.'` for `'Alice Brown'`.

---
