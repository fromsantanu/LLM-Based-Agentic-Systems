# **Chapter 6: Relationships Between Tables**

Relational databases are built on the idea that data is spread across multiple tables that are **related** to each other through **foreign keys**.
In SQLAlchemy ORM, these relationships are represented using the `relationship()` function.

---

## **6.1 Types of Relationships**

There are three main types of relationships in databases:

| Relationship Type | Description                                                         | Example                          |
| ----------------- | ------------------------------------------------------------------- | -------------------------------- |
| **One-to-Many**   | One record in a table is related to many records in another.        | One `Author` → Many `Books`      |
| **Many-to-One**   | Many records in one table relate to one record in another.          | Many `Books` → One `Author`      |
| **Many-to-Many**  | Records in both tables can relate to multiple records in the other. | Many `Students` ↔ Many `Courses` |

---

## **6.2 One-to-Many Relationship**

This is the most common type of relationship.
For example, one **Author** can write many **Books**.

### **Example**

```python
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship, declarative_base

Base = declarative_base()

class Author(Base):
    __tablename__ = 'authors'

    id = Column(Integer, primary_key=True)
    name = Column(String)

    # Relationship: one author has many books
    books = relationship("Book", back_populates="author")

class Book(Base):
    __tablename__ = 'books'

    id = Column(Integer, primary_key=True)
    title = Column(String)
    author_id = Column(Integer, ForeignKey('authors.id'))

    # Relationship: each book belongs to one author
    author = relationship("Author", back_populates="books")
```

### **Explanation**

* `ForeignKey('authors.id')` defines the connection between the two tables.
* `relationship("Book")` and `back_populates="author"` create ORM-level links.
* You can now navigate easily between the two:

```python
# Example usage
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

engine = create_engine("sqlite:///library.db")
Base.metadata.create_all(engine)

Session = sessionmaker(bind=engine)
session = Session()

author = Author(name="J.K. Rowling")
book1 = Book(title="Harry Potter and the Philosopher's Stone", author=author)
book2 = Book(title="Harry Potter and the Chamber of Secrets", author=author)

session.add(author)
session.commit()

# Access books by author
print(author.books)
# Access author by book
print(book1.author.name)
```

---

## **6.3 Many-to-One Relationship**

It’s essentially the reverse of **one-to-many**.

Each **Book** belongs to **one Author**.
The same relationship can be accessed in the opposite direction.

```python
book = session.query(Book).first()
print(book.author.name)  # Many books share one author
```

---

## **6.4 Many-to-Many Relationship**

A **many-to-many** relationship needs an **association table**.

### **Example: Students and Courses**

```python
from sqlalchemy import Table, Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship

Base = declarative_base()

# Association table (no model class)
student_course = Table(
    'student_course',
    Base.metadata,
    Column('student_id', ForeignKey('students.id'), primary_key=True),
    Column('course_id', ForeignKey('courses.id'), primary_key=True)
)

class Student(Base):
    __tablename__ = 'students'

    id = Column(Integer, primary_key=True)
    name = Column(String)

    courses = relationship(
        "Course",
        secondary=student_course,
        back_populates="students"
    )

class Course(Base):
    __tablename__ = 'courses'

    id = Column(Integer, primary_key=True)
    title = Column(String)

    students = relationship(
        "Student",
        secondary=student_course,
        back_populates="courses"
    )
```

### **Example Usage**

```python
s1 = Student(name="Alice")
s2 = Student(name="Bob")

c1 = Course(title="Mathematics")
c2 = Course(title="Physics")

s1.courses = [c1, c2]
s2.courses = [c1]

session.add_all([s1, s2])
session.commit()

# Check associations
print(s1.courses)  # [Mathematics, Physics]
print(c1.students)  # [Alice, Bob]
```

---

## **6.5 Using `relationship()` and `back_populates`**

The `relationship()` function defines how objects are linked at the ORM level.

| Argument                      | Purpose                                                 |
| ----------------------------- | ------------------------------------------------------- |
| `relationship("ModelName")`   | Defines the related model.                              |
| `back_populates="attr"`       | Establishes a two-way connection.                       |
| `secondary=association_table` | Used for many-to-many relationships.                    |
| `cascade`                     | Defines how related objects behave on delete or update. |

---

## **6.6 Lazy vs Eager Loading**

SQLAlchemy provides two strategies for loading related data:

| Loading Type      | Description                                         | Example                              |
| ----------------- | --------------------------------------------------- | ------------------------------------ |
| **Lazy Loading**  | Loads related data only when accessed.              | `lazy='select'` (default)            |
| **Eager Loading** | Loads related data immediately with the main query. | `lazy='joined'` or `lazy='subquery'` |

### **Example**

```python
# Lazy loading (default)
author = session.query(Author).first()
print(author.books)  # SQL runs here

# Eager loading
from sqlalchemy.orm import joinedload
author = session.query(Author).options(joinedload(Author.books)).first()
print(author.books)  # Books loaded with author
```

---

## **6.7 Cascades and Orphan Deletion**

Cascades define what happens to related objects when a parent object changes.

| Cascade Option  | Meaning                                                                |
| --------------- | ---------------------------------------------------------------------- |
| `save-update`   | Automatically saves changes to related objects.                        |
| `delete`        | Deletes related objects when the parent is deleted.                    |
| `delete-orphan` | Deletes related child objects that are no longer attached to a parent. |
| `all`           | Applies all cascade behaviors.                                         |

### **Example: Cascade Delete**

```python
class Author(Base):
    __tablename__ = 'authors'

    id = Column(Integer, primary_key=True)
    name = Column(String)

    books = relationship(
        "Book",
        back_populates="author",
        cascade="all, delete-orphan"
    )

class Book(Base):
    __tablename__ = 'books'

    id = Column(Integer, primary_key=True)
    title = Column(String)
    author_id = Column(Integer, ForeignKey('authors.id'))
    author = relationship("Author", back_populates="books")
```

```python
# Deleting the author deletes all related books
author = session.query(Author).first()
session.delete(author)
session.commit()
```

---

## **6.8 Summary**

✅ **One-to-Many** — e.g., Author → Books
✅ **Many-to-Many** — e.g., Students ↔ Courses
✅ **relationship() + back_populates** — define bidirectional links
✅ **Lazy/Eager loading** — control when related data is loaded
✅ **Cascades** — manage dependent object behavior automatically

---

## **Practice Exercise**

1. Create models for `Department` and `Employee` where:

   * One department can have many employees.
   * Deleting a department deletes its employees automatically.
   * Use eager loading to display employees when querying a department.

2. Create another relationship between `Project` and `Employee`:

   * Many employees can work on many projects.
   * Use a secondary association table.

---
