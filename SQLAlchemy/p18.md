# Chapter 18 — Mini Projects

In this chapter you’ll stitch together everything you’ve learned into three small-but-complete apps. Each mini-project is deliberately scoped so you can finish it in a day, yet rich enough to demonstrate “real” SQLAlchemy usage with relationships, validation, and a clean repository/service layout.

We’ll keep the stack consistent:

* **DB**: SQLite (swap to Postgres/MySQL later)
* **ORM**: SQLAlchemy 2.x (Declarative ORM)
* **API**: FastAPI (optional—but recommended to see end-to-end flow)
* **Structure**: repository + service + router (thin controllers)

> Tip: Start with the “baseline” files once, then reuse across all three.

---

## Baseline skeleton (reuse for all three)

```
miniapp/
├─ app/
│  ├─ config/
│  │  └─ settings.py
│  ├─ db/
│  │  ├─ base.py
│  │  └─ session.py
│  ├─ models/           # per-project models go here
│  ├─ repositories/     # per-entity repositories
│  ├─ services/         # business logic
│  ├─ routers/          # FastAPI routers
│  └─ main.py           # FastAPI app
├─ alembic/             # (optional) migrations
├─ requirements.txt
└─ README.md
```

**`app/db/base.py`**

```python
from typing import List
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column

class Base(DeclarativeBase):
    # handy mixins go here later (timestamps, __repr__, etc.)
    pass
```

**`app/db/session.py`**

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = "sqlite:///./app.db"
engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)
```

**`app/config/settings.py`**

```python
from pydantic import BaseSettings

class Settings(BaseSettings):
    database_url: str = "sqlite:///./app.db"
    class Config:
        env_file = ".env"

settings = Settings()
```

**FastAPI app bootstrap (`app/main.py`)**

```python
from fastapi import FastAPI
from app.db.session import engine
from app.db.base import Base

# import and include routers per project, e.g.:
# from app.routers import todos, users, books, posts

def create_app() -> FastAPI:
    app = FastAPI(title="Mini Projects with SQLAlchemy")
    Base.metadata.create_all(bind=engine)  # ok for SQLite demos
    # app.include_router(todos.router, prefix="/todos", tags=["todos"])
    # app.include_router(users.router, prefix="/users", tags=["users"])
    # ...
    return app

app = create_app()
```

**Repository pattern (template)**

```python
from typing import Generic, TypeVar, Type, Optional, Sequence
from sqlalchemy.orm import Session
from app.db.base import Base

ModelT = TypeVar("ModelT", bound=Base)

class Repository(Generic[ModelT]):
    def __init__(self, model: Type[ModelT]):
        self.model = model

    def get(self, db: Session, id: int) -> Optional[ModelT]:
        return db.get(self.model, id)

    def list(self, db: Session, *, skip=0, limit=100) -> Sequence[ModelT]:
        return db.query(self.model).offset(skip).limit(limit).all()

    def add(self, db: Session, obj: ModelT) -> ModelT:
        db.add(obj)
        db.commit()
        db.refresh(obj)
        return obj

    def delete(self, db: Session, id: int) -> bool:
        obj = self.get(db, id)
        if not obj:
            return False
        db.delete(obj)
        db.commit()
        return True
```

**Request/response schemas with Pydantic (template)**

```python
from pydantic import BaseModel, Field
from typing import Optional

class IDModel(BaseModel):
    id: int
    class Config:
        from_attributes = True  # pydantic v2: ORM mode
```

**Dependency to get DB session (FastAPI)**

```python
from fastapi import Depends
from sqlalchemy.orm import Session
from app.db.session import SessionLocal

def get_db() -> Session:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

---

## Project 1 — Simple To-Do Application

### 1) Data model

* `User(id, email, name, created_at)`
* `Todo(id, title, done, due_date, user_id, created_at, updated_at)`

One-to-many: **User 1—n Todo**

### 2) Models (`app/models/todo.py`)

```python
from datetime import datetime, date
from sqlalchemy import ForeignKey, String, Boolean, Date, func
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app.db.base import Base

class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column(primary_key=True, index=True)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    name: Mapped[str] = mapped_column(String(100))
    created_at: Mapped[datetime] = mapped_column(server_default=func.now())

    todos: Mapped[list["Todo"]] = relationship(back_populates="user", cascade="all, delete-orphan")

class Todo(Base):
    __tablename__ = "todos"
    id: Mapped[int] = mapped_column(primary_key=True, index=True)
    title: Mapped[str] = mapped_column(String(300))
    done: Mapped[bool] = mapped_column(Boolean, default=False, index=True)
    due_date: Mapped[date | None]
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id", ondelete="CASCADE"))
    created_at: Mapped[datetime] = mapped_column(server_default=func.now())
    updated_at: Mapped[datetime | None] = mapped_column(onupdate=func.now())

    user: Mapped["User"] = relationship(back_populates="todos")
```

### 3) Pydantic schemas (`app/routers/schemas_todo.py`)

```python
from datetime import date, datetime
from pydantic import BaseModel, Field
from typing import Optional

class UserCreate(BaseModel):
    email: str
    name: str

class TodoCreate(BaseModel):
    title: str = Field(min_length=1, max_length=300)
    due_date: Optional[date] = None
    user_id: int

class TodoUpdate(BaseModel):
    title: Optional[str] = None
    done: Optional[bool] = None
    due_date: Optional[date] = None

class UserOut(BaseModel):
    id: int
    email: str
    name: str
    created_at: datetime
    class Config:
        from_attributes = True

class TodoOut(BaseModel):
    id: int
    title: str
    done: bool
    due_date: Optional[date]
    user_id: int
    created_at: datetime
    updated_at: Optional[datetime]
    class Config:
        from_attributes = True
```

### 4) Repository (`app/repositories/todo_repo.py`)

```python
from typing import Sequence
from sqlalchemy.orm import Session
from sqlalchemy import select
from app.models.todo import Todo

class TodoRepo:
    def get(self, db: Session, id: int) -> Todo | None:
        return db.get(Todo, id)

    def list_for_user(self, db: Session, user_id: int, *, done: bool | None=None) -> Sequence[Todo]:
        stmt = select(Todo).where(Todo.user_id == user_id)
        if done is not None:
            stmt = stmt.where(Todo.done == done)
        return db.execute(stmt).scalars().all()

    def add(self, db: Session, todo: Todo) -> Todo:
        db.add(todo)
        db.commit()
        db.refresh(todo)
        return todo

    def update(self, db: Session, todo: Todo, **changes) -> Todo:
        for k, v in changes.items():
            setattr(todo, k, v)
        db.commit()
        db.refresh(todo)
        return todo

    def delete(self, db: Session, id: int) -> bool:
        obj = db.get(Todo, id)
        if not obj:
            return False
        db.delete(obj)
        db.commit()
        return True
```

### 5) Router (`app/routers/todos.py`)

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.db.session import SessionLocal
from app.models.todo import Todo
from app.repositories.todo_repo import TodoRepo
from app.routers.schemas_todo import TodoCreate, TodoUpdate, TodoOut
from app.main import get_db

router = APIRouter()
repo = TodoRepo()

@router.post("/", response_model=TodoOut, status_code=201)
def create_todo(payload: TodoCreate, db: Session = Depends(get_db)):
    todo = Todo(**payload.model_dump())
    return repo.add(db, todo)

@router.get("/{todo_id}", response_model=TodoOut)
def get_todo(todo_id: int, db: Session = Depends(get_db)):
    todo = repo.get(db, todo_id)
    if not todo:
        raise HTTPException(404, "Todo not found")
    return todo

@router.patch("/{todo_id}", response_model=TodoOut)
def update_todo(todo_id: int, payload: TodoUpdate, db: Session = Depends(get_db)):
    todo = repo.get(db, todo_id)
    if not todo:
        raise HTTPException(404, "Todo not found")
    return repo.update(db, todo, **payload.model_dump(exclude_unset=True))

@router.delete("/{todo_id}", status_code=204)
def delete_todo(todo_id: int, db: Session = Depends(get_db)):
    ok = repo.delete(db, todo_id)
    if not ok:
        raise HTTPException(404, "Todo not found")
```

> **Exercises**

* Add a **soft-delete** flag.
* Add **priority** (enum: LOW/MEDIUM/HIGH) and filter endpoints.
* Write an **overdue** query (`due_date < today AND done = false`).

---

## Project 2 — Library Management System

### 1) Data model (minimal)

* `Author(id, name)`
* `Book(id, title, isbn, author_id, copies_total, copies_available)`
* `Member(id, email, name)`
* `Loan(id, book_id, member_id, loan_date, due_date, returned_date)`

Relationships:

* Author 1—n Book
* Book 1—n Loan
* Member 1—n Loan

### 2) Models (`app/models/library.py`)

```python
from datetime import date, datetime, timedelta
from sqlalchemy import String, Integer, ForeignKey, Date, func
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app.db.base import Base

class Author(Base):
    __tablename__ = "authors"
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(150), index=True)

    books: Mapped[list["Book"]] = relationship(back_populates="author", cascade="all, delete-orphan")

class Book(Base):
    __tablename__ = "books"
    id: Mapped[int] = mapped_column(primary_key=True)
    title: Mapped[str] = mapped_column(String(250), index=True)
    isbn: Mapped[str] = mapped_column(String(20), unique=True, index=True)
    author_id: Mapped[int] = mapped_column(ForeignKey("authors.id", ondelete="RESTRICT"))
    copies_total: Mapped[int] = mapped_column(default=1)
    copies_available: Mapped[int] = mapped_column(default=1)

    author: Mapped["Author"] = relationship(back_populates="books")
    loans: Mapped[list["Loan"]] = relationship(back_populates="book", cascade="all, delete-orphan")

class Member(Base):
    __tablename__ = "members"
    id: Mapped[int] = mapped_column(primary_key=True)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    name: Mapped[str] = mapped_column(String(120))

    loans: Mapped[list["Loan"]] = relationship(back_populates="member", cascade="all, delete-orphan")

class Loan(Base):
    __tablename__ = "loans"
    id: Mapped[int] = mapped_column(primary_key=True)
    book_id: Mapped[int] = mapped_column(ForeignKey("books.id", ondelete="RESTRICT"))
    member_id: Mapped[int] = mapped_column(ForeignKey("members.id", ondelete="RESTRICT"))
    loan_date: Mapped[date] = mapped_column(default=func.current_date())
    due_date: Mapped[date]
    returned_date: Mapped[date | None] = mapped_column(default=None)

    book: Mapped["Book"] = relationship(back_populates="loans")
    member: Mapped["Member"] = relationship(back_populates="loans")
```

### 3) Business rules (service layer) — loaning & returning (`app/services/library_service.py`)

```python
from datetime import timedelta, date
from sqlalchemy.orm import Session
from fastapi import HTTPException
from app.models.library import Book, Member, Loan

DEFAULT_LOAN_DAYS = 14

class LibraryService:
    def loan_book(self, db: Session, *, book_id: int, member_id: int) -> Loan:
        book = db.get(Book, book_id)
        member = db.get(Member, member_id)
        if not book or not member:
            raise HTTPException(404, "Book or Member not found")
        if book.copies_available <= 0:
            raise HTTPException(400, "No copies available")

        loan = Loan(book_id=book.id, member_id=member.id,
                    due_date=date.today() + timedelta(days=DEFAULT_LOAN_DAYS))
        book.copies_available -= 1
        db.add(loan)
        db.commit()
        db.refresh(loan)
        return loan

    def return_book(self, db: Session, *, loan_id: int) -> Loan:
        loan = db.get(Loan, loan_id)
        if not loan:
            raise HTTPException(404, "Loan not found")
        if loan.returned_date:
            raise HTTPException(400, "Book already returned")

        loan.returned_date = date.today()
        book = db.get(Book, loan.book_id)
        book.copies_available += 1
        db.commit()
        db.refresh(loan)
        return loan
```

### 4) Routers (selected) (`app/routers/library.py`)

```python
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import List
from app.main import get_db
from app.models.library import Author, Book, Member, Loan
from pydantic import BaseModel

router = APIRouter()

class AuthorCreate(BaseModel):
    name: str

class BookCreate(BaseModel):
    title: str
    isbn: str
    author_id: int
    copies_total: int = 1

class MemberCreate(BaseModel):
    email: str
    name: str

@router.post("/authors", response_model=int, status_code=201)
def create_author(payload: AuthorCreate, db: Session = Depends(get_db)):
    a = Author(**payload.model_dump())
    db.add(a); db.commit(); db.refresh(a)
    return a.id

@router.post("/books", response_model=int, status_code=201)
def create_book(payload: BookCreate, db: Session = Depends(get_db)):
    b = Book(**payload.model_dump())
    b.copies_available = b.copies_total
    db.add(b); db.commit(); db.refresh(b)
    return b.id

@router.post("/members", response_model=int, status_code=201)
def create_member(payload: MemberCreate, db: Session = Depends(get_db)):
    m = Member(**payload.model_dump())
    db.add(m); db.commit(); db.refresh(m)
    return m.id
```

**Loan endpoints using the service**

```python
from app.services.library_service import LibraryService
service = LibraryService()

@router.post("/loans/borrow/{book_id}/member/{member_id}", response_model=int)
def borrow(book_id: int, member_id: int, db: Session = Depends(get_db)):
    loan = service.loan_book(db, book_id=book_id, member_id=member_id)
    return loan.id

@router.post("/loans/return/{loan_id}", response_model=bool)
def return_loan(loan_id: int, db: Session = Depends(get_db)):
    service.return_book(db, loan_id=loan_id)
    return True
```

**Useful queries to practice**

* Overdue loans:

```python
from datetime import date
from sqlalchemy import select
from app.models.library import Loan
stmt = select(Loan).where(Loan.due_date < date.today(), Loan.returned_date.is_(None))
```

* Top authors by active loans (join + group by).
* Full-text search on title (use `ILIKE/LIKE` or DB-specific FTS later).

> **Exercises**

* Add **penalties** for late returns (extra table or computed).
* Add **reservations/waitlists** when `copies_available == 0`.
* Add **unique constraint** (member cannot loan same book twice without returning).

---

## Project 3 — Blog with Users & Posts

### 1) Data model

* `User(id, email, name, hashed_password, created_at)`
* `Post(id, title, slug, body, author_id, published, created_at, updated_at)`
* `Tag(id, name, slug)`
* `post_tags(post_id, tag_id)` (association table)
* Optional: `Comment(id, post_id, author_name, body, created_at)`

Relationships:

* User 1—n Post
* Post n—m Tag
* Post 1—n Comment

### 2) Models (`app/models/blog.py`)

```python
from datetime import datetime
from sqlalchemy import String, Boolean, ForeignKey, Table, Column, Integer, func
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app.db.base import Base

post_tags = Table(
    "post_tags",
    Base.metadata,
    Column("post_id", ForeignKey("posts.id", ondelete="CASCADE"), primary_key=True),
    Column("tag_id", ForeignKey("tags.id", ondelete="CASCADE"), primary_key=True),
)

class User(Base):
    __tablename__ = "blog_users"
    id: Mapped[int] = mapped_column(primary_key=True)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    name: Mapped[str] = mapped_column(String(120))
    hashed_password: Mapped[str] = mapped_column(String(255))
    created_at: Mapped[datetime] = mapped_column(server_default=func.now())

    posts: Mapped[list["Post"]] = relationship(back_populates="author")

class Tag(Base):
    __tablename__ = "tags"
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(80), unique=True, index=True)
    slug: Mapped[str] = mapped_column(String(120), unique=True, index=True)

class Post(Base):
    __tablename__ = "posts"
    id: Mapped[int] = mapped_column(primary_key=True)
    title: Mapped[str] = mapped_column(String(200), index=True)
    slug: Mapped[str] = mapped_column(String(220), unique=True, index=True)
    body: Mapped[str]
    published: Mapped[bool] = mapped_column(default=False, index=True)
    author_id: Mapped[int] = mapped_column(ForeignKey("blog_users.id", ondelete="RESTRICT"))
    created_at: Mapped[datetime] = mapped_column(server_default=func.now())
    updated_at: Mapped[datetime | None] = mapped_column(onupdate=func.now())

    author: Mapped["User"] = relationship(back_populates="posts")
    tags: Mapped[list["Tag"]] = relationship(secondary=post_tags, lazy="selectin")

class Comment(Base):
    __tablename__ = "comments"
    id: Mapped[int] = mapped_column(primary_key=True)
    post_id: Mapped[int] = mapped_column(ForeignKey("posts.id", ondelete="CASCADE"), index=True)
    author_name: Mapped[str] = mapped_column(String(120))
    body: Mapped[str]
    created_at: Mapped[datetime] = mapped_column(server_default=func.now())
```

### 3) Slug utility & simple hashing (`app/services/blog_utils.py`)

```python
import re, hashlib

def slugify(title: str) -> str:
    s = re.sub(r"[^a-zA-Z0-9]+", "-", title).strip("-").lower()
    return s

def hash_password(pw: str) -> str:
    return hashlib.sha256(pw.encode("utf-8")).hexdigest()
```

### 4) Repository examples (`app/repositories/blog_repo.py`)

```python
from typing import Sequence
from sqlalchemy.orm import Session
from sqlalchemy import select
from app.models.blog import Post, Tag

class BlogRepo:
    def list_published(self, db: Session, *, tag: str | None=None) -> Sequence[Post]:
        stmt = select(Post).where(Post.published == True).order_by(Post.created_at.desc())
        if tag:
            stmt = stmt.join(Post.tags).where(Tag.slug == tag)
        return db.execute(stmt).scalars().all()

    def create_post(self, db: Session, post: Post, tag_slugs: list[str]) -> Post:
        if tag_slugs:
            tags = db.execute(select(Tag).where(Tag.slug.in_(tag_slugs))).scalars().all()
            post.tags = list(tags)
        db.add(post); db.commit(); db.refresh(post)
        return post

    def toggle_publish(self, db: Session, post_id: int, *, publish: bool) -> Post:
        p = db.get(Post, post_id)
        if not p:
            return None
        p.published = publish
        db.commit(); db.refresh(p)
        return p
```

### 5) Routers (selected) (`app/routers/blog.py`)

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from pydantic import BaseModel
from typing import List, Optional
from app.main import get_db
from app.models.blog import User, Post, Tag
from app.services.blog_utils import slugify, hash_password
from app.repositories.blog_repo import BlogRepo

router = APIRouter()
repo = BlogRepo()

class UserCreate(BaseModel):
    email: str
    name: str
    password: str

class PostCreate(BaseModel):
    title: str
    body: str
    author_id: int
    tags: List[str] = []  # tag slugs

@router.post("/users", response_model=int, status_code=201)
def create_user(payload: UserCreate, db: Session = Depends(get_db)):
    u = User(email=payload.email, name=payload.name, hashed_password=hash_password(payload.password))
    db.add(u); db.commit(); db.refresh(u)
    return u.id

@router.post("/tags", response_model=int, status_code=201)
def create_tag(name: str, db: Session = Depends(get_db)):
    t = Tag(name=name, slug=slugify(name))
    db.add(t); db.commit(); db.refresh(t)
    return t.id

@router.post("/posts", response_model=int, status_code=201)
def create_post(payload: PostCreate, db: Session = Depends(get_db)):
    p = Post(title=payload.title, slug=slugify(payload.title), body=payload.body, author_id=payload.author_id)
    created = repo.create_post(db, p, payload.tags)
    return created.id

@router.get("/posts")
def list_posts(tag: Optional[str] = None, db: Session = Depends(get_db)):
    return repo.list_published(db, tag=tag)

@router.post("/posts/{post_id}/publish")
def publish(post_id: int, publish: bool = True, db: Session = Depends(get_db)):
    p = repo.toggle_publish(db, post_id, publish=publish)
    if not p:
        raise HTTPException(404, "Post not found")
    return {"id": p.id, "published": p.published}
```

**Queries to practice**

* “Latest n posts per author” (window functions).
* “Related posts” by shared tags.
* “Top tags” by usage count (aggregate over `post_tags`).

> **Exercises**

* Add **JWT auth** & author-only publish permissions.
* Add **comments** endpoint with anti-spam constraints (min length, rate limit).
* Add **search** on `title/body` (SQLite LIKE → swap later to Postgres FTS).

---

## Testing quickstarts (for all projects)

* Use **pytest** with a **temp SQLite** DB:

```python
import tempfile, os, pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.db.base import Base

@pytest.fixture()
def db_session():
    fd, path = tempfile.mkstemp()
    os.close(fd)
    engine = create_engine(f"sqlite:///{path}", connect_args={"check_same_thread": False})
    TestingSessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)
    Base.metadata.create_all(bind=engine)
    try:
        yield TestingSessionLocal()
    finally:
        os.remove(path)
```

* Seed a user/author/member, run a flow (e.g., create todo → mark done; borrow/return; publish/unpublish).

---

## Migration notes (optional)

* Initialize Alembic once, then autogenerate:

  * `alembic init alembic`
  * Set `sqlalchemy.url` to your DB
  * `alembic revision --autogenerate -m "init"`
  * `alembic upgrade head`

---

## How to run

1. Install deps

```
pip install fastapi uvicorn sqlalchemy pydantic
```

2. Start API

```
uvicorn app.main:app --reload
```

3. Try endpoints (curl or browser):

* To-Do: `POST /todos`, `PATCH /todos/{id}`, `GET /todos/{id}`
* Library: create author/book/member, `POST /loans/borrow/{book_id}/member/{member_id}`, `POST /loans/return/{loan_id}`
* Blog: create user/tag/post, `POST /posts/{id}/publish`, `GET /posts?tag=python`

---

## Stretch goals

* Swap SQLite → Postgres with a connection pool.
* Add **DTO validation** (Pydantic constraints) and **domain errors**.
* Introduce **caching** for read-heavy endpoints (e.g., blog frontpage).
* Add **pagination** & **sorting** query params.
* Instrument SQL with logging and profile slow queries.

---

### What you should learn here

* Modeling one-to-many and many-to-many relations cleanly.
* Encapsulating persistence in repositories and keeping services “business-y”.
* Writing practical queries (filters, aggregates, joins) that map to real use cases.
* Shipping a tiny app end-to-end with SQLAlchemy powering your data layer.



