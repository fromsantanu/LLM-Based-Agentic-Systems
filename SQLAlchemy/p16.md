# **Chapter 16: Testing and CI/CD**

### **16.1 Introduction**

Testing is crucial for ensuring that your SQLAlchemy-based applications behave correctly and reliably.
This chapter covers how to:

* Set up **test databases**
* Use **fixtures** for consistent test environments
* **Mock sessions and queries**
* Integrate your tests into a **CI/CD pipeline**

---

### **16.2 Setting up Test Databases**

When testing SQLAlchemy applications, you don’t want to use your production database.
Instead, create an **in-memory SQLite database** or a **temporary test database** for isolation.

#### **Example: In-memory SQLite for Testing**

```python
# tests/conftest.py
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.models import Base

@pytest.fixture(scope="session")
def test_engine():
    engine = create_engine("sqlite:///:memory:", echo=False)
    Base.metadata.create_all(engine)
    yield engine
    Base.metadata.drop_all(engine)

@pytest.fixture
def test_session(test_engine):
    Session = sessionmaker(bind=test_engine)
    session = Session()
    yield session
    session.close()
```

**Explanation:**

* `scope="session"` → reuses the same in-memory database during the test session.
* The database is created and dropped automatically.
* Each test gets a fresh `session`.

---

### **16.3 Writing Your First Test**

Let's test inserting and querying a `User` model.

```python
# tests/test_user_model.py
from app.models.user import User

def test_create_user(test_session):
    new_user = User(name="Alice", email="alice@example.com")
    test_session.add(new_user)
    test_session.commit()

    user = test_session.query(User).filter_by(email="alice@example.com").first()
    assert user is not None
    assert user.name == "Alice"
```

**Explanation:**

* Uses the `test_session` fixture.
* Creates a record, commits it, then fetches and verifies it.

---

### **16.4 Using Fixtures with Pytest**

Fixtures are reusable setups for database sessions, mock data, or configurations.

#### **Parameterized Fixture Example**

```python
@pytest.fixture(params=["sqlite:///:memory:", "sqlite:///test.db"])
def param_engine(request):
    engine = create_engine(request.param, echo=False)
    Base.metadata.create_all(engine)
    yield engine
    Base.metadata.drop_all(engine)
```

This runs the same tests on multiple database backends.

---

### **16.5 Mocking Sessions and Queries**

Mocking allows you to test business logic **without hitting the database**.

#### **Using unittest.mock**

```python
from unittest.mock import MagicMock
from app.services.user_service import get_user_by_email

def test_get_user_by_email():
    # Create mock session
    mock_session = MagicMock()
    mock_query = mock_session.query.return_value
    mock_filter = mock_query.filter_by.return_value
    mock_filter.first.return_value = {"id": 1, "name": "Alice"}

    result = get_user_by_email(mock_session, "alice@example.com")
    assert result["name"] == "Alice"
```

**Key points:**

* `MagicMock` simulates the database session and query chain.
* No real DB connection is required.

---

### **16.6 Example: Testing a CRUD Service**

```python
# app/services/user_service.py
from app.models.user import User

def get_user_by_email(session, email):
    return session.query(User).filter_by(email=email).first()

def create_user(session, name, email):
    user = User(name=name, email=email)
    session.add(user)
    session.commit()
    return user
```

#### **Test**

```python
# tests/test_user_service.py
from app.services.user_service import create_user, get_user_by_email

def test_create_and_get_user(test_session):
    user = create_user(test_session, "Bob", "bob@example.com")
    assert user.id is not None

    retrieved = get_user_by_email(test_session, "bob@example.com")
    assert retrieved.email == "bob@example.com"
```

---

### **16.7 CI/CD Integration**

Automated tests ensure that code changes don’t break functionality.
You can use **GitHub Actions**, **GitLab CI**, or **Jenkins**.

#### **Example: GitHub Actions Workflow**

```yaml
# .github/workflows/tests.yml
name: Run SQLAlchemy Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest

      - name: Run Tests
        run: pytest -v
```

---

### **16.8 Continuous Integration Best Practices**

1. **Keep tests independent**
   Each test should run in isolation—no shared state.

2. **Use separate configurations**
   Use `.env.test` or `config_test.py` to define test DB URIs.

3. **Test early and often**
   Automate tests on every push or PR.

4. **Use coverage reports**

   ```bash
   pytest --cov=app --cov-report=term-missing
   ```

5. **Run linting and type checks**

   ```bash
   flake8 app/
   mypy app/
   ```

---

### **16.9 Advanced: Test Factories**

Use libraries like **Factory Boy** or **Faker** to generate dummy data.

```python
import factory
from app.models.user import User

class UserFactory(factory.alchemy.SQLAlchemyModelFactory):
    class Meta:
        model = User
        sqlalchemy_session_persistence = "commit"

    id = factory.Sequence(lambda n: n + 1)
    name = factory.Faker("name")
    email = factory.Faker("email")
```

Usage:

```python
def test_user_factory(test_session):
    user = UserFactory(_session=test_session)
    assert user.id is not None
```

---

### **16.10 Summary**

| Concept        | Description                                      |
| -------------- | ------------------------------------------------ |
| Test Databases | Use SQLite in-memory for isolation               |
| Fixtures       | Provide consistent setup for each test           |
| Mocking        | Avoid real DB calls with simulated sessions      |
| CI/CD          | Automate testing using GitHub Actions or similar |
| Factory Boy    | Generate realistic test data                     |

---

### ✅ **End of Chapter 16**

Next:
**Chapter 17 – Deployment and Production Tips**

* Handling migrations in CI/CD
* Database connection pooling in production
* Monitoring and observability

---

