# Chapter 6 Â· Interactive Tables

Learn how to build rich, spreadsheetâ€‘like experiences in Dash using `dash.dash_table.DataTable` â€” including sorting, filtering, editing, pagination, selection, and exporting.

---

## What youâ€™ll learn

* When to use `DataTable` vs. static HTML tables
* Key props for sorting, filtering, editing, pagination, and selection
* Styling cells/rows conditionally
* Capturing edits and validating data in callbacks
* A complete, runnable **Product Inventory Manager** example

> **Prerequisites:** Dash basics (layout & callbacks) from Chapters 1â€“5.

---

## Why `DataTable`?

`DataTable` gives you a familiar grid UI with builtâ€‘in interactions: sort, filter, paginate, select, and edit â€” all without writing custom JS. You can wire these interactions to Python callbacks to compute derived values, validate input, and persist changes.

---

## Core Concepts & Quick Reference

| Capability         | Props (most used)                                                               |                          |                              |
| ------------------ | ------------------------------------------------------------------------------- | ------------------------ | ---------------------------- |
| Data & Columns     | `data`, `columns=[{"name":"Label","id":"field","type":"numeric                  | text                     | datetime","editable":True}]` |
| Sorting            | `sort_action="native"` (or handle `sort_by` in callbacks)                       |                          |                              |
| Filtering          | `filter_action="native"` (or handle `filter_query` in callbacks)                |                          |                              |
| Pagination         | `page_size`, `page_current`, `page_action="native"`                             |                          |                              |
| Editing            | `editable=True` on table or perâ€‘column; dropdowns via `presentation="dropdown"` |                          |                              |
| Row Selection      | `row_selectable="single                                                         | multi"`, `selected_rows` |                              |
| Row Deletion       | `row_deletable=True`                                                            |                          |                              |
| Conditional Styles | `style_data_conditional`, `style_header`, `style_cell`                          |                          |                              |
| Export             | Use `dcc.Download` + callback with `dcc.send_data_frame`                        |                          |                              |

> Tip: Set column `type` for better filtering/sorting behavior.

---

## Minimal Example

```python
from dash import Dash, html, dcc
from dash import dash_table
import pandas as pd

app = Dash(__name__)

# Sample data
_df = pd.DataFrame({
    "id": [1, 2, 3],
    "product": ["Notebook", "Pen", "Stapler"],
    "price": [120.0, 10.5, 75.0],
    "stock": [15, 200, 8]
})

app.layout = html.Div([
    html.H3("Minimal DataTable"),
    dash_table.DataTable(
        id="tbl-min",
        data=_df.to_dict("records"),
        columns=[
            {"name": "ID", "id": "id", "type": "numeric"},
            {"name": "Product", "id": "product", "type": "text", "editable": True},
            {"name": "Price", "id": "price", "type": "numeric", "editable": True},
            {"name": "Stock", "id": "stock", "type": "numeric", "editable": True},
        ],
        sort_action="native",
        filter_action="native",
        page_action="native",
        page_size=5,
        editable=True,
        row_selectable="multi",
        style_table={"overflowX": "auto"}
    )
])

if __name__ == "__main__":
    app.run_server(debug=True)
```

---

## Sorting & Filtering

* **Native sorting/filtering**: simplest and fastest. Dash handles it in the frontend.
* **Advanced control**: set `sort_action=None` and use the `sort_by` prop in a callback to sort serverâ€‘side (useful for big data or custom sort rules). Similarly, handle `filter_query` manually if you need custom filters.

**Common patterns**

```python
# In DataTable props
sort_action="native"      # use built-in UI
filter_action="native"    # use built-in UI

# For custom server-side sorting
# @app.callback(Output("tbl", "data"), Input("tbl", "sort_by"))
# def sort_server_side(sort_by):
#     df = load_df()
#     if sort_by:
#         col = sort_by[0]["column_id"]
#         asc = sort_by[0]["direction"] == "asc"
#         df = df.sort_values(col, ascending=asc)
#     return df.to_dict("records")
```

**Filter syntax (native UI)** works intuitively by column type (e.g., `> 10`, `contains "abc"`). For advanced filters, manage `filter_query` in Python.

---

## Editing & Validation

Make the table or specific columns editable and capture changes in a callback via the `data` prop.

**Example validation pattern**

```python
from dash import Input, Output, State, no_update

@app.callback(
    Output("tbl-min", "data"),
    Input("tbl-min", "data_timestamp"),
    State("tbl-min", "data"),
)
def validate_on_edit(ts, rows):
    # Ensure valid numbers; coerce negatives to 0
    for r in rows:
        r["price"] = max(float(r.get("price", 0) or 0), 0)
        r["stock"] = max(int(r.get("stock", 0) or 0), 0)
    return rows
```

> Note: `data_timestamp` is updated whenever the user edits the grid; using it as an `Input` is a clean way to detect edits.

---

## Pagination

Set `page_action="native"` and `page_size=...` for client pagination. For very large datasets, implement serverâ€‘side pagination by controlling `page_current` and returning a slice of rows from a callback.

---

## Conditional Formatting

Use `style_data_conditional` to color cells/rows dynamically.

```python
style_data_conditional=[
    {
        "if": {"filter_query": "{stock} < {reorder}", "column_id": "stock"},
        "backgroundColor": "#ffe6e6",
        "color": "#b30000",
        "fontWeight": "600"
    }
]
```

---

## Complete Example Â· Product Inventory Manager

**Features**

* Editable inventory grid with dropdown for `category`
* Add/Delete rows, multiâ€‘row selection
* Lowâ€‘stock highlighting & computed `status`
* Instant validation (no negative numbers)
* Restock selected rows by N units
* Totals panel (count & inventory value)
* CSV export and state persistence

```python
from dash import Dash, html, dcc, dash_table, Input, Output, State, ctx, no_update
import pandas as pd

app = Dash(__name__)
app.title = "Inventory Manager"

# --- Seed data ---
INIT_ROWS = [
    {"sku": "NB-001", "name": "Notebook A5", "category": "Stationery", "unit_price": 120.0, "stock": 15, "reorder_level": 10},
    {"sku": "PN-010", "name": "Ball Pen (Blue)", "category": "Stationery", "unit_price": 10.5, "stock": 200, "reorder_level": 50},
    {"sku": "ST-007", "name": "Stapler M", "category": "Office", "unit_price": 75.0, "stock": 8, "reorder_level": 12},
    {"sku": "MK-003", "name": "Marker Black", "category": "Office", "unit_price": 45.0, "stock": 30, "reorder_level": 20},
]

CATEGORIES = ["Stationery", "Office", "Electronics", "Other"]

# Helper to compute derived columns
def with_status(rows):
    out = []
    for r in rows:
        r = r.copy()
        r["status"] = "Low Stock" if (r.get("stock", 0) < r.get("reorder_level", 0)) else "OK"
        r["line_value"] = round((r.get("unit_price", 0) or 0) * (r.get("stock", 0) or 0), 2)
        out.append(r)
    return out

app.layout = html.Div([
    html.H2("ðŸ“¦ Product Inventory Manager"),

    # Keep canonical data in a store for persistence across interactions
    dcc.Store(id="store-data", data=INIT_ROWS, storage_type="memory"),

    html.Div([
        html.Button("ï¼‹ Add Row", id="btn-add", n_clicks=0, style={"marginRight": "8px"}),
        dcc.Input(id="restock-qty", type="number", value=10, min=1, step=1, style={"width": 120, "marginRight": 8}),
        html.Button("â†» Restock Selected", id="btn-restock", n_clicks=0, style={"marginRight": "8px"}),
        html.Button("ðŸ’¾ Export CSV", id="btn-export", n_clicks=0)
    ], style={"marginBottom": "12px"}),

    dash_table.DataTable(
        id="tbl-inv",
        data=with_status(INIT_ROWS),
        columns=[
            {"name": "SKU", "id": "sku", "type": "text"},
            {"name": "Name", "id": "name", "type": "text", "editable": True},
            {"name": "Category", "id": "category", "type": "text", "presentation": "dropdown", "editable": True},
            {"name": "Unit Price", "id": "unit_price", "type": "numeric", "editable": True},
            {"name": "Stock", "id": "stock", "type": "numeric", "editable": True},
            {"name": "Reorder Level", "id": "reorder_level", "type": "numeric", "editable": True},
            {"name": "Status", "id": "status", "type": "text", "editable": False},
            {"name": "Line Value", "id": "line_value", "type": "numeric", "editable": False},
        ],
        dropdown={
            "category": {
                "options": [{"label": c, "value": c} for c in CATEGORIES]
            }
        },
        sort_action="native",
        filter_action="native",
        page_action="native",
        page_size=8,
        editable=True,
        row_deletable=True,
        row_selectable="multi",
        selected_rows=[],
        style_cell={"minWidth": 90, "maxWidth": 240, "whiteSpace": "normal"},
        style_table={"overflowX": "auto"},
        style_header={"fontWeight": "700"},
        style_data_conditional=[
            {
                "if": {"filter_query": "{status} = 'Low Stock'"},
                "backgroundColor": "#fff4f4",
                "color": "#9b1c1c",
                "fontWeight": "600"
            }
        ],
    ),

    html.Br(),
    html.Div(id="totals", style={"fontWeight": 600}),
    dcc.Download(id="download-csv"),
])

# --- Keep table synced with store & compute derived fields ---
@app.callback(
    Output("tbl-inv", "data"),
    Output("totals", "children"),
    Input("store-data", "data"),
)
def refresh_table(data):
    rows = with_status(data or [])
    df = pd.DataFrame(rows)
    total_items = int(df["stock"].sum()) if not df.empty else 0
    total_value = float(df["line_value"].sum()) if not df.empty else 0.0
    summary = f"Items in stock: {total_items} Â· Inventory value: â‚¹{total_value:,.2f}"
    return rows, summary

# --- Apply user edits (validate & persist) ---
@app.callback(
    Output("store-data", "data", allow_duplicate=True),
    Input("tbl-inv", "data_timestamp"),
    State("tbl-inv", "data"),
    prevent_initial_call=True,
)
def on_edit(ts, rows):
    # Validate numeric fields and sanitize
    clean = []
    for r in rows:
        c = r.copy()
        c["unit_price"] = max(float(c.get("unit_price", 0) or 0), 0)
        c["stock"] = max(int(float(c.get("stock", 0) or 0)), 0)
        c["reorder_level"] = max(int(float(c.get("reorder_level", 0) or 0)), 0)
        # Ensure required text fields
        c["sku"] = str(c.get("sku") or "").strip() or "NEW-SKU"
        c["name"] = str(c.get("name") or "").strip() or "Unnamed Item"
        c["category"] = c.get("category") or CATEGORIES[0]
        clean.append({k: c[k] for k in ["sku","name","category","unit_price","stock","reorder_level"]})
    return clean

# --- Add a blank row ---
@app.callback(
    Output("store-data", "data", allow_duplicate=True),
    Input("btn-add", "n_clicks"),
    State("store-data", "data"),
    prevent_initial_call=True,
)
def add_row(n, data):
    data = list(data or [])
    idx = len(data) + 1
    data.append({
        "sku": f"NEW-{idx:03d}",
        "name": "",
        "category": CATEGORIES[0],
        "unit_price": 0.0,
        "stock": 0,
        "reorder_level": 0,
    })
    return data

# --- Restock selected rows by N ---
@app.callback(
    Output("store-data", "data", allow_duplicate=True),
    Input("btn-restock", "n_clicks"),
    State("restock-qty", "value"),
    State("tbl-inv", "selected_rows"),
    State("store-data", "data"),
    prevent_initial_call=True,
)
def restock(n, qty, selected, data):
    if not selected:
        return no_update
    qty = max(int(qty or 0), 1)
    rows = list(data or [])
    for i in selected:
        if 0 <= i < len(rows):
            rows[i]["stock"] = max(int(rows[i].get("stock", 0)), 0) + qty
    return rows

# --- Export CSV ---
@app.callback(
    Output("download-csv", "data"),
    Input("btn-export", "n_clicks"),
    State("store-data", "data"),
    prevent_initial_call=True,
)
def export_csv(n, data):
    df = pd.DataFrame(with_status(data or []))
    return dcc.send_data_frame(df.to_csv, filename="inventory.csv", index=False)

if __name__ == "__main__":
    app.run_server(debug=True)
```

**How it works**

1. **State management:** canonical rows live in `dcc.Store(id="store-data")`. The table displays a derived view (`status`, `line_value`) computed by `with_status()`.
2. **Editing:** grid edits trigger `data_timestamp` â†’ the callback sanitizes numbers and writes back to the store.
3. **Row ops:** add rows and restock selected rows by mutating the store data.
4. **Totals:** recomputed every time the store changes.
5. **Highlighting:** conditional styling marks lowâ€‘stock rows.
6. **Export:** `dcc.Download` returns a CSV of the current (derived) table.

---

## Styling Tips

* Fix column widths with `style_cell` or perâ€‘column `style_data`.
* Rightâ€‘align numerics with `{"if":{"column_type":"numeric"}, "textAlign":"right"}`.
* For dense tables, reduce padding: `style_cell={"padding":"6px"}`.

---

## Common Pitfalls

* Forgetting to keep a single source of truth for data (use `dcc.Store`).
* Not coercing numeric inputs â€” user edits may introduce strings.
* Recomputing derived columns in multiple places â€” centralize in a helper.

---

## Exercises

1. Add a **Category filter** dropdown above the table that filters rows serverâ€‘side.
2. Add a **Delete Selected** button that removes `selected_rows` from the dataset.
3. Add a **Summary by Category** table (groupby) under the totals panel.

---

## Takeaways

* `DataTable` covers 80% of grid UI needs in Dash.
* Keep canonical data in a store; derive and validate via callbacks.
* Combine conditional styles + server logic for a polished UX.
