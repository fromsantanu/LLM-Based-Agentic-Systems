# Chapter 19 — Combining Dash with Streamlit or FastAPI

## What you’ll learn

* How to run **Dash as the frontend** and **FastAPI as the backend**
* How to **submit a form in Dash → send JSON to FastAPI → show the result**
* Two deployment patterns:

  1. **Two-process** (Dash on port 8050, FastAPI on 8000)
  2. **Single process** (mount Dash inside FastAPI)
* Optional: Calling the same FastAPI from **Streamlit** for comparison

---

## Architecture at a glance

```
[User Browser]
      |
      v
   Dash App (Frontend, http://localhost:8050)
      |  POST JSON
      v
 FastAPI API (Backend, http://localhost:8000)
      |  JSON response
      v
   Dash displays result
```

---

## Prerequisites

```bash
pip install dash plotly fastapi uvicorn "pydantic>=2" httpx requests
# (optional) for CORS in dev:
pip install starlette
```

---

## Project layout

```
dash-fastapi-demo/
├─ backend/
│  └─ main.py          # FastAPI backend (validation & logic)
├─ frontend/
│  └─ app_dash.py      # Dash app (form → calls backend)
└─ README.md
```

---

## Step 1 — Build the FastAPI backend

The backend exposes a `/score` endpoint that accepts a JSON payload (a mini “order” form) and returns a computed score plus a friendly message.

**`backend/main.py`**

```python
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field, PositiveInt, conlist
from typing import List

# ----- Pydantic models -----
class LineItem(BaseModel):
    product_id: PositiveInt
    qty: PositiveInt = Field(..., description="Quantity must be positive")
    unit_price: float = Field(..., ge=0)

class OrderIn(BaseModel):
    customer_name: str = Field(..., min_length=1)
    email: str
    items: conlist(LineItem, min_length=1)
    notes: str | None = None

class OrderOut(BaseModel):
    total: float
    items_count: int
    message: str

# ----- FastAPI app -----
app = FastAPI(title="Order API")

# In dev, allow Dash (on 8050) to call FastAPI (on 8000)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:8050", "http://127.0.0.1:8050"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.post("/score", response_model=OrderOut)
def score_order(order: OrderIn):
    try:
        total = sum(li.qty * li.unit_price for li in order.items)
        items_count = sum(li.qty for li in order.items)
        msg = f"Thanks {order.customer_name}! We received {items_count} items."
        return OrderOut(total=round(total, 2), items_count=items_count, message=msg)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
```

**Run the backend:**

```bash
uvicorn backend.main:app --reload --port 8000
```

**Quick test (optional):**

```bash
curl -X POST http://127.0.0.1:8000/score \
  -H "Content-Type: application/json" \
  -d '{
    "customer_name": "Aditi",
    "email": "aditi@example.com",
    "items": [{"product_id":1,"qty":2,"unit_price":199.5}]
  }'
```

---

## Step 2 — Build the Dash frontend (form → POST → show result)

**`frontend/app_dash.py`**

```python
import json
import dash
from dash import dcc, html, Input, Output, State, callback_context
import requests

BACKEND_URL = "http://127.0.0.1:8000/score"

app = dash.Dash(__name__, title="Dash ↔ FastAPI Demo")
server = app.server  # for deployment scaffolding

# Simple catalog for the demo
PRODUCTS = [
    {"id": 1, "name": "Stethoscope", "price": 149.0},
    {"id": 2, "name": "Thermometer", "price": 49.5},
    {"id": 3, "name": "BP Monitor", "price": 219.0},
]

def product_options():
    return [{"label": f"{p['name']} (₹{p['price']})", "value": p["id"]} for p in PRODUCTS]

def price_of(pid):
    return next((p["price"] for p in PRODUCTS if p["id"] == pid), 0.0)

app.layout = html.Div(
    style={"maxWidth": 800, "margin": "40px auto", "fontFamily": "system-ui"},
    children=[
        html.H2("Order Form (Dash frontend)"),
        html.Div([
            html.Label("Customer Name"),
            dcc.Input(id="cust-name", type="text", placeholder="Your name", style={"width":"100%"}),
        ], style={"marginBottom":"10px"}),

        html.Div([
            html.Label("Email"),
            dcc.Input(id="cust-email", type="email", placeholder="you@example.com", style={"width":"100%"}),
        ], style={"marginBottom":"10px"}),

        html.Div([
            html.H4("Line Item 1"),
            dcc.Dropdown(id="prod-1", options=product_options(), placeholder="Select a product"),
            html.Br(),
            dcc.Input(id="qty-1", type="number", min=1, step=1, placeholder="Qty", value=1),
        ], style={"marginBottom":"20px"}),

        html.Div([
            html.H4("Line Item 2 (optional)"),
            dcc.Dropdown(id="prod-2", options=product_options(), placeholder="Select a product"),
            html.Br(),
            dcc.Input(id="qty-2", type="number", min=1, step=1, placeholder="Qty"),
        ], style={"marginBottom":"20px"}),

        html.Div([
            html.Label("Notes"),
            dcc.Textarea(id="notes", placeholder="Anything to add?", style={"width":"100%","height":"80px"}),
        ], style={"marginBottom":"20px"}),

        html.Button("Submit to FastAPI", id="submit", n_clicks=0, style={"padding":"8px 16px"}),
        html.Span(id="status", style={"marginLeft":"12px"}),

        html.Hr(),
        html.H3("Backend Response"),
        html.Pre(id="response", style={"whiteSpace":"pre-wrap", "background":"#111", "color":"#eee", "padding":"12px", "borderRadius":"8px"}),
    ]
)

@app.callback(
    Output("response", "children"),
    Output("status", "children"),
    Input("submit", "n_clicks"),
    State("cust-name", "value"),
    State("cust-email", "value"),
    State("prod-1", "value"),
    State("qty-1", "value"),
    State("prod-2", "value"),
    State("qty-2", "value"),
    State("notes", "value"),
    prevent_initial_call=True
)
def submit(n, name, email, p1, q1, p2, q2, notes):
    if not name or not email or not p1 or not q1:
        return "Please fill required fields (Name, Email, Line Item 1).", "❗ Missing fields"

    items = [
        {"product_id": p1, "qty": int(q1), "unit_price": float(price_of(p1))}
    ]
    if p2 and q2:
        items.append({"product_id": p2, "qty": int(q2), "unit_price": float(price_of(p2))})

    payload = {"customer_name": name, "email": email, "items": items, "notes": notes}

    try:
        res = requests.post(BACKEND_URL, json=payload, timeout=10)
        if res.ok:
            data = res.json()
            return json.dumps(data, indent=2), "✅ Submitted"
        else:
            return f"Error {res.status_code}: {res.text}", "❌ Error"
    except Exception as e:
        return f"Request failed: {e}", "❌ Network error"

if __name__ == "__main__":
    app.run_server(debug=True, port=8050)
```

**Run the frontend:**

```bash
python frontend/app_dash.py
```

Open `http://127.0.0.1:8050`, fill the form, click **Submit to FastAPI**, and the response will appear below.

> **Why CORS middleware?**
> During local dev we run on different ports (`8050` vs `8000`). CORS lets the browser call the backend safely.

---

## Step 3 — Async client (optional, cleaner under heavy load)

Swap `requests` with `httpx` for an async call to improve concurrency:

```python
# in frontend/app_dash.py
# pip install httpx
import httpx
import asyncio

# Replace the callback body with async call
@app.callback(
    Output("response", "children"),
    Output("status", "children"),
    Input("submit", "n_clicks"),
    State("cust-name", "value"),
    State("cust-email", "value"),
    State("prod-1", "value"),
    State("qty-1", "value"),
    State("prod-2", "value"),
    State("qty-2", "value"),
    State("notes", "value"),
    prevent_initial_call=True
)
def submit(n, name, email, p1, q1, p2, q2, notes):
    async def _go(payload):
        async with httpx.AsyncClient(timeout=10) as client:
            return await client.post(BACKEND_URL, json=payload)

    if not name or not email or not p1 or not q1:
        return "Please fill required fields (Name, Email, Line Item 1).", "❗ Missing fields"

    items = [{"product_id": p1, "qty": int(q1), "unit_price": float(price_of(p1))}]
    if p2 and q2:
        items.append({"product_id": p2, "qty": int(q2), "unit_price": float(price_of(p2))})
    payload = {"customer_name": name, "email": email, "items": items, "notes": notes}

    try:
        res = asyncio.run(_go(payload))
        if res.status_code == 200:
            return json.dumps(res.json(), indent=2), "✅ Submitted"
        return f"Error {res.status_code}: {res.text}", "❌ Error"
    except Exception as e:
        return f"Request failed: {e}", "❌ Network error"
```

---

## Step 4 — One-server pattern: Mount Dash inside FastAPI

This removes CORS and lets you deploy a single process.

**`serve_both.py`**

```python
from fastapi import FastAPI
from fastapi.middleware.wsgi import WSGIMiddleware
from pydantic import BaseModel
from dash import Dash, dcc, html, Input, Output, State
import json

# ----- FastAPI backend -----
class Order(BaseModel):
    name: str
    count: int

api = FastAPI()

@api.post("/calc")
def calc(order: Order):
    return {"reply": f"Hello {order.name}", "double": order.count * 2}

# ----- Dash app -----
dash_app = Dash(__name__)
dash_app.layout = html.Div([
    html.H3("Mounted Dash + FastAPI"),
    dcc.Input(id="name", placeholder="Name"),
    dcc.Input(id="count", type="number", placeholder="Count", value=1),
    html.Button("Send", id="send", n_clicks=0),
    html.Pre(id="out")
])

@dash_app.callback(
    Output("out", "children"),
    Input("send", "n_clicks"),
    State("name", "value"),
    State("count", "value"),
    prevent_initial_call=True
)
def go(n, name, count):
    import requests
    payload = {"name": name or "Guest", "count": int(count or 1)}
    r = requests.post("http://127.0.0.1:8000/calc", json=payload)
    return json.dumps(r.json(), indent=2)

# Mount Dash (a WSGI app) under FastAPI
api.mount("/", WSGIMiddleware(dash_app.server))

# Run: uvicorn serve_both:api --reload --port 8000
```

Visit `http://127.0.0.1:8000/` for Dash and `http://127.0.0.1:8000/calc` for the API.

**When to use which pattern?**

* **Two-process**: simpler mental model, easy scaling with separate containers.
* **Mounted**: fewer moving parts, no CORS, convenient for small apps or internal tools.

---

## Step 5 — Bonus: Use the same FastAPI with Streamlit

This snippet shows how a Streamlit form can call the same `/score` endpoint you built earlier (nice for side-by-side comparison).

```python
# streamlit_app.py
import streamlit as st
import requests

st.title("Streamlit ↔ FastAPI Demo")

name = st.text_input("Customer Name")
email = st.text_input("Email")
qty = st.number_input("Qty", min_value=1, step=1, value=1)
price = st.number_input("Unit Price", min_value=0.0, step=0.5, value=99.0)

if st.button("Submit"):
    payload = {
        "customer_name": name,
        "email": email,
        "items": [{"product_id": 1, "qty": int(qty), "unit_price": float(price)}]
    }
    r = requests.post("http://127.0.0.1:8000/score", json=payload, timeout=10)
    st.write(r.status_code, r.json() if r.ok else r.text)
```

Run with:

```bash
streamlit run streamlit_app.py
```

---

## Production tips

* **Validation**: keep strict Pydantic models; return helpful error messages.
* **Security**: add auth (JWT API tokens), rate-limit, and server-side validation.
* **Timeouts & retries**: use `httpx` with sensible timeouts; handle backend errors gracefully.
* **Observability**: log requests, add request IDs, and track latency.
* **Deploy**:

  * Two-process: containerize each, use Nginx or a reverse proxy; scale independently
  * Mounted: run with `gunicorn -k uvicorn.workers.UvicornWorker` for ASGI

---

## Recap

* You built a **clean Dash → FastAPI** pipeline for form submit & response.
* You saw **two deployment patterns** and a **Streamlit** variant using the same API.
* This pattern scales: swap the “score” logic for ML inference, DB writes, or workflows—no UI changes required.

