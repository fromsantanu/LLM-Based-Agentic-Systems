# **Chapter 18: Advanced Interactivity (Chained Callbacks)**

### **1. Understanding Chained Callbacks**

Chained callbacks are used when the output of one callback becomes the input of another.
This enables **multi-step user interactions** — for example:

* Selecting a **Country** filters available **Cities**
* Selecting a **City** updates a **Sales Chart**

They are especially useful for **hierarchical data selections** or **dependent filtering**.

---

### **2. Structure of a Chained Callback**

In Dash, callbacks are automatically triggered when their inputs change.
If an output of one callback is an input of another, Dash manages the update order automatically.

#### **Basic flow:**

```
User Interaction → Callback 1 → Intermediate Component → Callback 2 → Final Output
```

For example:

* Callback 1: updates a dropdown list of cities based on selected country
* Callback 2: updates a graph based on selected city

---

### **3. Avoiding Circular Callbacks**

Dash **does not allow circular dependencies** between callbacks.
A circular callback happens when component A updates B and B also updates A.

#### **To avoid circular issues:**

* Use **`dash.callback_context`** to control when a callback should trigger.
* Store intermediate data in **`dcc.Store`**.
* Combine related logic into **one callback** with multiple outputs if possible.

---

### **4. Example: Country → City → Sales Graph**

This example demonstrates chained callbacks that update the available city options and a sales chart dynamically.

```python
import dash
from dash import dcc, html, Input, Output
import plotly.express as px
import pandas as pd

# Sample Data
data = {
    'Country': ['USA', 'USA', 'USA', 'India', 'India', 'UK', 'UK'],
    'City': ['New York', 'Los Angeles', 'Chicago', 'Delhi', 'Mumbai', 'London', 'Manchester'],
    'Sales': [400, 350, 300, 280, 260, 310, 270]
}
df = pd.DataFrame(data)

# App Initialization
app = dash.Dash(__name__)

app.layout = html.Div([
    html.H2("Chained Callbacks Example: Country → City → Sales"),
    html.Label("Select Country:"),
    dcc.Dropdown(
        id='country-dropdown',
        options=[{'label': c, 'value': c} for c in df['Country'].unique()],
        value='USA'
    ),
    html.Br(),
    html.Label("Select City:"),
    dcc.Dropdown(id='city-dropdown'),
    html.Br(),
    dcc.Graph(id='sales-graph')
])

# Callback 1: Update city dropdown based on selected country
@app.callback(
    Output('city-dropdown', 'options'),
    Input('country-dropdown', 'value')
)
def update_city_dropdown(selected_country):
    filtered_df = df[df['Country'] == selected_country]
    return [{'label': city, 'value': city} for city in filtered_df['City'].unique()]

# Callback 2: Update graph based on selected city
@app.callback(
    Output('sales-graph', 'figure'),
    Input('city-dropdown', 'value'),
    Input('country-dropdown', 'value')
)
def update_graph(selected_city, selected_country):
    if selected_city is None:
        filtered_df = df[df['Country'] == selected_country]
    else:
        filtered_df = df[(df['Country'] == selected_country) & (df['City'] == selected_city)]

    fig = px.bar(filtered_df, x='City', y='Sales', title=f"Sales in {selected_country}")
    return fig

if __name__ == '__main__':
    app.run_server(debug=True)
```

---

### **5. Explanation**

1. **First dropdown (`country-dropdown`)**: lists countries.
2. **Second dropdown (`city-dropdown`)**: updated dynamically when a country is selected.
3. **Graph (`sales-graph`)**: updates based on the selected city (or all cities in a country).

---

### **6. Tips for Complex Interactions**

* **Use `dcc.Store`** to cache filtered data between callbacks.
* **Combine outputs** when multiple components depend on the same input.
* Use **callback chaining** for data refinement stages.
* To debug, print `dash.callback_context.triggered` to see which component caused the update.

---

### **7. Extended Example: Using `dcc.Store`**

This version caches filtered data between callbacks to reduce recomputation.

```python
app.layout = html.Div([
    html.H2("Optimized Chained Callback with dcc.Store"),
    dcc.Dropdown(id='country', options=[{'label': c, 'value': c} for c in df['Country'].unique()], value='USA'),
    dcc.Dropdown(id='city'),
    dcc.Store(id='filtered-data'),
    dcc.Graph(id='sales-chart')
])

@app.callback(
    Output('filtered-data', 'data'),
    Input('country', 'value')
)
def store_filtered_data(country):
    filtered = df[df['Country'] == country].to_dict('records')
    return filtered

@app.callback(
    Output('city', 'options'),
    Input('filtered-data', 'data')
)
def update_city_options(stored_data):
    filtered_df = pd.DataFrame(stored_data)
    return [{'label': c, 'value': c} for c in filtered_df['City'].unique()]

@app.callback(
    Output('sales-chart', 'figure'),
    Input('city', 'value'),
    Input('filtered-data', 'data')
)
def update_chart(selected_city, stored_data):
    df_filtered = pd.DataFrame(stored_data)
    if selected_city:
        df_filtered = df_filtered[df_filtered['City'] == selected_city]
    return px.bar(df_filtered, x='City', y='Sales', title='Sales Overview')
```

This approach:

* Reduces redundant filtering logic.
* Improves performance when working with large datasets.

---

### ✅ **Summary**

| Concept                | Description                                               |
| ---------------------- | --------------------------------------------------------- |
| **Chained Callbacks**  | When one callback’s output becomes another’s input        |
| **Circular Callbacks** | Not allowed — avoid mutual dependencies                   |
| **`dcc.Store`**        | Used for caching intermediate data                        |
| **Use Case**           | Hierarchical filters, dependent dropdowns, dynamic graphs |

---

### **Next Chapter → Chapter 19:**

**Performance Optimization and Caching**

Learn how to speed up large dashboards using `@cache.memoize`, `dcc.Store`, and efficient data handling strategies.

---
