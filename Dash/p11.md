# Chapter 11 — Real-Time Updates

## What you’ll learn

* How `dcc.Interval` works (polling cadence, start/stop, max runs).
* A robust pattern for periodic updates without freezing the UI.
* A complete **Live Temperature Sensor** dashboard (simulated).
* (Bonus) A lightweight **Stock Price Ticker**.
* Performance tips: throttling, caching, graceful stop, and UI polish.

---

## The core tool: `dcc.Interval`

`dcc.Interval` is a tiny timer component that **fires a callback every N milliseconds**. It’s “pull”-based (polling), which is perfect for simple real-time needs.

**Key props**

* `interval`: milliseconds between ticks (e.g., `1000` for 1s).
* `n_intervals`: increments on each tick (the input to your callback).
* `disabled`: `True` stops the clock; `False` resumes.
* `max_intervals`: stop after N ticks (e.g., `-1` = never stop).
* `id`: unique id for your callbacks.

**Typical callback signature**

```python
@app.callback(Output(...), Input("interval", "n_intervals"), State(...))
def update_every_tick(n, ...):
    ...
```

---

## Pattern you’ll reuse a lot

1. Add an `Interval` component to your layout.
2. Add a **toggle** to enable/disable updates.
3. Keep the last **N** points in memory (`dcc.Store`) to avoid unbounded growth.
4. In the callback, **append** new data, trim, and redraw the figure.
5. (Optional) Use a **spinner** or **status badge** to show “Live/Paused”.

---

## Example A — Live Temperature Sensor Dashboard (simulated)

**What it does**

* Simulates a sensor stream (random walk around 25–30 °C).
* Updates once per second.
* Shows:

  * A live line chart (last 120 seconds).
  * Current temp card with conditional color.
  * A status row: tick count, last update time.
  * Controls: Start/Stop, interval slider, history window slider.

> Save as `app_realtime_temperature.py` and run with `python app_realtime_temperature.py`

```python
import random
import time
from datetime import datetime
from collections import deque

import dash
from dash import dcc, html, Input, Output, State, callback, no_update
import plotly.graph_objs as go

app = dash.Dash(__name__)
server = app.server

# ---- Configs ----
DEFAULT_MS = 1000         # 1s
DEFAULT_HISTORY = 120     # points to keep
TEMP_MIN, TEMP_MAX = 24.0, 31.5

# We’ll keep a small deque on the client via dcc.Store (preferred) and mirror on server only to simulate drifting source.
# To keep this example self-contained, we simulate a persistent temp value here.
_sim_temp = 28.0

def _next_temp(prev):
    """Random-walk next temperature, mildly bounded."""
    step = random.uniform(-0.25, 0.25)
    val = max(TEMP_MIN - 1, min(TEMP_MAX + 1, prev + step))
    # add a tiny pull back toward 28 for stability
    val += (28.0 - val) * 0.02
    return round(val, 2)

def make_figure(xs, ys):
    return {
        "data": [
            go.Scatter(x=xs, y=ys, mode="lines+markers", name="Temp (°C)")
        ],
        "layout": go.Layout(
            margin=dict(l=40, r=20, t=40, b=40),
            yaxis=dict(title="°C", range=[TEMP_MIN - 0.5, TEMP_MAX + 0.5]),
            xaxis=dict(title="Time (last)", showgrid=True),
            uirevision="keep-zoom",  # keeps user zoom during updates
            template="plotly_white"
        ),
    }

def current_badge(temp):
    color = "#10b981" if 26 <= temp <= 30 else ("#f59e0b" if 25 <= temp < 26 or 30 < temp <= 31 else "#ef4444")
    return html.Div(
        [
            html.Div("Current Temp", style={"fontSize": 12, "opacity": 0.7}),
            html.Div(f"{temp:.2f} °C", style={"fontWeight": 700, "fontSize": 28}),
        ],
        style={
            "padding": "12px 16px", "borderRadius": 12, "background": color, "color": "white",
            "boxShadow": "0 4px 10px rgba(0,0,0,0.08)", "minWidth": 140, "textAlign": "center"
        },
    )

app.layout = html.Div(
    style={"fontFamily": "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial", "padding": 20, "maxWidth": 1100, "margin": "0 auto"},
    children=[
        html.H2("Live Temperature Sensor", style={"marginBottom": 6}),
        html.Div("Simulated data stream (random walk) with 1-second default polling.", style={"opacity": 0.7, "marginBottom": 20}),

        # Controls
        html.Div(
            style={"display": "grid", "gridTemplateColumns": "1fr 1fr 1fr", "gap": 16, "marginBottom": 16},
            children=[
                html.Div([
                    html.Label("Update Frequency (ms)"),
                    dcc.Slider(200, 5000, step=100, value=DEFAULT_MS, marks=None, tooltip={"placement": "bottom", "always_visible": True}, id="ms-slider"),
                ]),
                html.Div([
                    html.Label("History Window (points)"),
                    dcc.Slider(30, 600, step=10, value=DEFAULT_HISTORY, marks=None, tooltip={"placement": "bottom", "always_visible": True}, id="history-slider"),
                ]),
                html.Div([
                    html.Label("Controls"),
                    html.Div(
                        [
                            html.Button("Start", id="btn-start", n_clicks=0, style={"marginRight": 8}),
                            html.Button("Stop", id="btn-stop", n_clicks=0),
                        ],
                        style={"marginTop": 6}
                    ),
                ]),
            ],
        ),

        # Status
        html.Div(
            id="status-row",
            style={"display": "flex", "gap": 16, "alignItems": "center", "marginBottom": 12},
            children=[
                html.Div("Status: ", style={"fontWeight": 600}),
                html.Div(id="live-status", children="Paused"),
                html.Div("•"),
                html.Div(id="tick-count", children="Ticks: 0"),
                html.Div("•"),
                html.Div(id="last-update", children="Last: —"),
            ]
        ),

        # KPI + Chart
        html.Div(
            style={"display": "grid", "gridTemplateColumns": "200px 1fr", "gap": 16, "alignItems": "stretch"},
            children=[
                html.Div(id="current-badge"),
                dcc.Graph(id="temp-graph", figure=make_figure([], []), style={"height": 420}),
            ]
        ),

        # Client-side store for timeseries
        dcc.Store(id="series-store", data={"ts": [], "vals": []}),

        # Interval timer
        dcc.Interval(id="ticker", interval=DEFAULT_MS, n_intervals=0, disabled=True, max_intervals=-1),
    ],
)

# Toggle start/stop -> controls Interval.disabled
@callback(
    Output("ticker", "disabled"),
    Input("btn-start", "n_clicks"),
    Input("btn-stop", "n_clicks"),
    prevent_initial_call=True,
)
def toggle_interval(n_start, n_stop):
    ctx = dash.callback_context
    if not ctx.triggered:
        return no_update
    which = ctx.triggered[0]["prop_id"].split(".")[0]
    return which != "btn-start"  # start => False (enabled), stop => True (disabled)

# Adjust frequency on the fly
@callback(Output("ticker", "interval"), Input("ms-slider", "value"))
def set_interval(ms):
    return int(ms)

# Main tick handler: append latest point to series and redraw
@callback(
    Output("series-store", "data"),
    Output("temp-graph", "figure"),
    Output("current-badge", "children"),
    Output("tick-count", "children"),
    Output("last-update", "children"),
    Output("live-status", "children"),
    Input("ticker", "n_intervals"),
    State("series-store", "data"),
    State("history-slider", "value"),
    State("ticker", "disabled"),
)
def on_tick(n, series, keep, is_disabled):
    global _sim_temp
    if is_disabled:
        # If paused, don’t change anything; just reflect status.
        return series, no_update, no_update, f"Ticks: {n}", "Last: —", "Paused"

    # Simulate “reading” a sensor value
    _sim_temp = _next_temp(_sim_temp)
    now = datetime.now().strftime("%H:%M:%S")

    xs = series["ts"] if series else []
    ys = series["vals"] if series else []

    xs = (xs + [now])[-keep:]
    ys = (ys + [_sim_temp])[-keep:]

    fig = make_figure(xs, ys)
    badge = current_badge(_sim_temp)

    return {"ts": xs, "vals": ys}, fig, badge, f"Ticks: {n}", f"Last: {now}", "Live"

if __name__ == "__main__":
    app.run_server(debug=True)
```

### Why this works well

* **Doesn’t block**: The “work” per tick is tiny, so the UI stays smooth.
* **Bounded memory**: We trim to `history window` to avoid unbounded growth.
* **User control**: Start/Stop without resetting the line (thanks to `n_intervals`).
* **Keeps zoom**: `uirevision="keep-zoom"` preserves user zoom across updates.
* **Clear state**: `dcc.Store` concentrates the time-series in one place.

---

## Example B — Minimal Stock Price Ticker (simulated)

> Save as `app_stock_ticker_min.py` for a tiny demo (30 lines-ish).

```python
import random
from datetime import datetime
from collections import deque
import dash
from dash import dcc, html, Input, Output
import plotly.graph_objects as go

app = dash.Dash(__name__)

prices = deque(maxlen=180)
times = deque(maxlen=180)
last = 100.0

app.layout = html.Div([
    html.H3("Live Stock (Simulated)"),
    html.Div(id="price", style={"fontSize": 28, "fontWeight": 700, "marginBottom": 8}),
    dcc.Graph(id="chart", style={"height": 350}),
    dcc.Interval(id="t", interval=1000, n_intervals=0)
])

@app.callback(Output("price", "children"), Output("chart", "figure"), Input("t", "n_intervals"))
def tick(n):
    global last
    last += random.uniform(-0.6, 0.6)  # small random step
    last = max(80, min(125, last))
    prices.append(round(last, 2))
    times.append(datetime.now().strftime("%H:%M:%S"))
    fig = go.Figure(go.Scatter(x=list(times), y=list(prices), mode="lines"))
    fig.update_layout(template="plotly_white", margin=dict(l=30, r=20, t=10, b=40), yaxis_title="Price")
    return f"${prices[-1]:.2f}", fig

if __name__ == "__main__":
    app.run_server(debug=True)
```

> To hook up to *real* prices, move the “random step” to a function that calls your API (respect rate limits!), parse the last price, and append it just like above.

---

## Performance & UX tips

* **Throttle wisely**: Use the slowest interval that still feels real-time (e.g., 1–5 s for prices; 100–500 ms only for very fast sensors).
* **Avoid unbounded growth**: Keep only the last **N** points (e.g., 300–1000) or last **M** minutes.
* **Graceful pause**: Bind a toggle to `Interval.disabled`. When paused, **don’t** mutate data—return `no_update`.
* **Protect the backend**: If calling an external API:

  * **Cache** recent results (e.g., 2–5 s) to avoid hammering the source.
  * Add basic **retry/backoff** around transient errors.
  * Consider a **server-side job** (Celery/RQ) to fetch updates and store them, then let Dash read quickly from your store.
* **User feedback**: Show a status badge (“Live/Paused”), last updated time, and tick count.
* **Keep zoom**: Set `uirevision` in the figure’s layout so users don’t lose their custom view.
* **Cap runs**: For demos or time-boxed streams, set `max_intervals`.

---

## When polling isn’t enough (Push alternatives)

For ultra-low latency or high frequency:

* **WebSockets**: Push updates from server to client (community components or a small socket server proxied by your Flask app).
* **Server-Sent Events (SSE)**: Simpler one-way streaming for logs/feeds.
* **dash-extensions**: Offers WebSocket components and other helpers.

Polling with `dcc.Interval` remains the **simplest** and is often sufficient.

---

## Exercises

1. **Alarm line**: Add a horizontal threshold (e.g., 30 °C) and change the card color when crossed.
2. **CSV snapshot**: Add a “Download last 2 minutes” button using `dcc.send_data_frame`.
3. **Multi-sensor**: Simulate 3 sensors (A/B/C) with different noise profiles and a toggle to show/hide traces.
4. **API adapter**: Replace the simulator with a real endpoint you control; implement simple caching to keep API calls ≤ 1/sec.

---

### Quick checklist

* [ ] Do I really need sub-second updates?
* [ ] Is my history bounded?
* [ ] Can users pause/resume?
* [ ] Do I show “last updated” clearly?
* [ ] Am I respecting API rate limits?

You’re now ready to add **live** features to your Dash apps—cleanly, safely, and with a great UX.

