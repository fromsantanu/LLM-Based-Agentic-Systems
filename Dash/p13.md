# **Chapter 13: Callbacks with Pattern Matching**

### **Overview**

When building interactive dashboards, sometimes you need to **dynamically generate components** — such as adding or removing input fields, rows, or charts — and still make them **reactive** using callbacks.
In such cases, **pattern matching callbacks** come to the rescue.

Dash provides three special wildcard selectors for handling dynamic components:

* `MATCH`
* `ALL`
* `ALLSMALLER`

These allow callbacks to **match multiple components dynamically**, even those created after the app starts running.

---

### **13.1 When to Use Pattern Matching**

Pattern matching is useful when:

* You have **a variable number of similar components**, such as dynamic form rows or items in a list.
* You need **fine-grained control** to update one specific component (`MATCH`).
* You want **a grouped update** for all components of a certain pattern (`ALL`).
* You need **hierarchical or nested control**, where parent callbacks affect only smaller indices (`ALLSMALLER`).

---

### **13.2 The Three Selectors**

| Selector     | Use Case                                                              | Example ID Format                              | Description                                           |
| ------------ | --------------------------------------------------------------------- | ---------------------------------------------- | ----------------------------------------------------- |
| `MATCH`      | To target one specific dynamically generated component                | `{"type": "input-field", "index": 3}`          | Used when each component should have its own callback |
| `ALL`        | To target **all components** of a type                                | `{"type": "input-field", "index": ALL}`        | Used when one action updates all matching components  |
| `ALLSMALLER` | To target components with **smaller indices** than the triggering one | `{"type": "input-field", "index": ALLSMALLER}` | Useful for hierarchical or sequential updates         |

---

### **13.3 Syntax Example**

```python
from dash import Dash, html, dcc, Input, Output, State, ctx, MATCH, ALL
import dash_bootstrap_components as dbc

app = Dash(__name__, external_stylesheets=[dbc.themes.FLATLY])

app.layout = html.Div([
    html.H3("Dynamic Invoice Entry Form"),
    html.Div(id='invoice-container', children=[]),
    html.Button('Add Product', id='add-btn', n_clicks=0),
    html.Button('Remove Last', id='remove-btn', n_clicks=0),
    html.Hr(),
    html.Div(id='total-display')
])

# Callback to dynamically add/remove product lines
@app.callback(
    Output('invoice-container', 'children'),
    Input('add-btn', 'n_clicks'),
    Input('remove-btn', 'n_clicks'),
    State('invoice-container', 'children'),
    prevent_initial_call=True
)
def modify_rows(add_clicks, remove_clicks, children):
    triggered_id = ctx.triggered_id
    if triggered_id == 'add-btn':
        new_index = len(children)
        new_row = html.Div([
            dcc.Input(
                id={'type': 'product', 'index': new_index},
                placeholder=f'Product {new_index + 1}',
                style={'width': '40%'}
            ),
            dcc.Input(
                id={'type': 'quantity', 'index': new_index},
                placeholder='Qty',
                type='number',
                style={'width': '20%'}
            ),
            dcc.Input(
                id={'type': 'price', 'index': new_index},
                placeholder='Price',
                type='number',
                style={'width': '20%'}
            ),
        ], style={'margin-bottom': '10px'})
        children.append(new_row)
    elif triggered_id == 'remove-btn' and children:
        children.pop()
    return children

# Callback to calculate total price dynamically
@app.callback(
    Output('total-display', 'children'),
    Input({'type': 'quantity', 'index': ALL}, 'value'),
    Input({'type': 'price', 'index': ALL}, 'value')
)
def calculate_total(qty_values, price_values):
    total = 0
    for q, p in zip(qty_values, price_values):
        if q and p:
            total += q * p
    return f"Total Invoice Amount: ₹{total:.2f}" if total > 0 else ""

if __name__ == '__main__':
    app.run_server(debug=True)
```

---

### **13.4 Explanation**

1. **Dynamic Component IDs:**
   Each input has an ID dictionary like:

   ```python
   {'type': 'price', 'index': 1}
   ```

   allowing callbacks to identify each input dynamically.

2. **Adding/Removing Rows:**
   The `modify_rows` callback dynamically adds or removes input rows inside the `invoice-container`.

3. **Pattern Matching Callback:**
   The second callback listens to **all `quantity` and `price` inputs** using `ALL`, recalculating totals whenever any of them changes.

4. **Contextual Trigger (`ctx`):**
   Dash’s `ctx.triggered_id` tells which button caused the update.

---

### **13.5 Key Takeaways**

* Use **pattern matching** to handle **dynamic, variable, or nested UI components**.
* `MATCH` = update one specific component.
* `ALL` = update all components of a type.
* `ALLSMALLER` = update components below a certain hierarchy.
* Keep your callback logic clean and modular by leveraging **ID dictionaries**.

---

### ✅ **Example Output**

When you run the app:

* Click **“Add Product”** to create a new row of inputs.
* Enter quantity and price for each product.
* The total updates automatically as you type.
* Click **“Remove Last”** to delete the most recent entry.

---

### **End of Chapter 13**

Next: **Chapter 14 – Advanced Callbacks and State Management**

---
